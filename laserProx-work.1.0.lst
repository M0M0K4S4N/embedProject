CCS PCM C Compiler, Version 5.063, 32906               29-Mar-17 19:37

               Filename:   D:\#cpeembed\#project\laserProx-work.1.0.lst

               ROM used:   7991 words (98%)
                           Largest free fragment is 98
               RAM used:   83 (23%) at main() level
                           199 (54%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  1C
0001:  MOVWF  0A
0002:  GOTO   487
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   061
.................... /* This example shows how to get single-shot range 
....................  measurements from the VL53L0X. The sensor can optionally be 
....................  configured with different ranging profiles, as described in 
....................  the VL53L0X API user manual, to get better performance for 
....................  a certain application. This code is based on the four 
....................  "SingleRanging" examples in the VL53L0X API. 
....................  
....................  The range readings are in units of mm. */ 
.................... #include "VL53L0X/pic16f886.h" 
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  43
0056:  RETLW  61
0057:  RETLW  6C
0058:  RETLW  69
0059:  RETLW  62
005A:  RETLW  72
005B:  RETLW  61
005C:  RETLW  74
005D:  RETLW  65
005E:  RETLW  64
005F:  RETLW  21
0060:  RETLW  00
*
0072:  DATA 53,3A
0073:  DATA 61,39
0074:  DATA F4,34
0075:  DATA EE,33
0076:  DATA 0D,05
0077:  DATA 00,00
0078:  DATA 20,2A
0079:  DATA C9,26
007A:  DATA C5,27
007B:  DATA 55,2A
007C:  DATA 0D,05
007D:  DATA 00,00
007E:  DATA D3,30
007F:  DATA 6D,38
0080:  DATA EC,34
0081:  DATA EE,33
0082:  DATA BA,06
0083:  DATA 0A,00
0084:  DATA D3,32
0085:  DATA EE,39
0086:  DATA 6F,39
0087:  DATA 3D,10
0088:  DATA 25,26
0089:  DATA F5,04
008A:  DATA C4,32
008B:  DATA 67,39
008C:  DATA E5,32
008D:  DATA 3D,10
008E:  DATA 25,17
008F:  DATA 32,33
0090:  DATA 09,22
0091:  DATA E9,39
0092:  DATA F4,1E
0093:  DATA A0,12
0094:  DATA 2E,19
0095:  DATA 66,10
0096:  DATA E3,36
0097:  DATA 20,10
0098:  DATA F4,30
0099:  DATA 6C,36
009A:  DATA BD,12
009B:  DATA 66,10
009C:  DATA E3,36
009D:  DATA 0D,05
009E:  DATA 00,00
009F:  DATA AD,16
00A0:  DATA AD,16
00A1:  DATA 00,00
00A2:  MOVF   0B,W
00A3:  MOVWF  68
00A4:  BCF    0B.7
00A5:  BSF    03.5
00A6:  BSF    03.6
00A7:  BSF    0C.7
00A8:  BSF    0C.0
00A9:  NOP
00AA:  NOP
00AB:  BCF    03.5
00AC:  BCF    03.6
00AD:  BTFSC  68.7
00AE:  BSF    0B.7
00AF:  BSF    03.6
00B0:  MOVF   0C,W
00B1:  ANDLW  7F
00B2:  BTFSC  03.2
00B3:  GOTO   0F8
00B4:  BCF    03.6
00B5:  MOVWF  68
00B6:  BSF    03.6
00B7:  MOVF   0D,W
00B8:  BCF    03.6
00B9:  MOVWF  69
00BA:  BSF    03.6
00BB:  MOVF   0F,W
00BC:  BCF    03.6
00BD:  MOVWF  6A
00BE:  MOVF   68,W
00BF:  BTFSS  0C.4
00C0:  GOTO   0BF
00C1:  MOVWF  19
00C2:  MOVF   69,W
00C3:  BSF    03.6
00C4:  MOVWF  0D
00C5:  BCF    03.6
00C6:  MOVF   6A,W
00C7:  BSF    03.6
00C8:  MOVWF  0F
00C9:  BCF    03.6
00CA:  MOVF   0B,W
00CB:  MOVWF  6B
00CC:  BCF    0B.7
00CD:  BSF    03.5
00CE:  BSF    03.6
00CF:  BSF    0C.7
00D0:  BSF    0C.0
00D1:  NOP
00D2:  NOP
00D3:  BCF    03.5
00D4:  BCF    03.6
00D5:  BTFSC  6B.7
00D6:  BSF    0B.7
00D7:  BSF    03.6
00D8:  RLF    0C,W
00D9:  RLF    0E,W
00DA:  ANDLW  7F
00DB:  BTFSC  03.2
00DC:  GOTO   0F8
00DD:  BCF    03.6
00DE:  MOVWF  68
00DF:  BSF    03.6
00E0:  MOVF   0D,W
00E1:  BCF    03.6
00E2:  MOVWF  69
00E3:  BSF    03.6
00E4:  MOVF   0F,W
00E5:  BCF    03.6
00E6:  MOVWF  6A
00E7:  MOVF   68,W
00E8:  BTFSS  0C.4
00E9:  GOTO   0E8
00EA:  MOVWF  19
00EB:  MOVF   69,W
00EC:  BSF    03.6
00ED:  MOVWF  0D
00EE:  BCF    03.6
00EF:  MOVF   6A,W
00F0:  BSF    03.6
00F1:  MOVWF  0F
00F2:  INCF   0D,F
00F3:  BTFSC  03.2
00F4:  INCF   0F,F
00F5:  BCF    03.6
00F6:  GOTO   0A2
00F7:  BSF    03.6
00F8:  BCF    03.6
00F9:  RETURN
*
015E:  BSF    03.5
015F:  MOVF   4F,W
0160:  MOVWF  56
0161:  MOVF   53,W
0162:  XORWF  56,F
0163:  BTFSS  56.7
0164:  GOTO   16A
0165:  BCF    03.2
0166:  BCF    03.0
0167:  BTFSC  4F.7
0168:  BSF    03.0
0169:  GOTO   19D
016A:  MOVF   4F,W
016B:  MOVWF  56
016C:  MOVF   52,W
016D:  MOVWF  57
016E:  MOVF   4E,W
016F:  SUBWF  57,F
0170:  BTFSC  03.2
0171:  GOTO   178
0172:  BTFSS  56.7
0173:  GOTO   19D
0174:  MOVF   03,W
0175:  XORLW  01
0176:  MOVWF  03
0177:  GOTO   19D
0178:  MOVF   53,W
0179:  MOVWF  57
017A:  MOVF   4F,W
017B:  SUBWF  57,F
017C:  BTFSC  03.2
017D:  GOTO   184
017E:  BTFSS  56.7
017F:  GOTO   19D
0180:  MOVF   03,W
0181:  XORLW  01
0182:  MOVWF  03
0183:  GOTO   19D
0184:  MOVF   54,W
0185:  MOVWF  57
0186:  MOVF   50,W
0187:  SUBWF  57,F
0188:  BTFSC  03.2
0189:  GOTO   190
018A:  BTFSS  56.7
018B:  GOTO   19D
018C:  MOVF   03,W
018D:  XORLW  01
018E:  MOVWF  03
018F:  GOTO   19D
0190:  MOVF   55,W
0191:  MOVWF  57
0192:  MOVF   51,W
0193:  SUBWF  57,F
0194:  BTFSC  03.2
0195:  GOTO   19C
0196:  BTFSS  56.7
0197:  GOTO   19D
0198:  MOVF   03,W
0199:  XORLW  01
019A:  MOVWF  03
019B:  GOTO   19D
019C:  BCF    03.0
019D:  BCF    03.5
019E:  RETURN
019F:  BSF    03.5
01A0:  MOVF   52,W
01A1:  BTFSC  03.2
01A2:  GOTO   210
01A3:  MOVWF  5A
01A4:  MOVF   56,W
01A5:  BTFSC  03.2
01A6:  GOTO   210
01A7:  ADDWF  5A,F
01A8:  BTFSC  03.0
01A9:  GOTO   1B1
01AA:  MOVLW  7F
01AB:  SUBWF  5A,F
01AC:  BTFSS  03.0
01AD:  GOTO   210
01AE:  BTFSC  03.2
01AF:  GOTO   210
01B0:  GOTO   1B5
01B1:  MOVLW  81
01B2:  ADDWF  5A,F
01B3:  BTFSC  03.0
01B4:  GOTO   210
01B5:  MOVF   5A,W
01B6:  MOVWF  77
01B7:  CLRF   78
01B8:  CLRF   79
01B9:  CLRF   7A
01BA:  MOVF   53,W
01BB:  MOVWF  5E
01BC:  BSF    5E.7
01BD:  MOVF   54,W
01BE:  MOVWF  5D
01BF:  MOVF   55,W
01C0:  MOVWF  5C
01C1:  MOVLW  18
01C2:  MOVWF  5A
01C3:  CLRF   5B
01C4:  BTFSS  5C.0
01C5:  GOTO   1DE
01C6:  MOVF   59,W
01C7:  ADDWF  7A,F
01C8:  BTFSS  03.0
01C9:  GOTO   1D0
01CA:  INCF   79,F
01CB:  BTFSS  03.2
01CC:  GOTO   1D0
01CD:  INCF   78,F
01CE:  BTFSC  03.2
01CF:  BSF    5B.7
01D0:  MOVF   58,W
01D1:  ADDWF  79,F
01D2:  BTFSS  03.0
01D3:  GOTO   1D7
01D4:  INCF   78,F
01D5:  BTFSC  03.2
01D6:  BSF    5B.7
01D7:  MOVF   57,W
01D8:  MOVWF  54
01D9:  BSF    54.7
01DA:  MOVF   54,W
01DB:  ADDWF  78,F
01DC:  BTFSC  03.0
01DD:  BSF    5B.7
01DE:  RLF    5B,F
01DF:  RRF    78,F
01E0:  RRF    79,F
01E1:  RRF    7A,F
01E2:  RRF    5E,F
01E3:  RRF    5D,F
01E4:  RRF    5C,F
01E5:  BCF    03.0
01E6:  DECFSZ 5A,F
01E7:  GOTO   1C3
01E8:  MOVLW  01
01E9:  ADDWF  77,F
01EA:  BTFSC  03.0
01EB:  GOTO   210
01EC:  BTFSC  78.7
01ED:  GOTO   1F5
01EE:  RLF    5E,F
01EF:  RLF    7A,F
01F0:  RLF    79,F
01F1:  RLF    78,F
01F2:  DECF   77,F
01F3:  BTFSC  03.2
01F4:  GOTO   210
01F5:  BTFSS  5E.7
01F6:  GOTO   206
01F7:  INCF   7A,F
01F8:  BTFSS  03.2
01F9:  GOTO   206
01FA:  INCF   79,F
01FB:  BTFSS  03.2
01FC:  GOTO   206
01FD:  INCF   78,F
01FE:  BTFSS  03.2
01FF:  GOTO   206
0200:  RRF    78,F
0201:  RRF    79,F
0202:  RRF    7A,F
0203:  INCF   77,F
0204:  BTFSC  03.2
0205:  GOTO   210
0206:  MOVF   53,W
0207:  MOVWF  5B
0208:  MOVF   57,W
0209:  XORWF  5B,F
020A:  BTFSS  5B.7
020B:  GOTO   20E
020C:  BSF    78.7
020D:  GOTO   214
020E:  BCF    78.7
020F:  GOTO   214
0210:  CLRF   77
0211:  CLRF   78
0212:  CLRF   79
0213:  CLRF   7A
0214:  BCF    03.5
0215:  RETURN
0216:  MOVLW  8E
0217:  MOVWF  77
0218:  BSF    03.5
0219:  MOVF   4E,W
021A:  SUBWF  77,F
021B:  MOVF   4F,W
021C:  MOVWF  79
021D:  MOVF   50,W
021E:  MOVWF  78
021F:  BSF    79.7
0220:  MOVF   77,F
0221:  BTFSC  03.2
0222:  GOTO   22E
0223:  BCF    03.0
0224:  MOVF   79,F
0225:  BTFSS  03.2
0226:  GOTO   22A
0227:  MOVF   78,F
0228:  BTFSC  03.2
0229:  GOTO   22E
022A:  RRF    79,F
022B:  RRF    78,F
022C:  DECFSZ 77,F
022D:  GOTO   223
022E:  BTFSS  4F.7
022F:  GOTO   235
0230:  COMF   78,F
0231:  COMF   79,F
0232:  INCF   78,F
0233:  BTFSC  03.2
0234:  INCF   79,F
0235:  BCF    03.5
0236:  RETURN
*
0377:  MOVLW  20
0378:  BSF    03.6
0379:  MOVWF  24
037A:  CLRF   20
037B:  CLRF   21
037C:  CLRF   22
037D:  CLRF   23
037E:  MOVF   1B,W
037F:  MOVWF  7A
0380:  MOVF   1A,W
0381:  MOVWF  79
0382:  MOVF   19,W
0383:  MOVWF  78
0384:  MOVF   18,W
0385:  MOVWF  77
0386:  BCF    03.0
0387:  BTFSS  77.0
0388:  GOTO   397
0389:  MOVF   1C,W
038A:  ADDWF  20,F
038B:  MOVF   1D,W
038C:  BTFSC  03.0
038D:  INCFSZ 1D,W
038E:  ADDWF  21,F
038F:  MOVF   1E,W
0390:  BTFSC  03.0
0391:  INCFSZ 1E,W
0392:  ADDWF  22,F
0393:  MOVF   1F,W
0394:  BTFSC  03.0
0395:  INCFSZ 1F,W
0396:  ADDWF  23,F
0397:  RRF    23,F
0398:  RRF    22,F
0399:  RRF    21,F
039A:  RRF    20,F
039B:  RRF    7A,F
039C:  RRF    79,F
039D:  RRF    78,F
039E:  RRF    77,F
039F:  DECFSZ 24,F
03A0:  GOTO   386
03A1:  BCF    03.6
03A2:  RETURN
03A3:  BTFSC  03.1
03A4:  GOTO   3A8
03A5:  MOVLW  20
03A6:  MOVWF  04
03A7:  BSF    03.7
03A8:  CLRF   77
03A9:  CLRF   78
03AA:  CLRF   79
03AB:  CLRF   7A
03AC:  BSF    03.6
03AD:  CLRF   20
03AE:  CLRF   21
03AF:  CLRF   22
03B0:  CLRF   23
03B1:  MOVF   1F,W
03B2:  IORWF  1E,W
03B3:  IORWF  1D,W
03B4:  IORWF  1C,W
03B5:  BTFSC  03.2
03B6:  GOTO   3E7
03B7:  MOVLW  20
03B8:  MOVWF  24
03B9:  BCF    03.0
03BA:  RLF    18,F
03BB:  RLF    19,F
03BC:  RLF    1A,F
03BD:  RLF    1B,F
03BE:  RLF    20,F
03BF:  RLF    21,F
03C0:  RLF    22,F
03C1:  RLF    23,F
03C2:  MOVF   1F,W
03C3:  SUBWF  23,W
03C4:  BTFSS  03.2
03C5:  GOTO   3D0
03C6:  MOVF   1E,W
03C7:  SUBWF  22,W
03C8:  BTFSS  03.2
03C9:  GOTO   3D0
03CA:  MOVF   1D,W
03CB:  SUBWF  21,W
03CC:  BTFSS  03.2
03CD:  GOTO   3D0
03CE:  MOVF   1C,W
03CF:  SUBWF  20,W
03D0:  BTFSS  03.0
03D1:  GOTO   3E1
03D2:  MOVF   1C,W
03D3:  SUBWF  20,F
03D4:  MOVF   1D,W
03D5:  BTFSS  03.0
03D6:  INCFSZ 1D,W
03D7:  SUBWF  21,F
03D8:  MOVF   1E,W
03D9:  BTFSS  03.0
03DA:  INCFSZ 1E,W
03DB:  SUBWF  22,F
03DC:  MOVF   1F,W
03DD:  BTFSS  03.0
03DE:  INCFSZ 1F,W
03DF:  SUBWF  23,F
03E0:  BSF    03.0
03E1:  RLF    77,F
03E2:  RLF    78,F
03E3:  RLF    79,F
03E4:  RLF    7A,F
03E5:  DECFSZ 24,F
03E6:  GOTO   3B9
03E7:  MOVF   20,W
03E8:  MOVWF  00
03E9:  INCF   04,F
03EA:  MOVF   21,W
03EB:  MOVWF  00
03EC:  INCF   04,F
03ED:  MOVF   22,W
03EE:  MOVWF  00
03EF:  INCF   04,F
03F0:  MOVF   23,W
03F1:  MOVWF  00
03F2:  BCF    03.6
03F3:  RETURN
*
07BB:  MOVLW  8E
07BC:  MOVWF  77
07BD:  BSF    03.5
07BE:  MOVF   53,W
07BF:  MOVWF  78
07C0:  MOVF   52,W
07C1:  MOVWF  79
07C2:  CLRF   7A
07C3:  MOVF   78,F
07C4:  BTFSS  03.2
07C5:  GOTO   7D0
07C6:  MOVF   79,W
07C7:  MOVWF  78
07C8:  CLRF   79
07C9:  MOVLW  08
07CA:  SUBWF  77,F
07CB:  MOVF   78,F
07CC:  BTFSS  03.2
07CD:  GOTO   7D0
07CE:  CLRF   77
07CF:  GOTO   7D8
07D0:  BCF    03.0
07D1:  BTFSC  78.7
07D2:  GOTO   7D7
07D3:  RLF    79,F
07D4:  RLF    78,F
07D5:  DECF   77,F
07D6:  GOTO   7D0
07D7:  BCF    78.7
07D8:  BCF    03.5
07D9:  RETURN
*
07ED:  MOVF   3C,W
07EE:  MOVWF  04
07EF:  BCF    03.7
07F0:  BTFSC  3D.0
07F1:  BSF    03.7
07F2:  BSF    03.5
07F3:  MOVF   28,W
07F4:  MOVWF  00
07F5:  INCF   04,F
07F6:  CLRF   00
07F7:  BCF    03.5
07F8:  INCF   3C,F
07F9:  BTFSC  03.2
07FA:  INCF   3D,F
07FB:  RETURN
*
0D66:  MOVF   7B,W
0D67:  BTFSC  03.2
0D68:  GOTO   638
0D69:  BSF    03.5
0D6A:  MOVWF  28
0D6B:  MOVF   20,W
0D6C:  BTFSS  03.2
0D6D:  GOTO   570
0D6E:  BCF    03.5
0D6F:  GOTO   638
0D70:  SUBWF  28,F
0D71:  BTFSS  03.0
0D72:  GOTO   57A
0D73:  MOVLW  7F
0D74:  ADDWF  28,F
0D75:  BTFSS  03.0
0D76:  GOTO   579
0D77:  BCF    03.5
0D78:  GOTO   638
0D79:  GOTO   584
0D7A:  MOVLW  81
0D7B:  SUBWF  28,F
0D7C:  BTFSC  03.0
0D7D:  GOTO   580
0D7E:  BCF    03.5
0D7F:  GOTO   638
0D80:  BTFSS  03.2
0D81:  GOTO   584
0D82:  BCF    03.5
0D83:  GOTO   638
0D84:  MOVF   28,W
0D85:  MOVWF  77
0D86:  CLRF   78
0D87:  CLRF   79
0D88:  CLRF   7A
0D89:  CLRF   27
0D8A:  MOVF   7C,W
0D8B:  MOVWF  26
0D8C:  BSF    26.7
0D8D:  MOVF   7D,W
0D8E:  MOVWF  25
0D8F:  MOVF   7E,W
0D90:  MOVWF  24
0D91:  MOVLW  19
0D92:  MOVWF  28
0D93:  MOVF   23,W
0D94:  SUBWF  24,F
0D95:  BTFSC  03.0
0D96:  GOTO   5A7
0D97:  MOVLW  01
0D98:  SUBWF  25,F
0D99:  BTFSC  03.0
0D9A:  GOTO   5A7
0D9B:  SUBWF  26,F
0D9C:  BTFSC  03.0
0D9D:  GOTO   5A7
0D9E:  SUBWF  27,F
0D9F:  BTFSC  03.0
0DA0:  GOTO   5A7
0DA1:  INCF   27,F
0DA2:  INCF   26,F
0DA3:  INCF   25,F
0DA4:  MOVF   23,W
0DA5:  ADDWF  24,F
0DA6:  GOTO   5D9
0DA7:  MOVF   22,W
0DA8:  SUBWF  25,F
0DA9:  BTFSC  03.0
0DAA:  GOTO   5C2
0DAB:  MOVLW  01
0DAC:  SUBWF  26,F
0DAD:  BTFSC  03.0
0DAE:  GOTO   5C2
0DAF:  SUBWF  27,F
0DB0:  BTFSC  03.0
0DB1:  GOTO   5C2
0DB2:  INCF   27,F
0DB3:  INCF   26,F
0DB4:  MOVF   22,W
0DB5:  ADDWF  25,F
0DB6:  MOVF   23,W
0DB7:  ADDWF  24,F
0DB8:  BTFSS  03.0
0DB9:  GOTO   5D9
0DBA:  INCF   25,F
0DBB:  BTFSS  03.2
0DBC:  GOTO   5D9
0DBD:  INCF   26,F
0DBE:  BTFSS  03.2
0DBF:  GOTO   5D9
0DC0:  INCF   27,F
0DC1:  GOTO   5D9
0DC2:  MOVF   21,W
0DC3:  IORLW  80
0DC4:  SUBWF  26,F
0DC5:  BTFSC  03.0
0DC6:  GOTO   5D8
0DC7:  MOVLW  01
0DC8:  SUBWF  27,F
0DC9:  BTFSC  03.0
0DCA:  GOTO   5D8
0DCB:  INCF   27,F
0DCC:  MOVF   21,W
0DCD:  IORLW  80
0DCE:  ADDWF  26,F
0DCF:  MOVF   22,W
0DD0:  ADDWF  25,F
0DD1:  BTFSS  03.0
0DD2:  GOTO   5B6
0DD3:  INCF   26,F
0DD4:  BTFSS  03.2
0DD5:  GOTO   5B6
0DD6:  INCF   27,F
0DD7:  GOTO   5B6
0DD8:  BSF    7A.0
0DD9:  DECFSZ 28,F
0DDA:  GOTO   5DC
0DDB:  GOTO   5E7
0DDC:  BCF    03.0
0DDD:  RLF    24,F
0DDE:  RLF    25,F
0DDF:  RLF    26,F
0DE0:  RLF    27,F
0DE1:  BCF    03.0
0DE2:  RLF    7A,F
0DE3:  RLF    79,F
0DE4:  RLF    78,F
0DE5:  RLF    29,F
0DE6:  GOTO   593
0DE7:  BTFSS  29.0
0DE8:  GOTO   5EF
0DE9:  BCF    03.0
0DEA:  RRF    78,F
0DEB:  RRF    79,F
0DEC:  RRF    7A,F
0DED:  RRF    29,F
0DEE:  GOTO   5F3
0DEF:  DECFSZ 77,F
0DF0:  GOTO   5F3
0DF1:  BCF    03.5
0DF2:  GOTO   638
0DF3:  BTFSC  29.7
0DF4:  GOTO   61C
0DF5:  BCF    03.0
0DF6:  RLF    24,F
0DF7:  RLF    25,F
0DF8:  RLF    26,F
0DF9:  RLF    27,F
0DFA:  MOVF   23,W
0DFB:  SUBWF  24,F
0DFC:  BTFSC  03.0
0DFD:  GOTO   608
0DFE:  MOVLW  01
0DFF:  SUBWF  25,F
0E00:  BTFSC  03.0
0E01:  GOTO   608
0E02:  SUBWF  26,F
0E03:  BTFSC  03.0
0E04:  GOTO   608
0E05:  SUBWF  27,F
0E06:  BTFSS  03.0
0E07:  GOTO   62D
0E08:  MOVF   22,W
0E09:  SUBWF  25,F
0E0A:  BTFSC  03.0
0E0B:  GOTO   613
0E0C:  MOVLW  01
0E0D:  SUBWF  26,F
0E0E:  BTFSC  03.0
0E0F:  GOTO   613
0E10:  SUBWF  27,F
0E11:  BTFSS  03.0
0E12:  GOTO   62D
0E13:  MOVF   21,W
0E14:  IORLW  80
0E15:  SUBWF  26,F
0E16:  BTFSC  03.0
0E17:  GOTO   61C
0E18:  MOVLW  01
0E19:  SUBWF  27,F
0E1A:  BTFSS  03.0
0E1B:  GOTO   62D
0E1C:  INCF   7A,F
0E1D:  BTFSS  03.2
0E1E:  GOTO   62D
0E1F:  INCF   79,F
0E20:  BTFSS  03.2
0E21:  GOTO   62D
0E22:  INCF   78,F
0E23:  BTFSS  03.2
0E24:  GOTO   62D
0E25:  INCF   77,F
0E26:  BTFSS  03.2
0E27:  GOTO   62A
0E28:  BCF    03.5
0E29:  GOTO   638
0E2A:  RRF    78,F
0E2B:  RRF    79,F
0E2C:  RRF    7A,F
0E2D:  MOVF   7C,W
0E2E:  MOVWF  28
0E2F:  MOVF   21,W
0E30:  XORWF  28,F
0E31:  BTFSS  28.7
0E32:  GOTO   635
0E33:  BSF    78.7
0E34:  GOTO   63D
0E35:  BCF    78.7
0E36:  GOTO   63D
0E37:  BCF    03.5
0E38:  CLRF   77
0E39:  CLRF   78
0E3A:  CLRF   79
0E3B:  CLRF   7A
0E3C:  BSF    03.5
0E3D:  BCF    03.5
0E3E:  RETURN
*
1599:  MOVLW  80
159A:  BTFSS  03.1
159B:  GOTO   59F
159C:  BSF    03.5
159D:  XORWF  57,F
159E:  BCF    03.5
159F:  BSF    03.5
15A0:  CLRF   5C
15A1:  CLRF   5D
15A2:  MOVF   53,W
15A3:  MOVWF  5B
15A4:  MOVF   57,W
15A5:  XORWF  5B,F
15A6:  MOVF   52,W
15A7:  BTFSC  03.2
15A8:  GOTO   68D
15A9:  MOVWF  5A
15AA:  MOVWF  77
15AB:  MOVF   56,W
15AC:  BTFSC  03.2
15AD:  GOTO   696
15AE:  SUBWF  5A,F
15AF:  BTFSC  03.2
15B0:  GOTO   632
15B1:  BTFSS  03.0
15B2:  GOTO   5F0
15B3:  MOVF   57,W
15B4:  MOVWF  60
15B5:  BSF    60.7
15B6:  MOVF   58,W
15B7:  MOVWF  5F
15B8:  MOVF   59,W
15B9:  MOVWF  5E
15BA:  CLRF   5D
15BB:  BCF    03.0
15BC:  RRF    60,F
15BD:  RRF    5F,F
15BE:  RRF    5E,F
15BF:  RRF    5D,F
15C0:  DECFSZ 5A,F
15C1:  GOTO   5BA
15C2:  BTFSS  5B.7
15C3:  GOTO   5C7
15C4:  BSF    5C.0
15C5:  GOTO   6AA
15C6:  BCF    5C.0
15C7:  BCF    5A.0
15C8:  BSF    5C.4
15C9:  MOVLW  D5
15CA:  MOVWF  04
15CB:  BCF    03.7
15CC:  GOTO   6BF
15CD:  BCF    5C.4
15CE:  BTFSC  5B.7
15CF:  GOTO   5DA
15D0:  BTFSS  5A.0
15D1:  GOTO   5E5
15D2:  RRF    60,F
15D3:  RRF    5F,F
15D4:  RRF    5E,F
15D5:  RRF    5D,F
15D6:  INCF   77,F
15D7:  BTFSC  03.2
15D8:  GOTO   6A5
15D9:  GOTO   5E5
15DA:  BTFSC  60.7
15DB:  GOTO   5E8
15DC:  BCF    03.0
15DD:  RLF    5D,F
15DE:  RLF    5E,F
15DF:  RLF    5F,F
15E0:  RLF    60,F
15E1:  DECF   77,F
15E2:  BTFSC  03.2
15E3:  GOTO   6A5
15E4:  GOTO   5DA
15E5:  BSF    5C.6
15E6:  GOTO   652
15E7:  BCF    5C.6
15E8:  MOVF   53,W
15E9:  MOVWF  5B
15EA:  BTFSS  5B.7
15EB:  GOTO   5EE
15EC:  BSF    60.7
15ED:  GOTO   69E
15EE:  BCF    60.7
15EF:  GOTO   69E
15F0:  MOVF   56,W
15F1:  MOVWF  5A
15F2:  MOVWF  77
15F3:  MOVF   52,W
15F4:  SUBWF  5A,F
15F5:  MOVF   53,W
15F6:  MOVWF  60
15F7:  BSF    60.7
15F8:  MOVF   54,W
15F9:  MOVWF  5F
15FA:  MOVF   55,W
15FB:  MOVWF  5E
15FC:  CLRF   5D
15FD:  BCF    03.0
15FE:  RRF    60,F
15FF:  RRF    5F,F
1600:  RRF    5E,F
1601:  RRF    5D,F
1602:  DECFSZ 5A,F
1603:  GOTO   5FC
1604:  BTFSS  5B.7
1605:  GOTO   609
1606:  BSF    5C.1
1607:  GOTO   6AA
1608:  BCF    5C.1
1609:  BCF    5A.0
160A:  BSF    5C.5
160B:  MOVLW  D9
160C:  MOVWF  04
160D:  BCF    03.7
160E:  GOTO   6BF
160F:  BCF    5C.5
1610:  BTFSC  5B.7
1611:  GOTO   61C
1612:  BTFSS  5A.0
1613:  GOTO   627
1614:  RRF    60,F
1615:  RRF    5F,F
1616:  RRF    5E,F
1617:  RRF    5D,F
1618:  INCF   77,F
1619:  BTFSC  03.2
161A:  GOTO   6A5
161B:  GOTO   627
161C:  BTFSC  60.7
161D:  GOTO   62A
161E:  BCF    03.0
161F:  RLF    5D,F
1620:  RLF    5E,F
1621:  RLF    5F,F
1622:  RLF    60,F
1623:  DECF   77,F
1624:  BTFSC  03.2
1625:  GOTO   6A5
1626:  GOTO   61C
1627:  BSF    5C.7
1628:  GOTO   652
1629:  BCF    5C.7
162A:  MOVF   57,W
162B:  MOVWF  5B
162C:  BTFSS  5B.7
162D:  GOTO   630
162E:  BSF    60.7
162F:  GOTO   69E
1630:  BCF    60.7
1631:  GOTO   69E
1632:  MOVF   57,W
1633:  MOVWF  60
1634:  BSF    60.7
1635:  MOVF   58,W
1636:  MOVWF  5F
1637:  MOVF   59,W
1638:  MOVWF  5E
1639:  BTFSS  5B.7
163A:  GOTO   63F
163B:  BCF    60.7
163C:  BSF    5C.2
163D:  GOTO   6AA
163E:  BCF    5C.2
163F:  CLRF   5D
1640:  BCF    5A.0
1641:  MOVLW  D5
1642:  MOVWF  04
1643:  BCF    03.7
1644:  GOTO   6BF
1645:  BTFSC  5B.7
1646:  GOTO   668
1647:  MOVF   53,W
1648:  MOVWF  5B
1649:  BTFSS  5A.0
164A:  GOTO   652
164B:  RRF    60,F
164C:  RRF    5F,F
164D:  RRF    5E,F
164E:  RRF    5D,F
164F:  INCF   77,F
1650:  BTFSC  03.2
1651:  GOTO   6A5
1652:  BTFSS  5D.7
1653:  GOTO   663
1654:  INCF   5E,F
1655:  BTFSS  03.2
1656:  GOTO   663
1657:  INCF   5F,F
1658:  BTFSS  03.2
1659:  GOTO   663
165A:  INCF   60,F
165B:  BTFSS  03.2
165C:  GOTO   663
165D:  RRF    60,F
165E:  RRF    5F,F
165F:  RRF    5E,F
1660:  INCF   77,F
1661:  BTFSC  03.2
1662:  GOTO   6A5
1663:  BTFSC  5C.6
1664:  GOTO   5E7
1665:  BTFSC  5C.7
1666:  GOTO   629
1667:  GOTO   687
1668:  MOVLW  80
1669:  XORWF  60,F
166A:  BTFSS  60.7
166B:  GOTO   670
166C:  GOTO   6AA
166D:  MOVF   57,W
166E:  MOVWF  5B
166F:  GOTO   67D
1670:  MOVF   53,W
1671:  MOVWF  5B
1672:  MOVF   60,F
1673:  BTFSS  03.2
1674:  GOTO   67D
1675:  MOVF   5F,F
1676:  BTFSS  03.2
1677:  GOTO   67D
1678:  MOVF   5E,F
1679:  BTFSS  03.2
167A:  GOTO   67D
167B:  CLRF   77
167C:  GOTO   69E
167D:  BTFSC  60.7
167E:  GOTO   687
167F:  BCF    03.0
1680:  RLF    5D,F
1681:  RLF    5E,F
1682:  RLF    5F,F
1683:  RLF    60,F
1684:  DECFSZ 77,F
1685:  GOTO   67D
1686:  GOTO   6A5
1687:  BTFSS  5B.7
1688:  GOTO   68B
1689:  BSF    60.7
168A:  GOTO   69E
168B:  BCF    60.7
168C:  GOTO   69E
168D:  MOVF   56,W
168E:  MOVWF  77
168F:  MOVF   57,W
1690:  MOVWF  60
1691:  MOVF   58,W
1692:  MOVWF  5F
1693:  MOVF   59,W
1694:  MOVWF  5E
1695:  GOTO   69E
1696:  MOVF   52,W
1697:  MOVWF  77
1698:  MOVF   53,W
1699:  MOVWF  60
169A:  MOVF   54,W
169B:  MOVWF  5F
169C:  MOVF   55,W
169D:  MOVWF  5E
169E:  MOVF   60,W
169F:  MOVWF  78
16A0:  MOVF   5F,W
16A1:  MOVWF  79
16A2:  MOVF   5E,W
16A3:  MOVWF  7A
16A4:  GOTO   6DD
16A5:  CLRF   77
16A6:  CLRF   78
16A7:  CLRF   79
16A8:  CLRF   7A
16A9:  GOTO   6DD
16AA:  CLRF   5D
16AB:  COMF   5E,F
16AC:  COMF   5F,F
16AD:  COMF   60,F
16AE:  COMF   5D,F
16AF:  INCF   5D,F
16B0:  BTFSS  03.2
16B1:  GOTO   6B8
16B2:  INCF   5E,F
16B3:  BTFSS  03.2
16B4:  GOTO   6B8
16B5:  INCF   5F,F
16B6:  BTFSC  03.2
16B7:  INCF   60,F
16B8:  BTFSC  5C.0
16B9:  GOTO   5C6
16BA:  BTFSC  5C.1
16BB:  GOTO   608
16BC:  BTFSC  5C.2
16BD:  GOTO   63E
16BE:  GOTO   66D
16BF:  MOVF   00,W
16C0:  ADDWF  5E,F
16C1:  BTFSS  03.0
16C2:  GOTO   6C9
16C3:  INCF   5F,F
16C4:  BTFSS  03.2
16C5:  GOTO   6C9
16C6:  INCF   60,F
16C7:  BTFSC  03.2
16C8:  BSF    5A.0
16C9:  DECF   04,F
16CA:  MOVF   00,W
16CB:  ADDWF  5F,F
16CC:  BTFSS  03.0
16CD:  GOTO   6D1
16CE:  INCF   60,F
16CF:  BTFSC  03.2
16D0:  BSF    5A.0
16D1:  DECF   04,F
16D2:  MOVF   00,W
16D3:  BTFSS  00.7
16D4:  XORLW  80
16D5:  ADDWF  60,F
16D6:  BTFSC  03.0
16D7:  BSF    5A.0
16D8:  BTFSC  5C.4
16D9:  GOTO   5CD
16DA:  BTFSC  5C.5
16DB:  GOTO   60F
16DC:  GOTO   645
16DD:  BCF    03.5
16DE:  RETURN
16DF:  MOVF   0B,W
16E0:  MOVWF  69
16E1:  BCF    0B.7
16E2:  BSF    03.5
16E3:  BSF    03.6
16E4:  BSF    0C.7
16E5:  BSF    0C.0
16E6:  NOP
16E7:  NOP
16E8:  BCF    03.5
16E9:  BCF    03.6
16EA:  BTFSC  69.7
16EB:  BSF    0B.7
16EC:  BTFSC  03.0
16ED:  GOTO   717
16EE:  BSF    03.6
16EF:  MOVF   0C,W
16F0:  ANDLW  7F
16F1:  BCF    03.6
16F2:  MOVWF  69
16F3:  BSF    03.6
16F4:  MOVF   0D,W
16F5:  BCF    03.6
16F6:  MOVWF  6A
16F7:  BSF    03.6
16F8:  MOVF   0F,W
16F9:  BCF    03.6
16FA:  MOVWF  6B
16FB:  MOVF   69,W
16FC:  BTFSS  0C.4
16FD:  GOTO   6FC
16FE:  MOVWF  19
16FF:  MOVF   6A,W
1700:  BSF    03.6
1701:  MOVWF  0D
1702:  BCF    03.6
1703:  MOVF   6B,W
1704:  BSF    03.6
1705:  MOVWF  0F
1706:  BCF    03.6
1707:  MOVF   0B,W
1708:  MOVWF  6C
1709:  BCF    0B.7
170A:  BSF    03.5
170B:  BSF    03.6
170C:  BSF    0C.7
170D:  BSF    0C.0
170E:  NOP
170F:  NOP
1710:  BCF    03.5
1711:  BCF    03.6
1712:  BTFSC  6C.7
1713:  BSF    0B.7
1714:  DECFSZ 68,F
1715:  GOTO   717
1716:  GOTO   737
1717:  BSF    03.6
1718:  RLF    0C,W
1719:  RLF    0E,W
171A:  ANDLW  7F
171B:  BCF    03.6
171C:  MOVWF  69
171D:  BSF    03.6
171E:  MOVF   0D,W
171F:  BCF    03.6
1720:  MOVWF  6A
1721:  BSF    03.6
1722:  MOVF   0F,W
1723:  BCF    03.6
1724:  MOVWF  6B
1725:  MOVF   69,W
1726:  BTFSS  0C.4
1727:  GOTO   726
1728:  MOVWF  19
1729:  MOVF   6A,W
172A:  BSF    03.6
172B:  MOVWF  0D
172C:  BCF    03.6
172D:  MOVF   6B,W
172E:  BSF    03.6
172F:  MOVWF  0F
1730:  INCF   0D,F
1731:  BTFSC  03.2
1732:  INCF   0F,F
1733:  BCF    03.0
1734:  BCF    03.6
1735:  DECFSZ 68,F
1736:  GOTO   6DF
1737:  RETURN
1738:  CLRF   70
1739:  MOVF   04,W
173A:  MOVWF  6F
173B:  BCF    70.0
173C:  BTFSC  03.7
173D:  BSF    70.0
173E:  SWAPF  69,W
173F:  IORLW  F0
1740:  MOVWF  6B
1741:  ADDWF  6B,F
1742:  ADDLW  E2
1743:  MOVWF  6C
1744:  ADDLW  32
1745:  MOVWF  6E
1746:  MOVF   69,W
1747:  ANDLW  0F
1748:  ADDWF  6C,F
1749:  ADDWF  6C,F
174A:  ADDWF  6E,F
174B:  ADDLW  E9
174C:  MOVWF  6D
174D:  ADDWF  6D,F
174E:  ADDWF  6D,F
174F:  SWAPF  68,W
1750:  ANDLW  0F
1751:  ADDWF  6D,F
1752:  ADDWF  6E,F
1753:  RLF    6D,F
1754:  RLF    6E,F
1755:  COMF   6E,F
1756:  RLF    6E,F
1757:  MOVF   68,W
1758:  ANDLW  0F
1759:  ADDWF  6E,F
175A:  RLF    6B,F
175B:  MOVLW  07
175C:  MOVWF  6A
175D:  MOVLW  0A
175E:  ADDWF  6E,F
175F:  DECF   6D,F
1760:  BTFSS  03.0
1761:  GOTO   75E
1762:  ADDWF  6D,F
1763:  DECF   6C,F
1764:  BTFSS  03.0
1765:  GOTO   762
1766:  ADDWF  6C,F
1767:  DECF   6B,F
1768:  BTFSS  03.0
1769:  GOTO   766
176A:  ADDWF  6B,F
176B:  DECF   6A,F
176C:  BTFSS  03.0
176D:  GOTO   76A
176E:  MOVLW  6A
176F:  MOVWF  04
1770:  BCF    03.7
1771:  MOVLW  07
1772:  ANDWF  6F,W
1773:  BCF    6F.6
1774:  ADDWF  04,F
1775:  MOVLW  6E
1776:  SUBWF  04,W
1777:  BTFSC  03.2
1778:  BSF    6F.6
1779:  MOVF   00,W
177A:  MOVWF  77
177B:  BTFSS  03.2
177C:  GOTO   785
177D:  BTFSC  6F.6
177E:  GOTO   785
177F:  BTFSC  6F.4
1780:  GOTO   78D
1781:  BTFSC  6F.3
1782:  GOTO   785
1783:  MOVLW  20
1784:  GOTO   788
1785:  BSF    6F.3
1786:  BCF    6F.4
1787:  MOVLW  30
1788:  ADDWF  77,F
1789:  MOVF   77,W
178A:  BTFSS  0C.4
178B:  GOTO   78A
178C:  MOVWF  19
178D:  INCF   04,F
178E:  BTFSS  6F.6
178F:  GOTO   775
1790:  BSF    0A.3
1791:  BSF    0A.4
1792:  GOTO   65B (RETURN)
1793:  BSF    03.5
1794:  MOVF   28,W
1795:  SUBLW  B6
1796:  MOVWF  28
1797:  CLRF   7A
1798:  MOVF   29,W
1799:  MOVWF  2C
179A:  BSF    29.7
179B:  BCF    03.0
179C:  RRF    29,F
179D:  RRF    2A,F
179E:  RRF    2B,F
179F:  RRF    7A,F
17A0:  RRF    79,F
17A1:  RRF    78,F
17A2:  RRF    77,F
17A3:  DECFSZ 28,F
17A4:  GOTO   79B
17A5:  BTFSS  2C.7
17A6:  GOTO   7B2
17A7:  COMF   77,F
17A8:  COMF   78,F
17A9:  COMF   79,F
17AA:  COMF   7A,F
17AB:  INCF   77,F
17AC:  BTFSC  03.2
17AD:  INCF   78,F
17AE:  BTFSC  03.2
17AF:  INCF   79,F
17B0:  BTFSC  03.2
17B1:  INCF   7A,F
17B2:  BCF    03.5
17B3:  RETURN
*
1A05:  MOVF   04,W
1A06:  MOVWF  6D
1A07:  MOVF   6C,W
1A08:  MOVWF  6F
1A09:  BTFSC  03.2
1A0A:  GOTO   230
1A0B:  MOVF   6B,W
1A0C:  BSF    03.5
1A0D:  MOVWF  55
1A0E:  BCF    03.5
1A0F:  MOVF   6A,W
1A10:  BSF    03.5
1A11:  MOVWF  54
1A12:  BCF    03.5
1A13:  MOVF   69,W
1A14:  BSF    03.5
1A15:  MOVWF  53
1A16:  BCF    03.5
1A17:  MOVF   68,W
1A18:  BSF    03.5
1A19:  MOVWF  52
1A1A:  CLRF   59
1A1B:  CLRF   58
1A1C:  MOVLW  20
1A1D:  MOVWF  57
1A1E:  MOVLW  82
1A1F:  MOVWF  56
1A20:  BCF    0A.4
1A21:  BCF    0A.3
1A22:  BCF    03.5
1A23:  CALL   19F
1A24:  BSF    0A.4
1A25:  BSF    0A.3
1A26:  MOVF   7A,W
1A27:  MOVWF  6B
1A28:  MOVF   79,W
1A29:  MOVWF  6A
1A2A:  MOVF   78,W
1A2B:  MOVWF  69
1A2C:  MOVF   77,W
1A2D:  MOVWF  68
1A2E:  DECFSZ 6F,F
1A2F:  GOTO   20B
1A30:  MOVF   6B,W
1A31:  BSF    03.5
1A32:  MOVWF  2B
1A33:  BCF    03.5
1A34:  MOVF   6A,W
1A35:  BSF    03.5
1A36:  MOVWF  2A
1A37:  BCF    03.5
1A38:  MOVF   69,W
1A39:  BSF    03.5
1A3A:  MOVWF  29
1A3B:  BCF    03.5
1A3C:  MOVF   68,W
1A3D:  BSF    03.5
1A3E:  MOVWF  28
1A3F:  BCF    0A.3
1A40:  BCF    03.5
1A41:  CALL   793
1A42:  BSF    0A.3
1A43:  MOVF   7A,W
1A44:  MOVWF  6B
1A45:  MOVF   79,W
1A46:  MOVWF  6A
1A47:  MOVF   78,W
1A48:  MOVWF  69
1A49:  MOVF   77,W
1A4A:  MOVWF  68
1A4B:  BTFSS  6B.7
1A4C:  GOTO   25A
1A4D:  DECF   6D,F
1A4E:  BSF    6D.5
1A4F:  COMF   68,F
1A50:  COMF   69,F
1A51:  COMF   6A,F
1A52:  COMF   6B,F
1A53:  INCF   68,F
1A54:  BTFSC  03.2
1A55:  INCF   69,F
1A56:  BTFSC  03.2
1A57:  INCF   6A,F
1A58:  BTFSC  03.2
1A59:  INCF   6B,F
1A5A:  MOVLW  3B
1A5B:  MOVWF  74
1A5C:  MOVLW  9A
1A5D:  MOVWF  73
1A5E:  MOVLW  CA
1A5F:  MOVWF  72
1A60:  CLRF   71
1A61:  MOVLW  0A
1A62:  MOVWF  6F
1A63:  MOVF   6C,W
1A64:  BTFSC  03.2
1A65:  INCF   6D,F
1A66:  BSF    03.1
1A67:  MOVLW  68
1A68:  MOVWF  04
1A69:  BCF    03.7
1A6A:  MOVF   6B,W
1A6B:  BSF    03.6
1A6C:  MOVWF  1B
1A6D:  BCF    03.6
1A6E:  MOVF   6A,W
1A6F:  BSF    03.6
1A70:  MOVWF  1A
1A71:  BCF    03.6
1A72:  MOVF   69,W
1A73:  BSF    03.6
1A74:  MOVWF  19
1A75:  BCF    03.6
1A76:  MOVF   68,W
1A77:  BSF    03.6
1A78:  MOVWF  18
1A79:  MOVF   74,W
1A7A:  MOVWF  1F
1A7B:  MOVF   73,W
1A7C:  MOVWF  1E
1A7D:  MOVF   72,W
1A7E:  MOVWF  1D
1A7F:  MOVF   71,W
1A80:  MOVWF  1C
1A81:  BCF    0A.4
1A82:  BCF    0A.3
1A83:  BCF    03.6
1A84:  CALL   3A3
1A85:  BSF    0A.4
1A86:  BSF    0A.3
1A87:  MOVF   78,W
1A88:  MOVF   77,F
1A89:  BTFSS  03.2
1A8A:  GOTO   29E
1A8B:  INCF   6C,W
1A8C:  SUBWF  6F,W
1A8D:  BTFSC  03.2
1A8E:  GOTO   29E
1A8F:  MOVF   6D,W
1A90:  BTFSC  03.2
1A91:  GOTO   2A0
1A92:  ANDLW  0F
1A93:  SUBWF  6F,W
1A94:  BTFSC  03.2
1A95:  GOTO   298
1A96:  BTFSC  03.0
1A97:  GOTO   2D4
1A98:  BTFSC  6D.7
1A99:  GOTO   2D4
1A9A:  BTFSC  6D.6
1A9B:  GOTO   2A0
1A9C:  MOVLW  20
1A9D:  GOTO   2CF
1A9E:  MOVLW  20
1A9F:  ANDWF  6D,F
1AA0:  BTFSS  6D.5
1AA1:  GOTO   2AF
1AA2:  BCF    6D.5
1AA3:  MOVF   6C,W
1AA4:  BTFSS  03.2
1AA5:  DECF   6D,F
1AA6:  MOVF   77,W
1AA7:  MOVWF  6D
1AA8:  MOVLW  2D
1AA9:  BTFSS  0C.4
1AAA:  GOTO   2A9
1AAB:  MOVWF  19
1AAC:  MOVF   6D,W
1AAD:  MOVWF  77
1AAE:  CLRF   6D
1AAF:  MOVF   6C,W
1AB0:  SUBWF  6F,W
1AB1:  BTFSS  03.2
1AB2:  GOTO   2BE
1AB3:  MOVF   77,W
1AB4:  MOVWF  6D
1AB5:  MOVLW  2E
1AB6:  BTFSS  0C.4
1AB7:  GOTO   2B6
1AB8:  MOVWF  19
1AB9:  MOVF   6D,W
1ABA:  MOVWF  77
1ABB:  MOVLW  20
1ABC:  ANDWF  6D,F
1ABD:  MOVLW  00
1ABE:  MOVLW  30
1ABF:  BTFSS  6D.5
1AC0:  GOTO   2CF
1AC1:  BCF    6D.5
1AC2:  MOVF   6C,W
1AC3:  BTFSS  03.2
1AC4:  DECF   6D,F
1AC5:  MOVF   77,W
1AC6:  MOVWF  6D
1AC7:  MOVLW  2D
1AC8:  BTFSS  0C.4
1AC9:  GOTO   2C8
1ACA:  MOVWF  19
1ACB:  MOVF   6D,W
1ACC:  MOVWF  77
1ACD:  CLRF   6D
1ACE:  MOVLW  30
1ACF:  ADDWF  77,F
1AD0:  MOVF   77,W
1AD1:  BTFSS  0C.4
1AD2:  GOTO   2D1
1AD3:  MOVWF  19
1AD4:  BCF    03.1
1AD5:  MOVF   74,W
1AD6:  BSF    03.6
1AD7:  MOVWF  1B
1AD8:  MOVF   73,W
1AD9:  MOVWF  1A
1ADA:  MOVF   72,W
1ADB:  MOVWF  19
1ADC:  MOVF   71,W
1ADD:  MOVWF  18
1ADE:  CLRF   1F
1ADF:  CLRF   1E
1AE0:  CLRF   1D
1AE1:  MOVLW  0A
1AE2:  MOVWF  1C
1AE3:  BCF    0A.4
1AE4:  BCF    0A.3
1AE5:  BCF    03.6
1AE6:  CALL   3A3
1AE7:  BSF    0A.4
1AE8:  BSF    0A.3
1AE9:  MOVF   7A,W
1AEA:  MOVWF  74
1AEB:  MOVF   79,W
1AEC:  MOVWF  73
1AED:  MOVF   78,W
1AEE:  MOVWF  72
1AEF:  MOVF   77,W
1AF0:  MOVWF  71
1AF1:  DECFSZ 6F,F
1AF2:  GOTO   266
1AF3:  RETURN
1AF4:  MOVF   0B,W
1AF5:  MOVWF  68
1AF6:  BCF    0B.7
1AF7:  BSF    03.5
1AF8:  BSF    03.6
1AF9:  BSF    0C.7
1AFA:  BSF    0C.0
1AFB:  NOP
1AFC:  NOP
1AFD:  BCF    03.5
1AFE:  BCF    03.6
1AFF:  BTFSC  68.7
1B00:  BSF    0B.7
1B01:  BSF    03.6
1B02:  MOVF   0C,W
1B03:  ANDLW  7F
1B04:  BTFSC  03.2
1B05:  GOTO   354
1B06:  BCF    03.6
1B07:  MOVWF  68
1B08:  BSF    03.6
1B09:  MOVF   0D,W
1B0A:  BCF    03.6
1B0B:  MOVWF  69
1B0C:  BSF    03.6
1B0D:  MOVF   0F,W
1B0E:  BCF    03.6
1B0F:  MOVWF  6A
1B10:  MOVF   68,W
1B11:  BSF    03.5
1B12:  MOVWF  28
1B13:  BCF    0A.4
1B14:  BCF    0A.3
1B15:  BCF    03.5
1B16:  CALL   7ED
1B17:  BSF    0A.4
1B18:  BSF    0A.3
1B19:  MOVF   69,W
1B1A:  BSF    03.6
1B1B:  MOVWF  0D
1B1C:  BCF    03.6
1B1D:  MOVF   6A,W
1B1E:  BSF    03.6
1B1F:  MOVWF  0F
1B20:  BCF    03.6
1B21:  MOVF   0B,W
1B22:  MOVWF  6B
1B23:  BCF    0B.7
1B24:  BSF    03.5
1B25:  BSF    03.6
1B26:  BSF    0C.7
1B27:  BSF    0C.0
1B28:  NOP
1B29:  NOP
1B2A:  BCF    03.5
1B2B:  BCF    03.6
1B2C:  BTFSC  6B.7
1B2D:  BSF    0B.7
1B2E:  BSF    03.6
1B2F:  RLF    0C,W
1B30:  RLF    0E,W
1B31:  ANDLW  7F
1B32:  BTFSC  03.2
1B33:  GOTO   354
1B34:  BCF    03.6
1B35:  MOVWF  68
1B36:  BSF    03.6
1B37:  MOVF   0D,W
1B38:  BCF    03.6
1B39:  MOVWF  69
1B3A:  BSF    03.6
1B3B:  MOVF   0F,W
1B3C:  BCF    03.6
1B3D:  MOVWF  6A
1B3E:  MOVF   68,W
1B3F:  BSF    03.5
1B40:  MOVWF  28
1B41:  BCF    0A.4
1B42:  BCF    0A.3
1B43:  BCF    03.5
1B44:  CALL   7ED
1B45:  BSF    0A.4
1B46:  BSF    0A.3
1B47:  MOVF   69,W
1B48:  BSF    03.6
1B49:  MOVWF  0D
1B4A:  BCF    03.6
1B4B:  MOVF   6A,W
1B4C:  BSF    03.6
1B4D:  MOVWF  0F
1B4E:  INCF   0D,F
1B4F:  BTFSC  03.2
1B50:  INCF   0F,F
1B51:  BCF    03.6
1B52:  GOTO   2F4
1B53:  BSF    03.6
1B54:  BCF    03.6
1B55:  BSF    0A.3
1B56:  BSF    0A.4
1B57:  GOTO   711 (RETURN)
1B58:  MOVF   04,W
1B59:  BSF    03.5
1B5A:  MOVWF  20
1B5B:  MOVF   70,W
1B5C:  MOVWF  22
1B5D:  BTFSC  03.2
1B5E:  GOTO   386
1B5F:  BCF    03.5
1B60:  MOVF   6F,W
1B61:  BSF    03.5
1B62:  MOVWF  55
1B63:  BCF    03.5
1B64:  MOVF   6E,W
1B65:  BSF    03.5
1B66:  MOVWF  54
1B67:  BCF    03.5
1B68:  MOVF   6D,W
1B69:  BSF    03.5
1B6A:  MOVWF  53
1B6B:  BCF    03.5
1B6C:  MOVF   6C,W
1B6D:  BSF    03.5
1B6E:  MOVWF  52
1B6F:  CLRF   59
1B70:  CLRF   58
1B71:  MOVLW  20
1B72:  MOVWF  57
1B73:  MOVLW  82
1B74:  MOVWF  56
1B75:  BCF    0A.4
1B76:  BCF    0A.3
1B77:  BCF    03.5
1B78:  CALL   19F
1B79:  BSF    0A.4
1B7A:  BSF    0A.3
1B7B:  MOVF   7A,W
1B7C:  MOVWF  6F
1B7D:  MOVF   79,W
1B7E:  MOVWF  6E
1B7F:  MOVF   78,W
1B80:  MOVWF  6D
1B81:  MOVF   77,W
1B82:  MOVWF  6C
1B83:  BSF    03.5
1B84:  DECFSZ 22,F
1B85:  GOTO   35F
1B86:  BCF    03.5
1B87:  MOVF   6F,W
1B88:  BSF    03.5
1B89:  MOVWF  2B
1B8A:  BCF    03.5
1B8B:  MOVF   6E,W
1B8C:  BSF    03.5
1B8D:  MOVWF  2A
1B8E:  BCF    03.5
1B8F:  MOVF   6D,W
1B90:  BSF    03.5
1B91:  MOVWF  29
1B92:  BCF    03.5
1B93:  MOVF   6C,W
1B94:  BSF    03.5
1B95:  MOVWF  28
1B96:  BCF    0A.3
1B97:  BCF    03.5
1B98:  CALL   793
1B99:  BSF    0A.3
1B9A:  MOVF   7A,W
1B9B:  MOVWF  6F
1B9C:  MOVF   79,W
1B9D:  MOVWF  6E
1B9E:  MOVF   78,W
1B9F:  MOVWF  6D
1BA0:  MOVF   77,W
1BA1:  MOVWF  6C
1BA2:  BTFSS  6F.7
1BA3:  GOTO   3B3
1BA4:  BSF    03.5
1BA5:  DECF   20,F
1BA6:  BSF    20.5
1BA7:  BCF    03.5
1BA8:  COMF   6C,F
1BA9:  COMF   6D,F
1BAA:  COMF   6E,F
1BAB:  COMF   6F,F
1BAC:  INCF   6C,F
1BAD:  BTFSC  03.2
1BAE:  INCF   6D,F
1BAF:  BTFSC  03.2
1BB0:  INCF   6E,F
1BB1:  BTFSC  03.2
1BB2:  INCF   6F,F
1BB3:  MOVLW  3B
1BB4:  BSF    03.5
1BB5:  MOVWF  27
1BB6:  MOVLW  9A
1BB7:  MOVWF  26
1BB8:  MOVLW  CA
1BB9:  MOVWF  25
1BBA:  CLRF   24
1BBB:  MOVLW  0A
1BBC:  MOVWF  22
1BBD:  MOVF   70,W
1BBE:  BTFSC  03.2
1BBF:  INCF   20,F
1BC0:  BSF    03.1
1BC1:  MOVLW  6C
1BC2:  MOVWF  04
1BC3:  BCF    03.7
1BC4:  BCF    03.5
1BC5:  MOVF   6F,W
1BC6:  BSF    03.6
1BC7:  MOVWF  1B
1BC8:  BCF    03.6
1BC9:  MOVF   6E,W
1BCA:  BSF    03.6
1BCB:  MOVWF  1A
1BCC:  BCF    03.6
1BCD:  MOVF   6D,W
1BCE:  BSF    03.6
1BCF:  MOVWF  19
1BD0:  BCF    03.6
1BD1:  MOVF   6C,W
1BD2:  BSF    03.6
1BD3:  MOVWF  18
1BD4:  BSF    03.5
1BD5:  BCF    03.6
1BD6:  MOVF   27,W
1BD7:  BCF    03.5
1BD8:  BSF    03.6
1BD9:  MOVWF  1F
1BDA:  BSF    03.5
1BDB:  BCF    03.6
1BDC:  MOVF   26,W
1BDD:  BCF    03.5
1BDE:  BSF    03.6
1BDF:  MOVWF  1E
1BE0:  BSF    03.5
1BE1:  BCF    03.6
1BE2:  MOVF   25,W
1BE3:  BCF    03.5
1BE4:  BSF    03.6
1BE5:  MOVWF  1D
1BE6:  BSF    03.5
1BE7:  BCF    03.6
1BE8:  MOVF   24,W
1BE9:  BCF    03.5
1BEA:  BSF    03.6
1BEB:  MOVWF  1C
1BEC:  BCF    0A.4
1BED:  BCF    0A.3
1BEE:  BCF    03.6
1BEF:  CALL   3A3
1BF0:  BSF    0A.4
1BF1:  BSF    0A.3
1BF2:  MOVF   78,W
1BF3:  MOVF   77,F
1BF4:  BTFSS  03.2
1BF5:  GOTO   40D
1BF6:  INCF   70,W
1BF7:  BSF    03.5
1BF8:  SUBWF  22,W
1BF9:  BTFSS  03.2
1BFA:  GOTO   3FD
1BFB:  BCF    03.5
1BFC:  GOTO   40D
1BFD:  MOVF   20,W
1BFE:  BTFSC  03.2
1BFF:  GOTO   410
1C00:  ANDLW  0F
1C01:  SUBWF  22,W
1C02:  BTFSC  03.2
1C03:  GOTO   406
1C04:  BTFSC  03.0
1C05:  GOTO   458
1C06:  BTFSC  20.7
1C07:  GOTO   458
1C08:  BTFSC  20.6
1C09:  GOTO   410
1C0A:  MOVLW  20
1C0B:  GOTO   44E
1C0C:  BCF    03.5
1C0D:  MOVLW  20
1C0E:  BSF    03.5
1C0F:  ANDWF  20,F
1C10:  BTFSS  20.5
1C11:  GOTO   424
1C12:  BCF    20.5
1C13:  MOVF   70,W
1C14:  BTFSS  03.2
1C15:  DECF   20,F
1C16:  MOVF   77,W
1C17:  MOVWF  20
1C18:  MOVLW  2D
1C19:  MOVWF  28
1C1A:  BCF    0A.4
1C1B:  BCF    0A.3
1C1C:  BCF    03.5
1C1D:  CALL   7ED
1C1E:  BSF    0A.4
1C1F:  BSF    0A.3
1C20:  BSF    03.5
1C21:  MOVF   20,W
1C22:  MOVWF  77
1C23:  CLRF   20
1C24:  MOVF   70,W
1C25:  SUBWF  22,W
1C26:  BTFSS  03.2
1C27:  GOTO   438
1C28:  MOVF   77,W
1C29:  MOVWF  20
1C2A:  MOVLW  2E
1C2B:  MOVWF  28
1C2C:  BCF    0A.4
1C2D:  BCF    0A.3
1C2E:  BCF    03.5
1C2F:  CALL   7ED
1C30:  BSF    0A.4
1C31:  BSF    0A.3
1C32:  BSF    03.5
1C33:  MOVF   20,W
1C34:  MOVWF  77
1C35:  MOVLW  20
1C36:  ANDWF  20,F
1C37:  MOVLW  00
1C38:  MOVLW  30
1C39:  BTFSS  20.5
1C3A:  GOTO   44E
1C3B:  BCF    20.5
1C3C:  MOVF   70,W
1C3D:  BTFSS  03.2
1C3E:  DECF   20,F
1C3F:  MOVF   77,W
1C40:  MOVWF  20
1C41:  MOVLW  2D
1C42:  MOVWF  28
1C43:  BCF    0A.4
1C44:  BCF    0A.3
1C45:  BCF    03.5
1C46:  CALL   7ED
1C47:  BSF    0A.4
1C48:  BSF    0A.3
1C49:  BSF    03.5
1C4A:  MOVF   20,W
1C4B:  MOVWF  77
1C4C:  CLRF   20
1C4D:  MOVLW  30
1C4E:  ADDWF  77,F
1C4F:  MOVF   77,W
1C50:  MOVWF  28
1C51:  BCF    0A.4
1C52:  BCF    0A.3
1C53:  BCF    03.5
1C54:  CALL   7ED
1C55:  BSF    0A.4
1C56:  BSF    0A.3
1C57:  BSF    03.5
1C58:  BCF    03.1
1C59:  MOVF   27,W
1C5A:  BCF    03.5
1C5B:  BSF    03.6
1C5C:  MOVWF  1B
1C5D:  BSF    03.5
1C5E:  BCF    03.6
1C5F:  MOVF   26,W
1C60:  BCF    03.5
1C61:  BSF    03.6
1C62:  MOVWF  1A
1C63:  BSF    03.5
1C64:  BCF    03.6
1C65:  MOVF   25,W
1C66:  BCF    03.5
1C67:  BSF    03.6
1C68:  MOVWF  19
1C69:  BSF    03.5
1C6A:  BCF    03.6
1C6B:  MOVF   24,W
1C6C:  BCF    03.5
1C6D:  BSF    03.6
1C6E:  MOVWF  18
1C6F:  CLRF   1F
1C70:  CLRF   1E
1C71:  CLRF   1D
1C72:  MOVLW  0A
1C73:  MOVWF  1C
1C74:  BCF    0A.4
1C75:  BCF    0A.3
1C76:  BCF    03.6
1C77:  CALL   3A3
1C78:  BSF    0A.4
1C79:  BSF    0A.3
1C7A:  MOVF   7A,W
1C7B:  BSF    03.5
1C7C:  MOVWF  27
1C7D:  MOVF   79,W
1C7E:  MOVWF  26
1C7F:  MOVF   78,W
1C80:  MOVWF  25
1C81:  MOVF   77,W
1C82:  MOVWF  24
1C83:  DECFSZ 22,F
1C84:  GOTO   3C0
1C85:  BCF    03.5
1C86:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
....................  
.................... #use delay(clock=8M) 
*
07A7:  MOVLW  69
07A8:  MOVWF  04
07A9:  BCF    03.7
07AA:  MOVF   00,W
07AB:  BTFSC  03.2
07AC:  GOTO   7BA
07AD:  MOVLW  02
07AE:  MOVWF  78
07AF:  CLRF   77
07B0:  DECFSZ 77,F
07B1:  GOTO   7B0
07B2:  DECFSZ 78,F
07B3:  GOTO   7AF
07B4:  MOVLW  97
07B5:  MOVWF  77
07B6:  DECFSZ 77,F
07B7:  GOTO   7B6
07B8:  DECFSZ 00,F
07B9:  GOTO   7AD
07BA:  RETURN
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(MASTER, I2C1, FORCE_HW) 
*
00FA:  BCF    14.7
00FB:  BCF    0C.3
00FC:  BSF    03.5
00FD:  MOVF   6C,W
00FE:  BCF    03.5
00FF:  MOVWF  13
0100:  MOVLW  02
0101:  BTFSC  14.7
0102:  GOTO   10A
0103:  BTFSS  0C.3
0104:  GOTO   103
0105:  MOVLW  00
0106:  BSF    03.5
0107:  BTFSC  11.6
0108:  MOVLW  01
0109:  BCF    03.5
010A:  MOVWF  78
010B:  RETURN
010C:  BCF    14.6
010D:  BSF    03.5
010E:  BSF    11.3
010F:  BTFSC  11.3
0110:  GOTO   10F
0111:  BTFSC  77.0
0112:  BCF    11.5
0113:  BTFSS  77.0
0114:  BSF    11.5
0115:  BSF    11.4
0116:  BTFSC  11.4
0117:  GOTO   116
0118:  BCF    03.5
0119:  MOVF   13,W
011A:  MOVWF  78
011B:  RETURN
....................  
.................... #define RUN_BUTTON   PIN_B7 
....................  
....................  
....................  
.................... //#include <Wire.h> 
.................... #include "VL53L0X/VL53L0X.h" 
.................... #ifndef VL53L0X_h 
.................... #define VL53L0X_h 
....................  
.................... //#include <Arduino.h> 
....................  
....................  
....................     // register addresses from API vl53l0x_device.h (ordered as listed there) 
....................     enum regAddr 
....................     { 
....................       SYSRANGE_START                              = 0x00, 
....................  
....................       SYSTEM_THRESH_HIGH                          = 0x0C, 
....................       SYSTEM_THRESH_LOW                           = 0x0E, 
....................  
....................       SYSTEM_SEQUENCE_CONFIG                      = 0x01, 
....................       SYSTEM_RANGE_CONFIG                         = 0x09, 
....................       SYSTEM_INTERMEASUREMENT_PERIOD              = 0x04, 
....................  
....................       SYSTEM_INTERRUPT_CONFIG_GPIO                = 0x0A, 
....................  
....................       GPIO_HV_MUX_ACTIVE_HIGH                     = 0x84, 
....................  
....................       SYSTEM_INTERRUPT_CLEAR                      = 0x0B, 
....................  
....................       RESULT_INTERRUPT_STATUS                     = 0x13, 
....................       RESULT_RANGE_STATUS                         = 0x14, 
....................  
....................       RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN       = 0xBC, 
....................       RESULT_CORE_RANGING_TOTAL_EVENTS_RTN        = 0xC0, 
....................       RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF       = 0xD0, 
....................       RESULT_CORE_RANGING_TOTAL_EVENTS_REF        = 0xD4, 
....................       RESULT_PEAK_SIGNAL_RATE_REF                 = 0xB6, 
....................  
....................       ALGO_PART_TO_PART_RANGE_OFFSET_MM           = 0x28, 
....................  
....................       I2C_SLAVE_DEVICE_ADDRESS                    = 0x8A, 
....................  
....................       MSRC_CONFIG_CONTROL                         = 0x60, 
....................  
....................       PRE_RANGE_CONFIG_MIN_SNR                    = 0x27, 
....................       PRE_RANGE_CONFIG_VALID_PHASE_LOW            = 0x56, 
....................       PRE_RANGE_CONFIG_VALID_PHASE_HIGH           = 0x57, 
....................       PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT          = 0x64, 
....................  
....................       FINAL_RANGE_CONFIG_MIN_SNR                  = 0x67, 
....................       FINAL_RANGE_CONFIG_VALID_PHASE_LOW          = 0x47, 
....................       FINAL_RANGE_CONFIG_VALID_PHASE_HIGH         = 0x48, 
....................       FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT = 0x44, 
....................  
....................       PRE_RANGE_CONFIG_SIGMA_THRESH_HI            = 0x61, 
....................       PRE_RANGE_CONFIG_SIGMA_THRESH_LO            = 0x62, 
....................  
....................       PRE_RANGE_CONFIG_VCSEL_PERIOD               = 0x50, 
....................       PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI          = 0x51, 
....................       PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO          = 0x52, 
....................  
....................       SYSTEM_HISTOGRAM_BIN                        = 0x81, 
....................       HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT       = 0x33, 
....................       HISTOGRAM_CONFIG_READOUT_CTRL               = 0x55, 
....................  
....................       FINAL_RANGE_CONFIG_VCSEL_PERIOD             = 0x70, 
....................       FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI        = 0x71, 
....................       FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO        = 0x72, 
....................       CROSSTALK_COMPENSATION_PEAK_RATE_MCPS       = 0x20, 
....................  
....................       MSRC_CONFIG_TIMEOUT_MACROP                  = 0x46, 
....................  
....................       SOFT_RESET_GO2_SOFT_RESET_N                 = 0xBF, 
....................       IDENTIFICATION_MODEL_ID                     = 0xC0, 
....................       IDENTIFICATION_REVISION_ID                  = 0xC2, 
....................  
....................       OSC_CALIBRATE_VAL                           = 0xF8, 
....................  
....................       GLOBAL_CONFIG_VCSEL_WIDTH                   = 0x32, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_0            = 0xB0, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_1            = 0xB1, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_2            = 0xB2, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_3            = 0xB3, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_4            = 0xB4, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_5            = 0xB5, 
....................  
....................       GLOBAL_CONFIG_REF_EN_START_SELECT           = 0xB6, 
....................       DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD         = 0x4E, 
....................       DYNAMIC_SPAD_REF_EN_START_OFFSET            = 0x4F, 
....................       POWER_MANAGEMENT_GO1_POWER_FORCE            = 0x80, 
....................  
....................       VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV           = 0x89, 
....................  
....................       ALGO_PHASECAL_LIM                           = 0x30, 
....................       ALGO_PHASECAL_CONFIG_TIMEOUT                = 0x30, 
....................     }; 
....................  
....................     // private variables 
....................  
....................     typedef struct  
....................     { 
....................       boolean tcc, msrc, dss, pre_range, final_range; 
....................     } SequenceStepEnables; 
....................  
....................  
....................  
....................     typedef struct  
....................     { 
....................       int16 pre_range_vcsel_period_pclks, final_range_vcsel_period_pclks; 
....................  
....................       int16 msrc_dss_tcc_mclks, pre_range_mclks, final_range_mclks; 
....................       int32 msrc_dss_tcc_us,    pre_range_us,    final_range_us; 
....................     } SequenceStepTimeouts; 
....................  
....................     void getSequenceStepEnables(SequenceStepEnables * enables); 
....................     void getSequenceStepTimeouts(SequenceStepEnables * enables, SequenceStepTimeouts * timeouts); 
....................      
....................      
....................     enum vcselPeriodType { VcselPeriodPreRange, VcselPeriodFinalRange }; 
....................  
....................     int8 address; 
....................     int16 io_timeout; 
....................     boolean did_timeout; 
....................     int16 timeout_start_ms; 
....................  
....................     int8 stop_variable; // read by init and used when starting measurement; is StopVariable field of VL53L0X_DevData_t structure in API 
....................     int32 measurement_timing_budget_us; 
....................  
....................     boolean getSpadInfo(int8 * count, boolean * type_is_aperture); 
....................  
....................     int8 last_status; // status of last I2C transmission 
....................  
....................     VL53L0X(void); 
....................  
....................     void setAddress(int8 new_addr); 
....................     int8 getAddress(void) { return address; } 
....................  
....................     boolean init(boolean io_2v8 = TRUE); 
....................     #separate boolean init2(); 
....................  
....................     void writeReg(int8 reg, int8 value); 
....................     void writeReg16Bit(int8 reg, int16 value); 
....................     void writeReg32Bit(int8 reg, int32 value); 
....................     int8 readReg(int8 reg); 
....................     int16 readReg16Bit(int8 reg); 
....................     int32 readReg32Bit(int8 reg); 
....................  
....................     void writeMulti(int8 reg, int8  * src, int8 count); 
....................     void readMulti(int8 reg, int8 * dst, int8 count); 
....................  
....................     boolean setSignalRateLimit(float limit_Mcps); 
....................     float getSignalRateLimit(void); 
....................  
....................     boolean setMeasurementTimingBudget(int32 budget_us); 
....................     int32 getMeasurementTimingBudget(void); 
....................  
....................     boolean setVcselPulsePeriod(vcselPeriodType type, int8 period_pclks); 
....................     int8 getVcselPulsePeriod(vcselPeriodType type); 
....................  
....................     void startContinuous(int32 period_ms = 0); 
....................     void stopContinuous(void); 
....................     int16 readRangeContinuousMillimeters(void); 
....................     int16 readRangeSingleMillimeters(void); 
....................  
....................     void setTimeout(int16 timeout) { io_timeout = timeout; } 
*
1568:  MOVF   69,W
1569:  MOVWF  2E
156A:  MOVF   68,W
156B:  MOVWF  2D
....................     int16 getTimeout(void) { return io_timeout; } 
....................     boolean timeoutOccurred(void); 
....................  
....................  
....................  
....................     boolean performSingleRefCalibration(int8 vhv_init_byte); 
....................  
....................     static int16 decodeTimeout(int16 value); 
....................     static int16 encodeTimeout(int16 timeout_mclks); 
....................     static int32 timeoutMclksToMicroseconds(int16 timeout_period_mclks, int8 vcsel_period_pclks); 
....................     static int32 timeoutMicrosecondsToMclks(int32 timeout_period_us, int8 vcsel_period_pclks); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
1800:  BSF    03.5
1801:  CLRF   33
1802:  CLRF   32
1803:  CLRF   31
1804:  MOVLW  7F
1805:  MOVWF  30
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
1806:  MOVLW  7E
1807:  MOVWF  3A
1808:  MOVLW  80
1809:  MOVWF  3B
180A:  CLRF   3C
180B:  CLRF   3D
180C:  MOVLW  7A
180D:  MOVWF  3E
180E:  MOVLW  2A
180F:  MOVWF  3F
1810:  MOVLW  AA
1811:  MOVWF  40
1812:  MOVLW  A3
1813:  MOVWF  41
1814:  MOVLW  75
1815:  MOVWF  42
1816:  MOVLW  B6
1817:  MOVWF  43
1818:  MOVLW  09
1819:  MOVWF  44
181A:  MOVLW  B4
181B:  MOVWF  45
181C:  MOVLW  6F
181D:  MOVWF  46
181E:  MOVLW  4F
181F:  MOVWF  47
1820:  MOVLW  B6
1821:  MOVWF  48
1822:  MOVLW  AA
1823:  MOVWF  49
1824:  MOVLW  69
1825:  MOVWF  4A
1826:  MOVLW  8B
1827:  MOVWF  4B
1828:  MOVLW  F6
1829:  MOVWF  4C
182A:  MOVLW  E8
182B:  MOVWF  4D
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
182C:  MOVF   27,W
182D:  MOVWF  51
182E:  MOVF   26,W
182F:  MOVWF  50
1830:  MOVF   25,W
1831:  MOVWF  4F
1832:  MOVF   24,W
1833:  MOVWF  4E
1834:  CLRF   55
1835:  CLRF   54
1836:  CLRF   53
1837:  CLRF   52
1838:  BCF    0A.4
1839:  BCF    0A.3
183A:  BCF    03.5
183B:  CALL   15E
183C:  BSF    0A.4
183D:  BSF    0A.3
183E:  BTFSS  03.0
183F:  GOTO   045
1840:  BSF    03.5
1841:  MOVF   25,W
1842:  XORLW  80
1843:  MOVWF  25
1844:  BCF    03.5
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
1845:  BSF    03.5
1846:  MOVF   27,W
1847:  MOVWF  55
1848:  MOVF   26,W
1849:  MOVWF  54
184A:  MOVF   25,W
184B:  MOVWF  53
184C:  MOVF   24,W
184D:  MOVWF  52
184E:  MOVLW  83
184F:  MOVWF  59
1850:  MOVLW  F9
1851:  MOVWF  58
1852:  MOVLW  22
1853:  MOVWF  57
1854:  MOVLW  7E
1855:  MOVWF  56
1856:  BCF    0A.4
1857:  BCF    0A.3
1858:  BCF    03.5
1859:  CALL   19F
185A:  BSF    0A.4
185B:  BSF    0A.3
185C:  MOVF   7A,W
185D:  BSF    03.5
185E:  MOVWF  51
185F:  MOVF   79,W
1860:  MOVWF  50
1861:  MOVF   78,W
1862:  MOVWF  4F
1863:  MOVF   77,W
1864:  MOVWF  4E
1865:  BCF    0A.4
1866:  BCF    0A.3
1867:  BCF    03.5
1868:  CALL   216
1869:  BSF    0A.4
186A:  BSF    0A.3
186B:  MOVF   78,W
186C:  BSF    03.5
186D:  MOVWF  34
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
186E:  MOVF   27,W
186F:  MOVWF  55
1870:  MOVF   26,W
1871:  MOVWF  54
1872:  MOVF   25,W
1873:  MOVWF  53
1874:  MOVF   24,W
1875:  MOVWF  52
1876:  MOVLW  83
1877:  MOVWF  59
1878:  MOVLW  F9
1879:  MOVWF  58
187A:  MOVLW  22
187B:  MOVWF  57
187C:  MOVLW  7E
187D:  MOVWF  56
187E:  BCF    0A.4
187F:  BCF    0A.3
1880:  BCF    03.5
1881:  CALL   19F
1882:  BSF    0A.4
1883:  BSF    0A.3
1884:  MOVF   7A,W
1885:  BSF    03.5
1886:  MOVWF  51
1887:  MOVF   79,W
1888:  MOVWF  50
1889:  MOVF   78,W
188A:  MOVWF  4F
188B:  MOVF   77,W
188C:  MOVWF  4E
188D:  CLRF   53
188E:  MOVF   34,W
188F:  MOVWF  52
1890:  BCF    0A.4
1891:  BCF    0A.3
1892:  BCF    03.5
1893:  CALL   7BB
1894:  BSF    0A.4
1895:  BSF    0A.3
1896:  BSF    03.1
1897:  BSF    03.5
1898:  MOVF   51,W
1899:  MOVWF  55
189A:  MOVF   50,W
189B:  MOVWF  54
189C:  MOVF   4F,W
189D:  MOVWF  53
189E:  MOVF   4E,W
189F:  MOVWF  52
18A0:  MOVF   7A,W
18A1:  MOVWF  59
18A2:  MOVF   79,W
18A3:  MOVWF  58
18A4:  MOVF   78,W
18A5:  MOVWF  57
18A6:  MOVF   77,W
18A7:  MOVWF  56
18A8:  BCF    0A.3
18A9:  BCF    03.5
18AA:  CALL   599
18AB:  BSF    0A.3
18AC:  MOVF   7A,W
18AD:  BSF    03.5
18AE:  MOVWF  39
18AF:  MOVF   79,W
18B0:  MOVWF  38
18B1:  MOVF   78,W
18B2:  MOVWF  37
18B3:  MOVF   77,W
18B4:  MOVWF  36
....................    quad = quad % 4;                    // quadrant (0 to 3) 
18B5:  MOVLW  03
18B6:  ANDWF  34,F
....................  
....................    if (quad == 0 || quad == 2) 
18B7:  MOVF   34,F
18B8:  BTFSC  03.2
18B9:  GOTO   0BE
18BA:  MOVF   34,W
18BB:  SUBLW  02
18BC:  BTFSS  03.2
18BD:  GOTO   0DE
....................       t = frac * PI_DIV_BY_TWO; 
18BE:  MOVF   39,W
18BF:  MOVWF  55
18C0:  MOVF   38,W
18C1:  MOVWF  54
18C2:  MOVF   37,W
18C3:  MOVWF  53
18C4:  MOVF   36,W
18C5:  MOVWF  52
18C6:  MOVLW  DB
18C7:  MOVWF  59
18C8:  MOVLW  0F
18C9:  MOVWF  58
18CA:  MOVLW  49
18CB:  MOVWF  57
18CC:  MOVLW  7F
18CD:  MOVWF  56
18CE:  BCF    0A.4
18CF:  BCF    0A.3
18D0:  BCF    03.5
18D1:  CALL   19F
18D2:  BSF    0A.4
18D3:  BSF    0A.3
18D4:  MOVF   7A,W
18D5:  BSF    03.5
18D6:  MOVWF  2F
18D7:  MOVF   79,W
18D8:  MOVWF  2E
18D9:  MOVF   78,W
18DA:  MOVWF  2D
18DB:  MOVF   77,W
18DC:  MOVWF  2C
18DD:  GOTO   155
....................    else if (quad == 1) 
18DE:  DECFSZ 34,W
18DF:  GOTO   11B
....................       t = (1-frac) * PI_DIV_BY_TWO; 
18E0:  BSF    03.1
18E1:  CLRF   55
18E2:  CLRF   54
18E3:  CLRF   53
18E4:  MOVLW  7F
18E5:  MOVWF  52
18E6:  MOVF   39,W
18E7:  MOVWF  59
18E8:  MOVF   38,W
18E9:  MOVWF  58
18EA:  MOVF   37,W
18EB:  MOVWF  57
18EC:  MOVF   36,W
18ED:  MOVWF  56
18EE:  BCF    0A.3
18EF:  BCF    03.5
18F0:  CALL   599
18F1:  BSF    0A.3
18F2:  MOVF   7A,W
18F3:  BSF    03.5
18F4:  MOVWF  51
18F5:  MOVF   79,W
18F6:  MOVWF  50
18F7:  MOVF   78,W
18F8:  MOVWF  4F
18F9:  MOVF   77,W
18FA:  MOVWF  4E
18FB:  MOVF   51,W
18FC:  MOVWF  55
18FD:  MOVF   50,W
18FE:  MOVWF  54
18FF:  MOVF   4F,W
1900:  MOVWF  53
1901:  MOVF   4E,W
1902:  MOVWF  52
1903:  MOVLW  DB
1904:  MOVWF  59
1905:  MOVLW  0F
1906:  MOVWF  58
1907:  MOVLW  49
1908:  MOVWF  57
1909:  MOVLW  7F
190A:  MOVWF  56
190B:  BCF    0A.4
190C:  BCF    0A.3
190D:  BCF    03.5
190E:  CALL   19F
190F:  BSF    0A.4
1910:  BSF    0A.3
1911:  MOVF   7A,W
1912:  BSF    03.5
1913:  MOVWF  2F
1914:  MOVF   79,W
1915:  MOVWF  2E
1916:  MOVF   78,W
1917:  MOVWF  2D
1918:  MOVF   77,W
1919:  MOVWF  2C
191A:  GOTO   155
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
191B:  BSF    03.1
191C:  MOVF   39,W
191D:  MOVWF  55
191E:  MOVF   38,W
191F:  MOVWF  54
1920:  MOVF   37,W
1921:  MOVWF  53
1922:  MOVF   36,W
1923:  MOVWF  52
1924:  CLRF   59
1925:  CLRF   58
1926:  CLRF   57
1927:  MOVLW  7F
1928:  MOVWF  56
1929:  BCF    0A.3
192A:  BCF    03.5
192B:  CALL   599
192C:  BSF    0A.3
192D:  MOVF   7A,W
192E:  BSF    03.5
192F:  MOVWF  51
1930:  MOVF   79,W
1931:  MOVWF  50
1932:  MOVF   78,W
1933:  MOVWF  4F
1934:  MOVF   77,W
1935:  MOVWF  4E
1936:  MOVF   51,W
1937:  MOVWF  55
1938:  MOVF   50,W
1939:  MOVWF  54
193A:  MOVF   4F,W
193B:  MOVWF  53
193C:  MOVF   4E,W
193D:  MOVWF  52
193E:  MOVLW  DB
193F:  MOVWF  59
1940:  MOVLW  0F
1941:  MOVWF  58
1942:  MOVLW  49
1943:  MOVWF  57
1944:  MOVLW  7F
1945:  MOVWF  56
1946:  BCF    0A.4
1947:  BCF    0A.3
1948:  BCF    03.5
1949:  CALL   19F
194A:  BSF    0A.4
194B:  BSF    0A.3
194C:  MOVF   7A,W
194D:  BSF    03.5
194E:  MOVWF  2F
194F:  MOVF   79,W
1950:  MOVWF  2E
1951:  MOVF   78,W
1952:  MOVWF  2D
1953:  MOVF   77,W
1954:  MOVWF  2C
....................  
....................    y = 1.0; 
1955:  CLRF   2B
1956:  CLRF   2A
1957:  CLRF   29
1958:  MOVLW  7F
1959:  MOVWF  28
....................    t = t * t; 
195A:  MOVF   2F,W
195B:  MOVWF  55
195C:  MOVF   2E,W
195D:  MOVWF  54
195E:  MOVF   2D,W
195F:  MOVWF  53
1960:  MOVF   2C,W
1961:  MOVWF  52
1962:  MOVF   2F,W
1963:  MOVWF  59
1964:  MOVF   2E,W
1965:  MOVWF  58
1966:  MOVF   2D,W
1967:  MOVWF  57
1968:  MOVF   2C,W
1969:  MOVWF  56
196A:  BCF    0A.4
196B:  BCF    0A.3
196C:  BCF    03.5
196D:  CALL   19F
196E:  BSF    0A.4
196F:  BSF    0A.3
1970:  MOVF   7A,W
1971:  BSF    03.5
1972:  MOVWF  2F
1973:  MOVF   79,W
1974:  MOVWF  2E
1975:  MOVF   78,W
1976:  MOVWF  2D
1977:  MOVF   77,W
1978:  MOVWF  2C
....................    for (i = 0; i <= 4; i++) 
1979:  CLRF   35
197A:  MOVF   35,W
197B:  SUBLW  04
197C:  BTFSS  03.0
197D:  GOTO   1F2
....................    { 
....................       t2 = t2 * t; 
197E:  MOVF   33,W
197F:  MOVWF  55
1980:  MOVF   32,W
1981:  MOVWF  54
1982:  MOVF   31,W
1983:  MOVWF  53
1984:  MOVF   30,W
1985:  MOVWF  52
1986:  MOVF   2F,W
1987:  MOVWF  59
1988:  MOVF   2E,W
1989:  MOVWF  58
198A:  MOVF   2D,W
198B:  MOVWF  57
198C:  MOVF   2C,W
198D:  MOVWF  56
198E:  BCF    0A.4
198F:  BCF    0A.3
1990:  BCF    03.5
1991:  CALL   19F
1992:  BSF    0A.4
1993:  BSF    0A.3
1994:  MOVF   7A,W
1995:  BSF    03.5
1996:  MOVWF  33
1997:  MOVF   79,W
1998:  MOVWF  32
1999:  MOVF   78,W
199A:  MOVWF  31
199B:  MOVF   77,W
199C:  MOVWF  30
....................       y = y + p[i] * t2; 
199D:  RLF    35,W
199E:  MOVWF  77
199F:  RLF    77,F
19A0:  MOVLW  FC
19A1:  ANDWF  77,F
19A2:  MOVF   77,W
19A3:  ADDLW  BA
19A4:  MOVWF  04
19A5:  BCF    03.7
19A6:  MOVF   00,W
19A7:  MOVWF  4E
19A8:  INCF   04,F
19A9:  MOVF   00,W
19AA:  MOVWF  4F
19AB:  INCF   04,F
19AC:  MOVF   00,W
19AD:  MOVWF  50
19AE:  INCF   04,F
19AF:  MOVF   00,W
19B0:  MOVWF  51
19B1:  MOVWF  55
19B2:  MOVF   50,W
19B3:  MOVWF  54
19B4:  MOVF   4F,W
19B5:  MOVWF  53
19B6:  MOVF   4E,W
19B7:  MOVWF  52
19B8:  MOVF   33,W
19B9:  MOVWF  59
19BA:  MOVF   32,W
19BB:  MOVWF  58
19BC:  MOVF   31,W
19BD:  MOVWF  57
19BE:  MOVF   30,W
19BF:  MOVWF  56
19C0:  BCF    0A.4
19C1:  BCF    0A.3
19C2:  BCF    03.5
19C3:  CALL   19F
19C4:  BSF    0A.4
19C5:  BSF    0A.3
19C6:  BSF    03.5
19C7:  CLRF   4F
19C8:  MOVF   04,W
19C9:  MOVWF  4E
19CA:  BCF    4F.0
19CB:  BTFSC  03.7
19CC:  BSF    4F.0
19CD:  BCF    03.1
19CE:  MOVF   2B,W
19CF:  MOVWF  55
19D0:  MOVF   2A,W
19D1:  MOVWF  54
19D2:  MOVF   29,W
19D3:  MOVWF  53
19D4:  MOVF   28,W
19D5:  MOVWF  52
19D6:  MOVF   7A,W
19D7:  MOVWF  59
19D8:  MOVF   79,W
19D9:  MOVWF  58
19DA:  MOVF   78,W
19DB:  MOVWF  57
19DC:  MOVF   77,W
19DD:  MOVWF  56
19DE:  BCF    0A.3
19DF:  BCF    03.5
19E0:  CALL   599
19E1:  BSF    0A.3
19E2:  BSF    03.5
19E3:  MOVF   4E,W
19E4:  MOVWF  04
19E5:  BCF    03.7
19E6:  BTFSC  4F.0
19E7:  BSF    03.7
19E8:  MOVF   7A,W
19E9:  MOVWF  2B
19EA:  MOVF   79,W
19EB:  MOVWF  2A
19EC:  MOVF   78,W
19ED:  MOVWF  29
19EE:  MOVF   77,W
19EF:  MOVWF  28
19F0:  INCF   35,F
19F1:  GOTO   17A
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
19F2:  MOVF   34,W
19F3:  SUBLW  02
19F4:  BTFSC  03.2
19F5:  GOTO   1F8
19F6:  DECFSZ 34,W
19F7:  GOTO   1FB
....................       y = -y;  // correct sign 
19F8:  MOVF   29,W
19F9:  XORLW  80
19FA:  MOVWF  29
....................  
....................    return (y); 
19FB:  MOVF   28,W
19FC:  MOVWF  77
19FD:  MOVF   29,W
19FE:  MOVWF  78
19FF:  MOVF   2A,W
1A00:  MOVWF  79
1A01:  MOVF   2B,W
1A02:  MOVWF  7A
1A03:  BCF    03.5
1A04:  RETURN
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
*
0F98:  BSF    03.1
0F99:  MOVF   7E,W
0F9A:  BSF    03.5
0F9B:  MOVWF  55
0F9C:  MOVF   7D,W
0F9D:  MOVWF  54
0F9E:  MOVF   7C,W
0F9F:  MOVWF  53
0FA0:  MOVF   7B,W
0FA1:  MOVWF  52
0FA2:  MOVLW  DB
0FA3:  MOVWF  59
0FA4:  MOVLW  0F
0FA5:  MOVWF  58
0FA6:  MOVLW  49
0FA7:  MOVWF  57
0FA8:  MOVLW  7F
0FA9:  MOVWF  56
0FAA:  BSF    0A.4
0FAB:  BCF    0A.3
0FAC:  BCF    03.5
0FAD:  CALL   599
0FAE:  BCF    0A.4
0FAF:  BSF    0A.3
0FB0:  MOVF   7A,W
0FB1:  BSF    03.5
0FB2:  MOVWF  23
0FB3:  MOVF   79,W
0FB4:  MOVWF  22
0FB5:  MOVF   78,W
0FB6:  MOVWF  21
0FB7:  MOVF   77,W
0FB8:  MOVWF  20
0FB9:  MOVF   23,W
0FBA:  MOVWF  27
0FBB:  MOVF   22,W
0FBC:  MOVWF  26
0FBD:  MOVF   21,W
0FBE:  MOVWF  25
0FBF:  MOVF   20,W
0FC0:  MOVWF  24
0FC1:  BSF    0A.4
0FC2:  BCF    03.5
0FC3:  CALL   000
0FC4:  BCF    0A.4
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
*
0F53:  MOVF   6B,W
0F54:  BSF    03.5
0F55:  MOVWF  27
0F56:  BCF    03.5
0F57:  MOVF   6A,W
0F58:  BSF    03.5
0F59:  MOVWF  26
0F5A:  BCF    03.5
0F5B:  MOVF   69,W
0F5C:  BSF    03.5
0F5D:  MOVWF  25
0F5E:  BCF    03.5
0F5F:  MOVF   68,W
0F60:  BSF    03.5
0F61:  MOVWF  24
0F62:  BSF    0A.4
0F63:  BCF    03.5
0F64:  CALL   000
0F65:  BCF    0A.4
0F66:  MOVF   7A,W
0F67:  MOVWF  6F
0F68:  MOVF   79,W
0F69:  MOVWF  6E
0F6A:  MOVF   78,W
0F6B:  MOVWF  6D
0F6C:  MOVF   77,W
0F6D:  MOVWF  6C
....................    if (c == 0.0) 
0F6E:  MOVF   6F,W
0F6F:  BSF    03.5
0F70:  MOVWF  51
0F71:  BCF    03.5
0F72:  MOVF   6E,W
0F73:  BSF    03.5
0F74:  MOVWF  50
0F75:  BCF    03.5
0F76:  MOVF   6D,W
0F77:  BSF    03.5
0F78:  MOVWF  4F
0F79:  BCF    03.5
0F7A:  MOVF   6C,W
0F7B:  BSF    03.5
0F7C:  MOVWF  4E
0F7D:  CLRF   55
0F7E:  CLRF   54
0F7F:  CLRF   53
0F80:  CLRF   52
0F81:  BCF    0A.3
0F82:  BCF    03.5
0F83:  CALL   15E
0F84:  BSF    0A.3
0F85:  BTFSS  03.2
0F86:  GOTO   790
....................       return (1.0e+36); 
0F87:  MOVLW  F6
0F88:  MOVWF  77
0F89:  MOVLW  40
0F8A:  MOVWF  78
0F8B:  MOVLW  97
0F8C:  MOVWF  79
0F8D:  MOVLW  CE
0F8E:  MOVWF  7A
0F8F:  GOTO   7E6
....................  
....................    s = sin(x); 
0F90:  MOVF   6B,W
0F91:  MOVWF  7E
0F92:  MOVF   6A,W
0F93:  MOVWF  7D
0F94:  MOVF   69,W
0F95:  MOVWF  7C
0F96:  MOVF   68,W
0F97:  MOVWF  7B
*
0FC5:  MOVF   7A,W
0FC6:  MOVWF  73
0FC7:  MOVF   79,W
0FC8:  MOVWF  72
0FC9:  MOVF   78,W
0FCA:  MOVWF  71
0FCB:  MOVF   77,W
0FCC:  MOVWF  70
....................    return(s/c); 
0FCD:  MOVF   73,W
0FCE:  MOVWF  7E
0FCF:  MOVF   72,W
0FD0:  MOVWF  7D
0FD1:  MOVF   71,W
0FD2:  MOVWF  7C
0FD3:  MOVF   70,W
0FD4:  MOVWF  7B
0FD5:  MOVF   6F,W
0FD6:  BSF    03.5
0FD7:  MOVWF  23
0FD8:  BCF    03.5
0FD9:  MOVF   6E,W
0FDA:  BSF    03.5
0FDB:  MOVWF  22
0FDC:  BCF    03.5
0FDD:  MOVF   6D,W
0FDE:  BSF    03.5
0FDF:  MOVWF  21
0FE0:  BCF    03.5
0FE1:  MOVF   6C,W
0FE2:  BSF    03.5
0FE3:  MOVWF  20
0FE4:  BCF    03.5
0FE5:  CALL   566
0FE6:  BSF    0A.3
0FE7:  BSF    0A.4
0FE8:  GOTO   5DA (RETURN)
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define millis()  (msTimer) 
.................... int32 msTimer=0; 
....................  
....................  
.................... #INT_TIMER1 
.................... void timer1_isr() { 
....................    set_timer1(65286); // keep period at 1 ms (at 8 MHz) 
*
0061:  CLRF   0E
0062:  MOVLW  FF
0063:  MOVWF  0F
0064:  MOVLW  06
0065:  MOVWF  0E
....................    msTimer++; 
0066:  MOVLW  01
0067:  ADDWF  38,F
0068:  BTFSC  03.0
0069:  INCF   39,F
006A:  BTFSC  03.2
006B:  INCF   3A,F
006C:  BTFSC  03.2
006D:  INCF   3B,F
006E:  BCF    0C.0
006F:  BCF    0A.3
0070:  BCF    0A.4
0071:  GOTO   02D
.................... } 
....................  
....................  
.................... void pic_setup() { 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
*
1009:  MOVLW  35
100A:  MOVWF  10
....................    set_timer1(65286); // keep period at 1 ms (at 8 MHz) 
100B:  CLRF   0E
100C:  MOVLW  FF
100D:  MOVWF  0F
100E:  MOVLW  06
100F:  MOVWF  0E
....................    enable_interrupts(INT_TIMER1); 
1010:  BSF    03.5
1011:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
1012:  MOVLW  C0
1013:  BCF    03.5
1014:  IORWF  0B,F
....................  
.................... } 
....................  
....................  
....................  
.................... // VL53L0X sensor; 
....................  
....................  
.................... // Uncomment this line to use long range mode. This 
.................... // increases the sensitivity of the sensor and extends its 
.................... // potential range, but increases the likelihood of getting 
.................... // an inaccurate reading because of reflections from objects 
.................... // other than the intended target. It works best in dark 
.................... // conditions. 
....................  
.................... #define LONG_RANGE 
....................  
....................  
.................... // Uncomment ONE of these two lines to get 
.................... // - higher speed at the cost of lower accuracy OR 
.................... // - higher accuracy at the cost of lower speed 
....................  
.................... //#define HIGH_SPEED 
.................... #define HIGH_ACCURACY 
....................  
....................  
.................... void setup() 
.................... { 
....................  
....................    printf("Starting\r\n"); 
*
1000:  MOVLW  72
1001:  BSF    03.6
1002:  MOVWF  0D
1003:  MOVLW  00
1004:  MOVWF  0F
1005:  BCF    0A.4
1006:  BCF    03.6
1007:  CALL   0A2
1008:  BSF    0A.4
....................     
....................    pic_setup(); 
....................  
....................   init(); 
*
1015:  MOVLW  01
1016:  MOVWF  68
....................   setTimeout(200); 
*
1564:  BCF    03.5
1565:  CLRF   69
1566:  MOVLW  C8
1567:  MOVWF  68
....................  
.................... #if defined LONG_RANGE 
....................   // lower the return signal rate limit (default is 0.25 MCPS) 
....................   setSignalRateLimit(0.1); 
*
156C:  MOVLW  CD
156D:  MOVWF  7E
156E:  MOVLW  CC
156F:  MOVWF  7D
1570:  MOVLW  4C
1571:  MOVWF  7C
1572:  MOVLW  7B
1573:  MOVWF  7B
1574:  BCF    0A.4
1575:  CALL   25F
1576:  BSF    0A.4
....................   // increase laser pulse periods (defaults are 14 and 10 PCLKs) 
....................   setVcselPulsePeriod(VcselPeriodPreRange, 18); 
1577:  CLRF   68
1578:  MOVLW  12
1579:  MOVWF  69
157A:  BCF    0A.4
157B:  BSF    0A.3
157C:  CALL   313
157D:  BSF    0A.4
157E:  BCF    0A.3
....................   setVcselPulsePeriod(VcselPeriodFinalRange, 14); 
157F:  MOVLW  01
1580:  MOVWF  68
1581:  MOVLW  0E
1582:  MOVWF  69
1583:  BCF    0A.4
1584:  BSF    0A.3
1585:  CALL   313
1586:  BSF    0A.4
1587:  BCF    0A.3
.................... #endif 
....................  
.................... #if defined HIGH_SPEED 
....................   // reduce timing budget to 20 ms (default is about 33 ms) 
....................   setMeasurementTimingBudget(20000); 
.................... #elif defined HIGH_ACCURACY 
....................   // increase timing budget to 200 ms 
....................   setMeasurementTimingBudget(200000); 
1588:  BSF    03.5
1589:  CLRF   40
158A:  MOVLW  03
158B:  MOVWF  3F
158C:  MOVLW  0D
158D:  MOVWF  3E
158E:  MOVLW  40
158F:  MOVWF  3D
1590:  BCF    0A.4
1591:  BSF    0A.3
1592:  BCF    03.5
1593:  CALL   000
1594:  BSF    0A.4
1595:  BCF    0A.3
.................... #endif 
1596:  BSF    0A.3
1597:  BSF    0A.4
1598:  GOTO   4C6 (RETURN)
.................... } 
....................  
.................... void loop() 
.................... { 
....................   printf("%lu\r\n", readRangeSingleMillimeters()); 
....................   if (timeoutOccurred()) { printf(" TIMEOUT\r\n"); } 
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////// 
.................... //define LCD Display  
.................... //////////////////////////////////////////////////////////// 
.................... #define SLAVE_ADDRESS  0xB0 
.................... #define DISPLAY_ADDRESS 0xB4 
.................... #define REGISTER_SIZE  8    
.................... #define DISPLAY_CMD_SEND_VALUE 2 
.................... #define DISPLAY_CMD_SEND_LONG_TEXT 5 
.................... #define DISPLAY_CMD_CLS 6 
.................... #define DISPLAY_CMD_SETPOS 8 
.................... //////////////////////////////////////////////////////////// 
.................... //define LCD Display  
.................... //////////////////////////////////////////////////////////// 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //LCD Display Funtion  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... int16 rotaryR; 
.................... float degree,distance,tall,rad; 
....................  
.................... void displayLongText(char* text) { 
....................  
....................    int i ; 
....................    i2c_start(); 
*
0F1C:  BSF    03.5
0F1D:  BSF    11.0
0F1E:  BTFSC  11.0
0F1F:  GOTO   71E
....................    i2c_write(DISPLAY_ADDRESS); 
0F20:  MOVLW  B4
0F21:  MOVWF  6C
0F22:  BCF    0A.3
0F23:  BCF    03.5
0F24:  CALL   0FA
0F25:  BSF    0A.3
....................    i2c_write(DISPLAY_CMD_SEND_LONG_TEXT); 
0F26:  MOVLW  05
0F27:  BSF    03.5
0F28:  MOVWF  6C
0F29:  BCF    0A.3
0F2A:  BCF    03.5
0F2B:  CALL   0FA
0F2C:  BSF    0A.3
....................  
....................    for(i=0;text[i]!='\0';i++) 
0F2D:  CLRF   6C
0F2E:  MOVF   6C,W
0F2F:  ADDWF  6A,W
0F30:  MOVWF  04
0F31:  BCF    03.7
0F32:  BTFSC  6B.0
0F33:  BSF    03.7
0F34:  MOVF   00,F
0F35:  BTFSC  03.2
0F36:  GOTO   747
....................    { 
....................       i2c_write(text[i]); 
0F37:  MOVF   6C,W
0F38:  ADDWF  6A,W
0F39:  MOVWF  04
0F3A:  BCF    03.7
0F3B:  BTFSC  6B.0
0F3C:  BSF    03.7
0F3D:  MOVF   00,W
0F3E:  MOVWF  6D
0F3F:  BSF    03.5
0F40:  MOVWF  6C
0F41:  BCF    0A.3
0F42:  BCF    03.5
0F43:  CALL   0FA
0F44:  BSF    0A.3
0F45:  INCF   6C,F
0F46:  GOTO   72E
....................  
....................    } 
....................    i2c_write('\0'); 
0F47:  BSF    03.5
0F48:  CLRF   6C
0F49:  BCF    0A.3
0F4A:  BCF    03.5
0F4B:  CALL   0FA
0F4C:  BSF    0A.3
....................    i2c_stop(); 
0F4D:  BSF    03.5
0F4E:  BSF    11.2
0F4F:  BTFSC  11.2
0F50:  GOTO   74F
0F51:  BCF    03.5
0F52:  RETURN
....................  
.................... //delay_ms(100); 
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void clearDisplay(){ 
....................  
....................    i2c_start(); 
*
07DA:  BSF    03.5
07DB:  BSF    11.0
07DC:  BTFSC  11.0
07DD:  GOTO   7DC
....................    i2c_write(DISPLAY_ADDRESS); 
07DE:  MOVLW  B4
07DF:  MOVWF  6C
07E0:  BCF    03.5
07E1:  CALL   0FA
....................    i2c_write(DISPLAY_CMD_CLS); 
07E2:  MOVLW  06
07E3:  BSF    03.5
07E4:  MOVWF  6C
07E5:  BCF    03.5
07E6:  CALL   0FA
....................    i2c_stop(); 
07E7:  BSF    03.5
07E8:  BSF    11.2
07E9:  BTFSC  11.2
07EA:  GOTO   7E9
07EB:  BCF    03.5
07EC:  RETURN
.................... } 
....................  
.................... void setDisplayPos(int pos){ 
....................    i2c_start(); 
*
0EF8:  BSF    03.5
0EF9:  BSF    11.0
0EFA:  BTFSC  11.0
0EFB:  GOTO   6FA
....................    i2c_write(DISPLAY_ADDRESS); 
0EFC:  MOVLW  B4
0EFD:  MOVWF  6C
0EFE:  BCF    0A.3
0EFF:  BCF    03.5
0F00:  CALL   0FA
0F01:  BSF    0A.3
....................    i2c_write(DISPLAY_CMD_SETPOS); 
0F02:  MOVLW  08
0F03:  BSF    03.5
0F04:  MOVWF  6C
0F05:  BCF    0A.3
0F06:  BCF    03.5
0F07:  CALL   0FA
0F08:  BSF    0A.3
....................    i2c_write(pos); 
0F09:  MOVF   68,W
0F0A:  BSF    03.5
0F0B:  MOVWF  6C
0F0C:  BCF    0A.3
0F0D:  BCF    03.5
0F0E:  CALL   0FA
0F0F:  BSF    0A.3
....................    i2c_write('\0'); 
0F10:  BSF    03.5
0F11:  CLRF   6C
0F12:  BCF    0A.3
0F13:  BCF    03.5
0F14:  CALL   0FA
0F15:  BSF    0A.3
....................    i2c_stop(); 
0F16:  BSF    03.5
0F17:  BSF    11.2
0F18:  BTFSC  11.2
0F19:  GOTO   718
0F1A:  BCF    03.5
0F1B:  RETURN
.................... } 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //LCD Display Funtion  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //READ DISTANCE ULTRASONIC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void main() { 
*
1C87:  MOVF   03,W
1C88:  ANDLW  1F
1C89:  MOVWF  03
1C8A:  MOVLW  71
1C8B:  BSF    03.5
1C8C:  MOVWF  0F
1C8D:  CLRF   10
1C8E:  MOVF   0F,W
1C8F:  BSF    03.6
1C90:  BCF    07.3
1C91:  MOVLW  0C
1C92:  BCF    03.6
1C93:  MOVWF  19
1C94:  MOVLW  A2
1C95:  MOVWF  18
1C96:  MOVLW  90
1C97:  BCF    03.5
1C98:  MOVWF  18
1C99:  MOVLW  FF
1C9A:  MOVWF  2B
1C9B:  BSF    2B.3
1C9C:  MOVF   2B,W
1C9D:  BSF    03.5
1C9E:  MOVWF  07
1C9F:  BCF    03.5
1CA0:  BSF    2B.4
1CA1:  MOVF   2B,W
1CA2:  BSF    03.5
1CA3:  MOVWF  07
1CA4:  MOVLW  13
1CA5:  MOVWF  13
1CA6:  MOVLW  28
1CA7:  BCF    03.5
1CA8:  MOVWF  14
1CA9:  BSF    03.5
1CAA:  BSF    14.7
1CAB:  BCF    14.6
1CAC:  BCF    03.5
1CAD:  CLRF   3B
1CAE:  CLRF   3A
1CAF:  CLRF   39
1CB0:  CLRF   38
1CB1:  CLRF   3D
1CB2:  CLRF   3C
1CB3:  BSF    03.5
1CB4:  BSF    03.6
1CB5:  MOVF   09,W
1CB6:  ANDLW  C0
1CB7:  MOVWF  09
1CB8:  BCF    03.6
1CB9:  BCF    1F.4
1CBA:  BCF    1F.5
1CBB:  MOVLW  00
1CBC:  BSF    03.6
1CBD:  MOVWF  08
1CBE:  BCF    03.5
1CBF:  CLRF   07
1CC0:  CLRF   08
1CC1:  CLRF   09
1CC2:  BCF    03.7
....................    setup(); 
1CC3:  BCF    0A.3
1CC4:  BCF    03.6
1CC5:  GOTO   000
1CC6:  BSF    0A.3
....................     
....................     
....................     
....................     setup_adc_ports(sAN0); // setup PIN A0 as analog input  
1CC7:  BSF    03.5
1CC8:  BSF    03.6
1CC9:  MOVF   09,W
1CCA:  ANDLW  C0
1CCB:  MOVWF  09
1CCC:  BCF    03.6
1CCD:  BCF    1F.4
1CCE:  BCF    1F.5
1CCF:  MOVLW  01
1CD0:  BSF    03.6
1CD1:  MOVWF  08
....................     setup_adc( ADC_CLOCK_INTERNAL );  
1CD2:  BCF    03.5
1CD3:  BCF    03.6
1CD4:  BSF    1F.6
1CD5:  BSF    1F.7
1CD6:  BSF    03.5
1CD7:  BSF    1F.7
1CD8:  BCF    03.5
1CD9:  BSF    1F.0
....................  
....................     printf("Sampling:\r\n"); 
1CDA:  MOVLW  7E
1CDB:  BSF    03.6
1CDC:  MOVWF  0D
1CDD:  MOVLW  00
1CDE:  MOVWF  0F
1CDF:  BCF    0A.4
1CE0:  BCF    0A.3
1CE1:  BCF    03.6
1CE2:  CALL   0A2
1CE3:  BSF    0A.4
1CE4:  BSF    0A.3
....................     set_adc_channel( 0 ); // set the ADC chaneel to read  
1CE5:  MOVLW  00
1CE6:  MOVWF  78
1CE7:  MOVF   1F,W
1CE8:  ANDLW  C3
1CE9:  IORWF  78,W
1CEA:  MOVWF  1F
....................     delay_ms(50); // wait for the sensor reading to finish 
1CEB:  MOVLW  32
1CEC:  MOVWF  69
1CED:  BCF    0A.4
1CEE:  BCF    0A.3
1CEF:  CALL   7A7
1CF0:  BSF    0A.4
1CF1:  BSF    0A.3
....................       
....................     float toFloor ; 
....................      
....................    while(1) { 
....................        rotaryR = read_adc(); 
1CF2:  BSF    1F.1
1CF3:  BTFSC  1F.1
1CF4:  GOTO   4F3
1CF5:  BSF    03.5
1CF6:  MOVF   1E,W
1CF7:  BCF    03.5
1CF8:  MOVWF  3E
1CF9:  MOVF   1E,W
1CFA:  MOVWF  3F
....................       degree = 90.0*(rotaryR-394) / 137; 
1CFB:  MOVLW  8A
1CFC:  SUBWF  3E,W
1CFD:  MOVWF  77
1CFE:  MOVF   3F,W
1CFF:  MOVWF  7A
1D00:  MOVLW  01
1D01:  BTFSS  03.0
1D02:  MOVLW  02
1D03:  SUBWF  7A,F
1D04:  MOVF   77,W
1D05:  BSF    03.5
1D06:  MOVWF  52
1D07:  MOVF   7A,W
1D08:  MOVWF  53
1D09:  BCF    0A.4
1D0A:  BCF    0A.3
1D0B:  BCF    03.5
1D0C:  CALL   7BB
1D0D:  BSF    0A.4
1D0E:  BSF    0A.3
1D0F:  BSF    03.5
1D10:  CLRF   55
1D11:  CLRF   54
1D12:  MOVLW  34
1D13:  MOVWF  53
1D14:  MOVLW  85
1D15:  MOVWF  52
1D16:  MOVF   7A,W
1D17:  MOVWF  59
1D18:  MOVF   79,W
1D19:  MOVWF  58
1D1A:  MOVF   78,W
1D1B:  MOVWF  57
1D1C:  MOVF   77,W
1D1D:  MOVWF  56
1D1E:  BCF    0A.4
1D1F:  BCF    0A.3
1D20:  BCF    03.5
1D21:  CALL   19F
1D22:  BSF    0A.4
1D23:  BSF    0A.3
1D24:  MOVF   7A,W
1D25:  MOVWF  6B
1D26:  MOVF   79,W
1D27:  MOVWF  6A
1D28:  MOVF   78,W
1D29:  MOVWF  69
1D2A:  MOVF   77,W
1D2B:  MOVWF  68
1D2C:  MOVF   7A,W
1D2D:  MOVWF  7E
1D2E:  MOVF   79,W
1D2F:  MOVWF  7D
1D30:  MOVF   78,W
1D31:  MOVWF  7C
1D32:  MOVF   77,W
1D33:  MOVWF  7B
1D34:  BSF    03.5
1D35:  CLRF   23
1D36:  CLRF   22
1D37:  MOVLW  09
1D38:  MOVWF  21
1D39:  MOVLW  86
1D3A:  MOVWF  20
1D3B:  BCF    0A.4
1D3C:  BCF    03.5
1D3D:  CALL   566
1D3E:  BSF    0A.4
1D3F:  MOVF   7A,W
1D40:  MOVWF  43
1D41:  MOVF   79,W
1D42:  MOVWF  42
1D43:  MOVF   78,W
1D44:  MOVWF  41
1D45:  MOVF   77,W
1D46:  MOVWF  40
....................       distance = readRangeSingleMillimeters() / 10.0; 
1D47:  BCF    0A.4
1D48:  GOTO   63F
1D49:  BSF    0A.4
1D4A:  MOVF   79,W
1D4B:  MOVWF  69
1D4C:  MOVF   78,W
1D4D:  MOVWF  68
1D4E:  MOVF   79,W
1D4F:  BSF    03.5
1D50:  MOVWF  53
1D51:  BCF    03.5
1D52:  MOVF   78,W
1D53:  BSF    03.5
1D54:  MOVWF  52
1D55:  BCF    0A.4
1D56:  BCF    0A.3
1D57:  BCF    03.5
1D58:  CALL   7BB
1D59:  BSF    0A.4
1D5A:  BSF    0A.3
1D5B:  MOVF   7A,W
1D5C:  MOVWF  7E
1D5D:  MOVF   79,W
1D5E:  MOVWF  7D
1D5F:  MOVF   78,W
1D60:  MOVWF  7C
1D61:  MOVF   77,W
1D62:  MOVWF  7B
1D63:  BSF    03.5
1D64:  CLRF   23
1D65:  CLRF   22
1D66:  MOVLW  20
1D67:  MOVWF  21
1D68:  MOVLW  82
1D69:  MOVWF  20
1D6A:  BCF    0A.4
1D6B:  BCF    03.5
1D6C:  CALL   566
1D6D:  BSF    0A.4
1D6E:  MOVF   7A,W
1D6F:  MOVWF  47
1D70:  MOVF   79,W
1D71:  MOVWF  46
1D72:  MOVF   78,W
1D73:  MOVWF  45
1D74:  MOVF   77,W
1D75:  MOVWF  44
....................       //if (timeoutOccurred()) { printf(" TIMEOUT\r\n"); } 
....................  
....................       if(!input(PIN_B7)){ 
1D76:  BSF    03.5
1D77:  BSF    06.7
1D78:  BCF    03.5
1D79:  BTFSC  06.7
1D7A:  GOTO   5AB
....................          toFloor = distance; 
1D7B:  MOVF   47,W
1D7C:  MOVWF  53
1D7D:  MOVF   46,W
1D7E:  MOVWF  52
1D7F:  MOVF   45,W
1D80:  MOVWF  51
1D81:  MOVF   44,W
1D82:  MOVWF  50
....................           
....................          clearDisplay(); 
1D83:  BCF    0A.4
1D84:  BCF    0A.3
1D85:  CALL   7DA
1D86:  BSF    0A.4
1D87:  BSF    0A.3
....................          setDisplayPos(1); 
1D88:  MOVLW  01
1D89:  MOVWF  68
1D8A:  BCF    0A.4
1D8B:  CALL   6F8
1D8C:  BSF    0A.4
....................          displayLongText((char*)"Calibrated!"); 
1D8D:  CLRF   78
1D8E:  MOVLW  0C
1D8F:  MOVWF  77
1D90:  MOVLW  54
1D91:  MOVWF  04
1D92:  BCF    03.7
1D93:  MOVF   78,W
1D94:  BCF    0A.4
1D95:  BCF    0A.3
1D96:  CALL   051
1D97:  BSF    0A.4
1D98:  BSF    0A.3
1D99:  MOVWF  00
1D9A:  INCF   78,F
1D9B:  INCF   04,F
1D9C:  DECFSZ 77,F
1D9D:  GOTO   593
1D9E:  CLRF   6B
1D9F:  MOVLW  54
1DA0:  MOVWF  6A
1DA1:  BCF    0A.4
1DA2:  CALL   71C
1DA3:  BSF    0A.4
....................          delay_ms(100); 
1DA4:  MOVLW  64
1DA5:  MOVWF  69
1DA6:  BCF    0A.4
1DA7:  BCF    0A.3
1DA8:  CALL   7A7
1DA9:  BSF    0A.4
1DAA:  BSF    0A.3
....................       } 
....................  
....................       rad = degree * 0.0174533; 
1DAB:  MOVF   43,W
1DAC:  BSF    03.5
1DAD:  MOVWF  55
1DAE:  BCF    03.5
1DAF:  MOVF   42,W
1DB0:  BSF    03.5
1DB1:  MOVWF  54
1DB2:  BCF    03.5
1DB3:  MOVF   41,W
1DB4:  BSF    03.5
1DB5:  MOVWF  53
1DB6:  BCF    03.5
1DB7:  MOVF   40,W
1DB8:  BSF    03.5
1DB9:  MOVWF  52
1DBA:  MOVLW  39
1DBB:  MOVWF  59
1DBC:  MOVLW  FA
1DBD:  MOVWF  58
1DBE:  MOVLW  0E
1DBF:  MOVWF  57
1DC0:  MOVLW  79
1DC1:  MOVWF  56
1DC2:  BCF    0A.4
1DC3:  BCF    0A.3
1DC4:  BCF    03.5
1DC5:  CALL   19F
1DC6:  BSF    0A.4
1DC7:  BSF    0A.3
1DC8:  MOVF   7A,W
1DC9:  MOVWF  4F
1DCA:  MOVF   79,W
1DCB:  MOVWF  4E
1DCC:  MOVF   78,W
1DCD:  MOVWF  4D
1DCE:  MOVF   77,W
1DCF:  MOVWF  4C
....................       tall = (tan(rad) * distance ) + toFloor; 
1DD0:  MOVF   4F,W
1DD1:  MOVWF  6B
1DD2:  MOVF   4E,W
1DD3:  MOVWF  6A
1DD4:  MOVF   4D,W
1DD5:  MOVWF  69
1DD6:  MOVF   4C,W
1DD7:  MOVWF  68
1DD8:  BCF    0A.4
1DD9:  GOTO   753
1DDA:  BSF    0A.4
1DDB:  MOVF   7A,W
1DDC:  MOVWF  6B
1DDD:  MOVF   79,W
1DDE:  MOVWF  6A
1DDF:  MOVF   78,W
1DE0:  MOVWF  69
1DE1:  MOVF   77,W
1DE2:  MOVWF  68
1DE3:  MOVF   7A,W
1DE4:  BSF    03.5
1DE5:  MOVWF  55
1DE6:  BCF    03.5
1DE7:  MOVF   79,W
1DE8:  BSF    03.5
1DE9:  MOVWF  54
1DEA:  BCF    03.5
1DEB:  MOVF   78,W
1DEC:  BSF    03.5
1DED:  MOVWF  53
1DEE:  BCF    03.5
1DEF:  MOVF   77,W
1DF0:  BSF    03.5
1DF1:  MOVWF  52
1DF2:  BCF    03.5
1DF3:  MOVF   47,W
1DF4:  BSF    03.5
1DF5:  MOVWF  59
1DF6:  BCF    03.5
1DF7:  MOVF   46,W
1DF8:  BSF    03.5
1DF9:  MOVWF  58
1DFA:  BCF    03.5
1DFB:  MOVF   45,W
1DFC:  BSF    03.5
1DFD:  MOVWF  57
1DFE:  BCF    03.5
1DFF:  MOVF   44,W
1E00:  BSF    03.5
1E01:  MOVWF  56
1E02:  BCF    0A.4
1E03:  BCF    0A.3
1E04:  BCF    03.5
1E05:  CALL   19F
1E06:  BSF    0A.4
1E07:  BSF    0A.3
1E08:  MOVF   7A,W
1E09:  MOVWF  6B
1E0A:  MOVF   79,W
1E0B:  MOVWF  6A
1E0C:  MOVF   78,W
1E0D:  MOVWF  69
1E0E:  MOVF   77,W
1E0F:  MOVWF  68
1E10:  CLRF   6D
1E11:  MOVF   04,W
1E12:  MOVWF  6C
1E13:  BCF    6D.0
1E14:  BTFSC  03.7
1E15:  BSF    6D.0
1E16:  BCF    03.1
1E17:  MOVF   7A,W
1E18:  BSF    03.5
1E19:  MOVWF  55
1E1A:  BCF    03.5
1E1B:  MOVF   79,W
1E1C:  BSF    03.5
1E1D:  MOVWF  54
1E1E:  BCF    03.5
1E1F:  MOVF   78,W
1E20:  BSF    03.5
1E21:  MOVWF  53
1E22:  BCF    03.5
1E23:  MOVF   77,W
1E24:  BSF    03.5
1E25:  MOVWF  52
1E26:  BCF    03.5
1E27:  MOVF   53,W
1E28:  BSF    03.5
1E29:  MOVWF  59
1E2A:  BCF    03.5
1E2B:  MOVF   52,W
1E2C:  BSF    03.5
1E2D:  MOVWF  58
1E2E:  BCF    03.5
1E2F:  MOVF   51,W
1E30:  BSF    03.5
1E31:  MOVWF  57
1E32:  BCF    03.5
1E33:  MOVF   50,W
1E34:  BSF    03.5
1E35:  MOVWF  56
1E36:  BCF    0A.3
1E37:  BCF    03.5
1E38:  CALL   599
1E39:  BSF    0A.3
1E3A:  MOVF   6C,W
1E3B:  MOVWF  04
1E3C:  BCF    03.7
1E3D:  BTFSC  6D.0
1E3E:  BSF    03.7
1E3F:  MOVF   7A,W
1E40:  MOVWF  4B
1E41:  MOVF   79,W
1E42:  MOVWF  4A
1E43:  MOVF   78,W
1E44:  MOVWF  49
1E45:  MOVF   77,W
1E46:  MOVWF  48
....................      // tall = tall +  0; 
....................        
....................       printf("Sensor= %Lu\tDegree= %.2f\tDist= %.2f cm  tall=%f cm\r\n", rotaryR,degree,distance,tall); 
1E47:  MOVLW  84
1E48:  BSF    03.6
1E49:  MOVWF  0D
1E4A:  MOVLW  00
1E4B:  MOVWF  0F
1E4C:  BCF    03.0
1E4D:  MOVLW  08
1E4E:  BCF    03.6
1E4F:  MOVWF  68
1E50:  BCF    0A.3
1E51:  CALL   6DF
1E52:  BSF    0A.3
1E53:  MOVLW  10
1E54:  MOVWF  04
1E55:  MOVF   3F,W
1E56:  MOVWF  69
1E57:  MOVF   3E,W
1E58:  MOVWF  68
1E59:  BCF    0A.3
1E5A:  GOTO   738
1E5B:  BSF    0A.3
1E5C:  MOVLW  89
1E5D:  BSF    03.6
1E5E:  MOVWF  0D
1E5F:  MOVLW  00
1E60:  MOVWF  0F
1E61:  BSF    03.0
1E62:  MOVLW  09
1E63:  BCF    03.6
1E64:  MOVWF  68
1E65:  BCF    0A.3
1E66:  CALL   6DF
1E67:  BSF    0A.3
1E68:  MOVLW  89
1E69:  MOVWF  04
1E6A:  MOVF   43,W
1E6B:  MOVWF  6B
1E6C:  MOVF   42,W
1E6D:  MOVWF  6A
1E6E:  MOVF   41,W
1E6F:  MOVWF  69
1E70:  MOVF   40,W
1E71:  MOVWF  68
1E72:  MOVLW  02
1E73:  MOVWF  6C
1E74:  CALL   205
1E75:  MOVLW  90
1E76:  BSF    03.6
1E77:  MOVWF  0D
1E78:  MOVLW  00
1E79:  MOVWF  0F
1E7A:  BCF    03.0
1E7B:  MOVLW  07
1E7C:  BCF    03.6
1E7D:  MOVWF  68
1E7E:  BCF    0A.3
1E7F:  CALL   6DF
1E80:  BSF    0A.3
1E81:  MOVLW  89
1E82:  MOVWF  04
1E83:  MOVF   47,W
1E84:  MOVWF  6B
1E85:  MOVF   46,W
1E86:  MOVWF  6A
1E87:  MOVF   45,W
1E88:  MOVWF  69
1E89:  MOVF   44,W
1E8A:  MOVWF  68
1E8B:  MOVLW  02
1E8C:  MOVWF  6C
1E8D:  CALL   205
1E8E:  MOVLW  95
1E8F:  BSF    03.6
1E90:  MOVWF  0D
1E91:  MOVLW  00
1E92:  MOVWF  0F
1E93:  BSF    03.0
1E94:  MOVLW  0A
1E95:  BCF    03.6
1E96:  MOVWF  68
1E97:  BCF    0A.3
1E98:  CALL   6DF
1E99:  BSF    0A.3
1E9A:  MOVLW  89
1E9B:  MOVWF  04
1E9C:  MOVF   4B,W
1E9D:  MOVWF  6B
1E9E:  MOVF   4A,W
1E9F:  MOVWF  6A
1EA0:  MOVF   49,W
1EA1:  MOVWF  69
1EA2:  MOVF   48,W
1EA3:  MOVWF  68
1EA4:  MOVLW  02
1EA5:  MOVWF  6C
1EA6:  CALL   205
1EA7:  MOVLW  9B
1EA8:  BSF    03.6
1EA9:  MOVWF  0D
1EAA:  MOVLW  00
1EAB:  MOVWF  0F
1EAC:  BSF    03.0
1EAD:  MOVLW  05
1EAE:  BCF    03.6
1EAF:  MOVWF  68
1EB0:  BCF    0A.3
1EB1:  CALL   6DF
1EB2:  BSF    0A.3
....................       delay_ms(100); 
1EB3:  MOVLW  64
1EB4:  MOVWF  69
1EB5:  BCF    0A.4
1EB6:  BCF    0A.3
1EB7:  CALL   7A7
1EB8:  BSF    0A.4
1EB9:  BSF    0A.3
....................       clearDisplay(); 
1EBA:  BCF    0A.4
1EBB:  BCF    0A.3
1EBC:  CALL   7DA
1EBD:  BSF    0A.4
1EBE:  BSF    0A.3
....................       setDisplayPos(1); 
1EBF:  MOVLW  01
1EC0:  MOVWF  68
1EC1:  BCF    0A.4
1EC2:  CALL   6F8
1EC3:  BSF    0A.4
....................       char* message; 
....................       displayLongText((char*)"Deg:"); 
1EC4:  MOVLW  44
1EC5:  MOVWF  62
1EC6:  MOVLW  65
1EC7:  MOVWF  63
1EC8:  MOVLW  67
1EC9:  MOVWF  64
1ECA:  MOVLW  3A
1ECB:  MOVWF  65
1ECC:  CLRF   66
1ECD:  CLRF   6B
1ECE:  MOVLW  62
1ECF:  MOVWF  6A
1ED0:  BCF    0A.4
1ED1:  CALL   71C
1ED2:  BSF    0A.4
....................        
....................       if(degree >= 90) sprintf( message , "----" ); 
1ED3:  BSF    03.5
1ED4:  CLRF   51
1ED5:  CLRF   50
1ED6:  MOVLW  34
1ED7:  MOVWF  4F
1ED8:  MOVLW  85
1ED9:  MOVWF  4E
1EDA:  BCF    03.5
1EDB:  MOVF   43,W
1EDC:  BSF    03.5
1EDD:  MOVWF  55
1EDE:  BCF    03.5
1EDF:  MOVF   42,W
1EE0:  BSF    03.5
1EE1:  MOVWF  54
1EE2:  BCF    03.5
1EE3:  MOVF   41,W
1EE4:  BSF    03.5
1EE5:  MOVWF  53
1EE6:  BCF    03.5
1EE7:  MOVF   40,W
1EE8:  BSF    03.5
1EE9:  MOVWF  52
1EEA:  BCF    0A.4
1EEB:  BCF    0A.3
1EEC:  BCF    03.5
1EED:  CALL   15E
1EEE:  BSF    0A.4
1EEF:  BSF    0A.3
1EF0:  BTFSC  03.0
1EF1:  GOTO   6F4
1EF2:  BTFSS  03.2
1EF3:  GOTO   700
1EF4:  MOVF   61,W
1EF5:  MOVWF  3D
1EF6:  MOVF   60,W
1EF7:  MOVWF  3C
1EF8:  MOVLW  9F
1EF9:  BSF    03.6
1EFA:  MOVWF  0D
1EFB:  MOVLW  00
1EFC:  MOVWF  0F
1EFD:  BCF    03.6
1EFE:  GOTO   2F4
1EFF:  GOTO   711
....................       else sprintf( message , "%.1lf" ,(float) degree); 
1F00:  MOVF   61,W
1F01:  MOVWF  3D
1F02:  MOVF   60,W
1F03:  MOVWF  3C
1F04:  MOVLW  89
1F05:  MOVWF  04
1F06:  MOVF   43,W
1F07:  MOVWF  6F
1F08:  MOVF   42,W
1F09:  MOVWF  6E
1F0A:  MOVF   41,W
1F0B:  MOVWF  6D
1F0C:  MOVF   40,W
1F0D:  MOVWF  6C
1F0E:  MOVLW  01
1F0F:  MOVWF  70
1F10:  CALL   358
....................        
....................        setDisplayPos(5); 
1F11:  MOVLW  05
1F12:  MOVWF  68
1F13:  BCF    0A.4
1F14:  CALL   6F8
1F15:  BSF    0A.4
....................       displayLongText(message); 
1F16:  MOVF   61,W
1F17:  MOVWF  6B
1F18:  MOVF   60,W
1F19:  MOVWF  6A
1F1A:  BCF    0A.4
1F1B:  CALL   71C
1F1C:  BSF    0A.4
....................        
....................       setDisplayPos(9); 
1F1D:  MOVLW  09
1F1E:  MOVWF  68
1F1F:  BCF    0A.4
1F20:  CALL   6F8
1F21:  BSF    0A.4
....................       displayLongText((char*)"Dis:"); 
1F22:  MOVLW  44
1F23:  MOVWF  62
1F24:  MOVLW  69
1F25:  MOVWF  63
1F26:  MOVLW  73
1F27:  MOVWF  64
1F28:  MOVLW  3A
1F29:  MOVWF  65
1F2A:  CLRF   66
1F2B:  CLRF   6B
1F2C:  MOVLW  62
1F2D:  MOVWF  6A
1F2E:  BCF    0A.4
1F2F:  CALL   71C
1F30:  BSF    0A.4
....................       sprintf( message , "%.1lf" ,(float)distance /100.0); 
1F31:  MOVF   47,W
1F32:  MOVWF  7E
1F33:  MOVF   46,W
1F34:  MOVWF  7D
1F35:  MOVF   45,W
1F36:  MOVWF  7C
1F37:  MOVF   44,W
1F38:  MOVWF  7B
1F39:  BSF    03.5
1F3A:  CLRF   23
1F3B:  CLRF   22
1F3C:  MOVLW  48
1F3D:  MOVWF  21
1F3E:  MOVLW  85
1F3F:  MOVWF  20
1F40:  BCF    0A.4
1F41:  BCF    03.5
1F42:  CALL   566
1F43:  BSF    0A.4
1F44:  MOVF   7A,W
1F45:  MOVWF  6B
1F46:  MOVF   79,W
1F47:  MOVWF  6A
1F48:  MOVF   78,W
1F49:  MOVWF  69
1F4A:  MOVF   77,W
1F4B:  MOVWF  68
1F4C:  MOVF   61,W
1F4D:  MOVWF  3D
1F4E:  MOVF   60,W
1F4F:  MOVWF  3C
1F50:  MOVLW  89
1F51:  MOVWF  04
1F52:  MOVF   7A,W
1F53:  MOVWF  6F
1F54:  MOVF   79,W
1F55:  MOVWF  6E
1F56:  MOVF   78,W
1F57:  MOVWF  6D
1F58:  MOVF   77,W
1F59:  MOVWF  6C
1F5A:  MOVLW  01
1F5B:  MOVWF  70
1F5C:  CALL   358
....................       displayLongText(message); 
1F5D:  MOVF   61,W
1F5E:  MOVWF  6B
1F5F:  MOVF   60,W
1F60:  MOVWF  6A
1F61:  BCF    0A.4
1F62:  CALL   71C
1F63:  BSF    0A.4
....................  
.................... //!      if(!input(PIN_B7)){ 
.................... //!         distanceToFloor = distanceFromUltrasonic(); 
.................... //!      } 
....................       setDisplayPos(17); 
1F64:  MOVLW  11
1F65:  MOVWF  68
1F66:  BCF    0A.4
1F67:  CALL   6F8
1F68:  BSF    0A.4
....................       displayLongText((char*)"tall:"); 
1F69:  MOVLW  74
1F6A:  MOVWF  62
1F6B:  MOVLW  61
1F6C:  MOVWF  63
1F6D:  MOVLW  6C
1F6E:  MOVWF  64
1F6F:  MOVWF  65
1F70:  MOVLW  3A
1F71:  MOVWF  66
1F72:  CLRF   67
1F73:  CLRF   6B
1F74:  MOVLW  62
1F75:  MOVWF  6A
1F76:  BCF    0A.4
1F77:  CALL   71C
1F78:  BSF    0A.4
....................       sprintf( message , "%.1f" ,tall ); 
1F79:  MOVF   61,W
1F7A:  MOVWF  3D
1F7B:  MOVF   60,W
1F7C:  MOVWF  3C
1F7D:  MOVLW  89
1F7E:  MOVWF  04
1F7F:  MOVF   4B,W
1F80:  MOVWF  6F
1F81:  MOVF   4A,W
1F82:  MOVWF  6E
1F83:  MOVF   49,W
1F84:  MOVWF  6D
1F85:  MOVF   48,W
1F86:  MOVWF  6C
1F87:  MOVLW  01
1F88:  MOVWF  70
1F89:  CALL   358
....................       displayLongText(message); 
1F8A:  MOVF   61,W
1F8B:  MOVWF  6B
1F8C:  MOVF   60,W
1F8D:  MOVWF  6A
1F8E:  BCF    0A.4
1F8F:  CALL   71C
1F90:  BSF    0A.4
....................  
....................  
....................        
....................        
....................        
....................       delay_ms(300); 
1F91:  MOVLW  02
1F92:  MOVWF  68
1F93:  MOVLW  96
1F94:  MOVWF  69
1F95:  BCF    0A.4
1F96:  BCF    0A.3
1F97:  CALL   7A7
1F98:  BSF    0A.4
1F99:  BSF    0A.3
1F9A:  DECFSZ 68,F
1F9B:  GOTO   793
1F9C:  GOTO   4F2
....................        
....................       
....................        
....................    } 
....................  
.................... } 
....................  
....................  
.................... #include "VL53L0X/VL53L0X.c" 
.................... // Most of the functionality of this library is based on the VL53L0X API 
.................... // provided by ST (STSW-IMG005), and some of the explanatory comments are quoted 
.................... // or paraphrased from the API source code, API user manual (UM2039), and the 
.................... // VL53L0X datasheet. 
....................  
.................... #include <VL53L0X.h> 
.................... #ifndef VL53L0X_h 
.................... #define VL53L0X_h 
....................  
.................... //#include <Arduino.h> 
....................  
....................  
....................     // register addresses from API vl53l0x_device.h (ordered as listed there) 
....................     enum regAddr 
....................     { 
....................       SYSRANGE_START                              = 0x00, 
....................  
....................       SYSTEM_THRESH_HIGH                          = 0x0C, 
....................       SYSTEM_THRESH_LOW                           = 0x0E, 
....................  
....................       SYSTEM_SEQUENCE_CONFIG                      = 0x01, 
....................       SYSTEM_RANGE_CONFIG                         = 0x09, 
....................       SYSTEM_INTERMEASUREMENT_PERIOD              = 0x04, 
....................  
....................       SYSTEM_INTERRUPT_CONFIG_GPIO                = 0x0A, 
....................  
....................       GPIO_HV_MUX_ACTIVE_HIGH                     = 0x84, 
....................  
....................       SYSTEM_INTERRUPT_CLEAR                      = 0x0B, 
....................  
....................       RESULT_INTERRUPT_STATUS                     = 0x13, 
....................       RESULT_RANGE_STATUS                         = 0x14, 
....................  
....................       RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN       = 0xBC, 
....................       RESULT_CORE_RANGING_TOTAL_EVENTS_RTN        = 0xC0, 
....................       RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF       = 0xD0, 
....................       RESULT_CORE_RANGING_TOTAL_EVENTS_REF        = 0xD4, 
....................       RESULT_PEAK_SIGNAL_RATE_REF                 = 0xB6, 
....................  
....................       ALGO_PART_TO_PART_RANGE_OFFSET_MM           = 0x28, 
....................  
....................       I2C_SLAVE_DEVICE_ADDRESS                    = 0x8A, 
....................  
....................       MSRC_CONFIG_CONTROL                         = 0x60, 
....................  
....................       PRE_RANGE_CONFIG_MIN_SNR                    = 0x27, 
....................       PRE_RANGE_CONFIG_VALID_PHASE_LOW            = 0x56, 
....................       PRE_RANGE_CONFIG_VALID_PHASE_HIGH           = 0x57, 
....................       PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT          = 0x64, 
....................  
....................       FINAL_RANGE_CONFIG_MIN_SNR                  = 0x67, 
....................       FINAL_RANGE_CONFIG_VALID_PHASE_LOW          = 0x47, 
....................       FINAL_RANGE_CONFIG_VALID_PHASE_HIGH         = 0x48, 
....................       FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT = 0x44, 
....................  
....................       PRE_RANGE_CONFIG_SIGMA_THRESH_HI            = 0x61, 
....................       PRE_RANGE_CONFIG_SIGMA_THRESH_LO            = 0x62, 
....................  
....................       PRE_RANGE_CONFIG_VCSEL_PERIOD               = 0x50, 
....................       PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI          = 0x51, 
....................       PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO          = 0x52, 
....................  
....................       SYSTEM_HISTOGRAM_BIN                        = 0x81, 
....................       HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT       = 0x33, 
....................       HISTOGRAM_CONFIG_READOUT_CTRL               = 0x55, 
....................  
....................       FINAL_RANGE_CONFIG_VCSEL_PERIOD             = 0x70, 
....................       FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI        = 0x71, 
....................       FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO        = 0x72, 
....................       CROSSTALK_COMPENSATION_PEAK_RATE_MCPS       = 0x20, 
....................  
....................       MSRC_CONFIG_TIMEOUT_MACROP                  = 0x46, 
....................  
....................       SOFT_RESET_GO2_SOFT_RESET_N                 = 0xBF, 
....................       IDENTIFICATION_MODEL_ID                     = 0xC0, 
....................       IDENTIFICATION_REVISION_ID                  = 0xC2, 
....................  
....................       OSC_CALIBRATE_VAL                           = 0xF8, 
....................  
....................       GLOBAL_CONFIG_VCSEL_WIDTH                   = 0x32, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_0            = 0xB0, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_1            = 0xB1, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_2            = 0xB2, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_3            = 0xB3, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_4            = 0xB4, 
....................       GLOBAL_CONFIG_SPAD_ENABLES_REF_5            = 0xB5, 
....................  
....................       GLOBAL_CONFIG_REF_EN_START_SELECT           = 0xB6, 
....................       DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD         = 0x4E, 
....................       DYNAMIC_SPAD_REF_EN_START_OFFSET            = 0x4F, 
....................       POWER_MANAGEMENT_GO1_POWER_FORCE            = 0x80, 
....................  
....................       VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV           = 0x89, 
....................  
....................       ALGO_PHASECAL_LIM                           = 0x30, 
....................       ALGO_PHASECAL_CONFIG_TIMEOUT                = 0x30, 
....................     }; 
....................  
....................     // private variables 
....................  
....................     typedef struct  
....................     { 
....................       boolean tcc, msrc, dss, pre_range, final_range; 
....................     } SequenceStepEnables; 
....................  
....................  
....................  
....................     typedef struct  
....................     { 
....................       int16 pre_range_vcsel_period_pclks, final_range_vcsel_period_pclks; 
....................  
....................       int16 msrc_dss_tcc_mclks, pre_range_mclks, final_range_mclks; 
....................       int32 msrc_dss_tcc_us,    pre_range_us,    final_range_us; 
....................     } SequenceStepTimeouts; 
....................  
....................     void getSequenceStepEnables(SequenceStepEnables * enables); 
....................     void getSequenceStepTimeouts(SequenceStepEnables * enables, SequenceStepTimeouts * timeouts); 
....................      
....................      
....................     enum vcselPeriodType { VcselPeriodPreRange, VcselPeriodFinalRange }; 
....................  
....................     int8 address; 
....................     int16 io_timeout; 
....................     boolean did_timeout; 
....................     int16 timeout_start_ms; 
....................  
....................     int8 stop_variable; // read by init and used when starting measurement; is StopVariable field of VL53L0X_DevData_t structure in API 
....................     int32 measurement_timing_budget_us; 
....................  
....................     boolean getSpadInfo(int8 * count, boolean * type_is_aperture); 
....................  
....................     int8 last_status; // status of last I2C transmission 
....................  
....................     VL53L0X(void); 
....................  
....................     void setAddress(int8 new_addr); 
....................     int8 getAddress(void) { return address; } 
....................  
....................     boolean init(boolean io_2v8 = TRUE); 
....................     #separate boolean init2(); 
....................  
....................     void writeReg(int8 reg, int8 value); 
....................     void writeReg16Bit(int8 reg, int16 value); 
....................     void writeReg32Bit(int8 reg, int32 value); 
....................     int8 readReg(int8 reg); 
....................     int16 readReg16Bit(int8 reg); 
....................     int32 readReg32Bit(int8 reg); 
....................  
....................     void writeMulti(int8 reg, int8  * src, int8 count); 
....................     void readMulti(int8 reg, int8 * dst, int8 count); 
....................  
....................     boolean setSignalRateLimit(float limit_Mcps); 
....................     float getSignalRateLimit(void); 
....................  
....................     boolean setMeasurementTimingBudget(int32 budget_us); 
....................     int32 getMeasurementTimingBudget(void); 
....................  
....................     boolean setVcselPulsePeriod(vcselPeriodType type, int8 period_pclks); 
....................     int8 getVcselPulsePeriod(vcselPeriodType type); 
....................  
....................     void startContinuous(int32 period_ms = 0); 
....................     void stopContinuous(void); 
....................     int16 readRangeContinuousMillimeters(void); 
....................     int16 readRangeSingleMillimeters(void); 
....................  
....................     void setTimeout(int16 timeout) { io_timeout = timeout; } 
....................     int16 getTimeout(void) { return io_timeout; } 
....................     boolean timeoutOccurred(void); 
....................  
....................  
....................  
....................     boolean performSingleRefCalibration(int8 vhv_init_byte); 
....................  
....................     static int16 decodeTimeout(int16 value); 
....................     static int16 encodeTimeout(int16 timeout_mclks); 
....................     static int32 timeoutMclksToMicroseconds(int16 timeout_period_mclks, int8 vcsel_period_pclks); 
....................     static int32 timeoutMicrosecondsToMclks(int32 timeout_period_us, int8 vcsel_period_pclks); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... // #include <Wire.h> 
....................  
.................... // Defines ///////////////////////////////////////////////////////////////////// 
....................  
.................... // The Arduino two-wire interface uses a 7-bit number for the address, 
.................... // and sets the last bit correctly based on reads and writes 
.................... //#define ADDRESS_DEFAULT 0b0101001 
....................  
.................... // 8 bit i2c address 
.................... #define ADDRESS_DEFAULT 0b01010010 
....................  
.................... // Record the current time to check an upcoming timeout against 
.................... #define startTimeout() (timeout_start_ms = millis()) 
.................... //#define startTimeout() (timeout_start_ms = 0) 
....................  
.................... // Check if timeout is enabled (set to nonzero value) and has expired 
.................... #define checkTimeoutExpired() (io_timeout > 0 && ((int16)millis() - timeout_start_ms) > io_timeout) 
....................  
.................... // Decode VCSEL (vertical cavity surface emitting laser) pulse period in PCLKs 
.................... // from register value 
.................... // based on VL53L0X_decode_vcsel_period() 
.................... #define decodeVcselPeriod(reg_val)      (((reg_val) + 1) << 1) 
....................  
.................... // Encode VCSEL pulse period register value from period in PCLKs 
.................... // based on VL53L0X_encode_vcsel_period() 
.................... #define encodeVcselPeriod(period_pclks) (((period_pclks) >> 1) - 1) 
....................  
.................... // Calculate macro period in *nanoseconds* from VCSEL period in PCLKs 
.................... // based on VL53L0X_calc_macro_period_ps() 
.................... // PLL_period_ps = 1655; macro_period_vclks = 2304 
.................... #define calcMacroPeriod(vcsel_period_pclks) ((((int32)2304 * (vcsel_period_pclks) * 1655) + 500) / 1000) 
....................  
1F9D:  SLEEP
.................... // Constructors //////////////////////////////////////////////////////////////// 
....................  
.................... // VL53L0X(void) 
.................... //   : address(ADDRESS_DEFAULT) 
.................... //   , io_timeout(0) // no timeout 
.................... //   , did_timeout(false) 
.................... // { 
.................... // } 
.................... //!VL53L0X(void) { 
.................... //!  address = (ADDRESS_DEFAULT); 
.................... //!  io_timeout =0 ; // no timeout 
.................... //!  did_timeout = false; 
.................... //!} 
.................... // Public Methods ////////////////////////////////////////////////////////////// 
....................  
.................... void setAddress(int8 new_addr) 
.................... { 
....................   writeReg(I2C_SLAVE_DEVICE_ADDRESS, new_addr & 0x7F); 
....................   address = new_addr; 
.................... } 
....................  
.................... // Initialize sensor using sequence based on VL53L0X_DataInit(), 
.................... // VL53L0X_StaticInit(), and VL53L0X_PerformRefCalibration(). 
.................... // This function does not perform reference SPAD calibration 
.................... // (VL53L0X_PerformRefSpadManagement()), since the API user manual says that it 
.................... // is performed by ST on the bare modules; it seems like that should work well 
.................... // enough unless a cover glass is added. 
.................... // If io_2v8 (optional) is true or not given, the sensor is configured for 2V8 
.................... // mode. 
.................... boolean init(boolean io_2v8) 
.................... { 
....................   // VL53L0X_DataInit() begin 
....................   address = (ADDRESS_DEFAULT); 
*
1017:  MOVLW  52
1018:  MOVWF  2C
....................   io_timeout =0 ; // no timeout 
1019:  CLRF   2E
101A:  CLRF   2D
....................   did_timeout = false; 
101B:  BCF    2F.0
....................    
....................   // sensor uses 1V8 mode for I/O by default; switch to 2V8 mode if necessary 
....................   if (io_2v8) 
101C:  MOVF   68,F
101D:  BTFSC  03.2
101E:  GOTO   032
....................   { 
....................     writeReg(VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV, 
....................       readReg(VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV) | 0x01); // set bit 0 
101F:  MOVLW  89
1020:  BSF    03.5
1021:  MOVWF  69
1022:  BCF    0A.4
1023:  BCF    03.5
1024:  CALL   11C
1025:  BSF    0A.4
1026:  MOVF   78,W
1027:  IORLW  01
1028:  MOVWF  74
1029:  MOVLW  89
102A:  BSF    03.5
102B:  MOVWF  3F
102C:  MOVF   74,W
102D:  MOVWF  40
102E:  BCF    0A.4
102F:  BCF    03.5
1030:  CALL   142
1031:  BSF    0A.4
....................   } 
....................  
....................   // "Set I2C standard mode" 
....................   writeReg(0x88, 0x00); 
1032:  MOVLW  88
1033:  BSF    03.5
1034:  MOVWF  3F
1035:  CLRF   40
1036:  BCF    0A.4
1037:  BCF    03.5
1038:  CALL   142
1039:  BSF    0A.4
....................  
....................   writeReg(0x80, 0x01); 
103A:  MOVLW  80
103B:  BSF    03.5
103C:  MOVWF  3F
103D:  MOVLW  01
103E:  MOVWF  40
103F:  BCF    0A.4
1040:  BCF    03.5
1041:  CALL   142
1042:  BSF    0A.4
....................   writeReg(0xFF, 0x01); 
1043:  MOVLW  FF
1044:  BSF    03.5
1045:  MOVWF  3F
1046:  MOVLW  01
1047:  MOVWF  40
1048:  BCF    0A.4
1049:  BCF    03.5
104A:  CALL   142
104B:  BSF    0A.4
....................   writeReg(0x00, 0x00); 
104C:  BSF    03.5
104D:  CLRF   3F
104E:  CLRF   40
104F:  BCF    0A.4
1050:  BCF    03.5
1051:  CALL   142
1052:  BSF    0A.4
....................   stop_variable = readReg(0x91); 
1053:  MOVLW  91
1054:  BSF    03.5
1055:  MOVWF  69
1056:  BCF    0A.4
1057:  BCF    03.5
1058:  CALL   11C
1059:  BSF    0A.4
105A:  MOVF   78,W
105B:  MOVWF  32
....................   writeReg(0x00, 0x01); 
105C:  BSF    03.5
105D:  CLRF   3F
105E:  MOVLW  01
105F:  MOVWF  40
1060:  BCF    0A.4
1061:  BCF    03.5
1062:  CALL   142
1063:  BSF    0A.4
....................   writeReg(0xFF, 0x00); 
1064:  MOVLW  FF
1065:  BSF    03.5
1066:  MOVWF  3F
1067:  CLRF   40
1068:  BCF    0A.4
1069:  BCF    03.5
106A:  CALL   142
106B:  BSF    0A.4
....................   writeReg(0x80, 0x00); 
106C:  MOVLW  80
106D:  BSF    03.5
106E:  MOVWF  3F
106F:  CLRF   40
1070:  BCF    0A.4
1071:  BCF    03.5
1072:  CALL   142
1073:  BSF    0A.4
....................  
....................   // disable SIGNAL_RATE_MSRC (bit 1) and SIGNAL_RATE_PRE_RANGE (bit 4) limit checks 
....................   writeReg(MSRC_CONFIG_CONTROL, readReg(MSRC_CONFIG_CONTROL) | 0x12); 
1074:  MOVLW  60
1075:  BSF    03.5
1076:  MOVWF  69
1077:  BCF    0A.4
1078:  BCF    03.5
1079:  CALL   11C
107A:  BSF    0A.4
107B:  MOVF   78,W
107C:  IORLW  12
107D:  MOVWF  74
107E:  MOVLW  60
107F:  BSF    03.5
1080:  MOVWF  3F
1081:  MOVF   74,W
1082:  MOVWF  40
1083:  BCF    0A.4
1084:  BCF    03.5
1085:  CALL   142
1086:  BSF    0A.4
....................  
....................   // set final range signal rate limit to 0.25 MCPS (million counts per second) 
....................   setSignalRateLimit(0.25); 
1087:  CLRF   7E
1088:  CLRF   7D
1089:  CLRF   7C
108A:  MOVLW  7D
108B:  MOVWF  7B
108C:  BCF    0A.4
108D:  CALL   25F
108E:  BSF    0A.4
....................  
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, 0xFF); 
108F:  MOVLW  01
1090:  BSF    03.5
1091:  MOVWF  3F
1092:  MOVLW  FF
1093:  MOVWF  40
1094:  BCF    0A.4
1095:  BCF    03.5
1096:  CALL   142
1097:  BSF    0A.4
....................  
....................   // VL53L0X_DataInit() end 
....................  
....................   // VL53L0X_StaticInit() begin 
....................  
....................   int8 spad_count; 
....................   //boolean spad_type_is_aperture;    // boolean can't be used as a pointer 
....................   int8 spad_type_is_aperture; 
....................    
....................    
....................    
....................   if (!getSpadInfo(&spad_count, &spad_type_is_aperture)) { return false; } 
1098:  CLRF   75
1099:  MOVLW  69
109A:  MOVWF  74
109B:  CLRF   7C
109C:  MOVLW  6A
109D:  MOVWF  7B
*
11A4:  MOVF   78,F
11A5:  BTFSS  03.2
11A6:  GOTO   1AA
11A7:  MOVLW  00
11A8:  MOVWF  78
11A9:  GOTO   564
....................  
....................   // The SPAD map (RefGoodSpadMap) is read by VL53L0X_get_info_from_device() in 
....................   // the API, but the same data seems to be more easily readable from 
....................   // GLOBAL_CONFIG_SPAD_ENABLES_REF_0 through _6, so read it from there 
....................   int8 ref_spad_map[6]; 
....................   readMulti(GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6); 
11AA:  MOVLW  B0
11AB:  MOVWF  74
11AC:  CLRF   76
11AD:  MOVLW  6B
11AE:  MOVWF  75
11AF:  MOVLW  06
11B0:  MOVWF  7B
....................  
....................   // -- VL53L0X_set_reference_spads() begin (assume NVM values are valid) 
....................  
....................   writeReg(0xFF, 0x01); 
*
11FE:  MOVLW  FF
11FF:  MOVWF  3F
1200:  MOVLW  01
1201:  MOVWF  40
1202:  BCF    0A.4
1203:  BCF    03.5
1204:  CALL   142
1205:  BSF    0A.4
....................   writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00); 
1206:  MOVLW  4F
1207:  BSF    03.5
1208:  MOVWF  3F
1209:  CLRF   40
120A:  BCF    0A.4
120B:  BCF    03.5
120C:  CALL   142
120D:  BSF    0A.4
....................   writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C); 
120E:  MOVLW  4E
120F:  BSF    03.5
1210:  MOVWF  3F
1211:  MOVLW  2C
1212:  MOVWF  40
1213:  BCF    0A.4
1214:  BCF    03.5
1215:  CALL   142
1216:  BSF    0A.4
....................   writeReg(0xFF, 0x00); 
1217:  MOVLW  FF
1218:  BSF    03.5
1219:  MOVWF  3F
121A:  CLRF   40
121B:  BCF    0A.4
121C:  BCF    03.5
121D:  CALL   142
121E:  BSF    0A.4
....................   writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4); 
121F:  MOVLW  B6
1220:  BSF    03.5
1221:  MOVWF  3F
1222:  MOVLW  B4
1223:  MOVWF  40
1224:  BCF    0A.4
1225:  BCF    03.5
1226:  CALL   142
1227:  BSF    0A.4
....................  
....................   int8 first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad 
....................   int8 spads_enabled = 0; 
1228:  MOVF   6A,F
1229:  BTFSC  03.2
122A:  GOTO   22D
122B:  MOVLW  0C
122C:  GOTO   22E
122D:  MOVLW  00
122E:  MOVWF  71
122F:  CLRF   72
....................  
....................   for (int8 i = 0; i < 48; i++) 
1230:  CLRF   73
1231:  MOVF   73,W
1232:  SUBLW  2F
1233:  BTFSS  03.0
1234:  GOTO   276
....................   { 
....................     if (i < first_spad_to_enable || spads_enabled == spad_count) 
1235:  MOVF   71,W
1236:  SUBWF  73,W
1237:  BTFSS  03.0
1238:  GOTO   23D
1239:  MOVF   69,W
123A:  SUBWF  72,W
123B:  BTFSS  03.2
123C:  GOTO   258
....................     { 
....................       // This bit is lower than the first one that should be enabled, or 
....................       // (reference_spad_count) bits have already been enabled, so zero this bit 
....................       ref_spad_map[i / 8] &= ~(1 << (i % 8)); 
123D:  RRF    73,W
123E:  MOVWF  77
123F:  RRF    77,F
1240:  RRF    77,F
1241:  MOVLW  1F
1242:  ANDWF  77,F
1243:  MOVF   77,W
1244:  ADDLW  6B
1245:  MOVWF  04
1246:  BCF    03.7
1247:  MOVF   73,W
1248:  ANDLW  07
1249:  MOVWF  78
124A:  MOVLW  01
124B:  MOVWF  77
124C:  MOVF   78,F
124D:  BTFSC  03.2
124E:  GOTO   253
124F:  BCF    03.0
1250:  RLF    77,F
1251:  DECFSZ 78,F
1252:  GOTO   24F
1253:  MOVF   77,W
1254:  XORLW  FF
1255:  ANDWF  00,W
1256:  MOVWF  00
....................     } 
1257:  GOTO   274
....................     else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1) 
1258:  RRF    73,W
1259:  MOVWF  77
125A:  RRF    77,F
125B:  RRF    77,F
125C:  MOVLW  1F
125D:  ANDWF  77,F
125E:  MOVF   77,W
125F:  ADDLW  6B
1260:  MOVWF  04
1261:  BCF    03.7
1262:  MOVF   00,W
1263:  MOVWF  74
1264:  MOVF   73,W
1265:  ANDLW  07
1266:  MOVWF  78
1267:  MOVF   74,W
1268:  MOVWF  77
1269:  MOVF   78,F
126A:  BTFSC  03.2
126B:  GOTO   270
126C:  BCF    03.0
126D:  RRF    77,F
126E:  DECFSZ 78,F
126F:  GOTO   26C
1270:  MOVF   77,W
1271:  ANDLW  01
1272:  BTFSS  03.2
....................     { 
....................       spads_enabled++; 
1273:  INCF   72,F
....................     } 
1274:  INCF   73,F
1275:  GOTO   231
....................   } 
....................  
....................   writeMulti(GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6); 
1276:  MOVLW  B0
1277:  MOVWF  74
1278:  CLRF   76
1279:  MOVLW  6B
127A:  MOVWF  75
127B:  MOVLW  06
127C:  MOVWF  7B
....................  
....................   // -- VL53L0X_set_reference_spads() end 
....................  
....................   // -- VL53L0X_load_tuning_settings() begin 
....................   // DefaultTuningSettings from vl53l0x_tuning.h 
....................  
....................   writeReg(0xFF, 0x01); 
*
12AE:  MOVLW  FF
12AF:  MOVWF  3F
12B0:  MOVLW  01
12B1:  MOVWF  40
12B2:  BCF    0A.4
12B3:  BCF    03.5
12B4:  CALL   142
12B5:  BSF    0A.4
....................   writeReg(0x00, 0x00); 
12B6:  BSF    03.5
12B7:  CLRF   3F
12B8:  CLRF   40
12B9:  BCF    0A.4
12BA:  BCF    03.5
12BB:  CALL   142
12BC:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
12BD:  MOVLW  FF
12BE:  BSF    03.5
12BF:  MOVWF  3F
12C0:  CLRF   40
12C1:  BCF    0A.4
12C2:  BCF    03.5
12C3:  CALL   142
12C4:  BSF    0A.4
....................   writeReg(0x09, 0x00); 
12C5:  MOVLW  09
12C6:  BSF    03.5
12C7:  MOVWF  3F
12C8:  CLRF   40
12C9:  BCF    0A.4
12CA:  BCF    03.5
12CB:  CALL   142
12CC:  BSF    0A.4
....................   writeReg(0x10, 0x00); 
12CD:  MOVLW  10
12CE:  BSF    03.5
12CF:  MOVWF  3F
12D0:  CLRF   40
12D1:  BCF    0A.4
12D2:  BCF    03.5
12D3:  CALL   142
12D4:  BSF    0A.4
....................   writeReg(0x11, 0x00); 
12D5:  MOVLW  11
12D6:  BSF    03.5
12D7:  MOVWF  3F
12D8:  CLRF   40
12D9:  BCF    0A.4
12DA:  BCF    03.5
12DB:  CALL   142
12DC:  BSF    0A.4
....................  
....................   writeReg(0x24, 0x01); 
12DD:  MOVLW  24
12DE:  BSF    03.5
12DF:  MOVWF  3F
12E0:  MOVLW  01
12E1:  MOVWF  40
12E2:  BCF    0A.4
12E3:  BCF    03.5
12E4:  CALL   142
12E5:  BSF    0A.4
....................   writeReg(0x25, 0xFF); 
12E6:  MOVLW  25
12E7:  BSF    03.5
12E8:  MOVWF  3F
12E9:  MOVLW  FF
12EA:  MOVWF  40
12EB:  BCF    0A.4
12EC:  BCF    03.5
12ED:  CALL   142
12EE:  BSF    0A.4
....................   writeReg(0x75, 0x00); 
12EF:  MOVLW  75
12F0:  BSF    03.5
12F1:  MOVWF  3F
12F2:  CLRF   40
12F3:  BCF    0A.4
12F4:  BCF    03.5
12F5:  CALL   142
12F6:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x01); 
12F7:  MOVLW  FF
12F8:  BSF    03.5
12F9:  MOVWF  3F
12FA:  MOVLW  01
12FB:  MOVWF  40
12FC:  BCF    0A.4
12FD:  BCF    03.5
12FE:  CALL   142
12FF:  BSF    0A.4
....................   writeReg(0x4E, 0x2C); 
1300:  MOVLW  4E
1301:  BSF    03.5
1302:  MOVWF  3F
1303:  MOVLW  2C
1304:  MOVWF  40
1305:  BCF    0A.4
1306:  BCF    03.5
1307:  CALL   142
1308:  BSF    0A.4
....................   writeReg(0x48, 0x00); 
1309:  MOVLW  48
130A:  BSF    03.5
130B:  MOVWF  3F
130C:  CLRF   40
130D:  BCF    0A.4
130E:  BCF    03.5
130F:  CALL   142
1310:  BSF    0A.4
....................   writeReg(0x30, 0x20); 
1311:  MOVLW  30
1312:  BSF    03.5
1313:  MOVWF  3F
1314:  MOVLW  20
1315:  MOVWF  40
1316:  BCF    0A.4
1317:  BCF    03.5
1318:  CALL   142
1319:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
131A:  MOVLW  FF
131B:  BSF    03.5
131C:  MOVWF  3F
131D:  CLRF   40
131E:  BCF    0A.4
131F:  BCF    03.5
1320:  CALL   142
1321:  BSF    0A.4
....................   writeReg(0x30, 0x09); 
1322:  MOVLW  30
1323:  BSF    03.5
1324:  MOVWF  3F
1325:  MOVLW  09
1326:  MOVWF  40
1327:  BCF    0A.4
1328:  BCF    03.5
1329:  CALL   142
132A:  BSF    0A.4
....................   writeReg(0x54, 0x00); 
132B:  MOVLW  54
132C:  BSF    03.5
132D:  MOVWF  3F
132E:  CLRF   40
132F:  BCF    0A.4
1330:  BCF    03.5
1331:  CALL   142
1332:  BSF    0A.4
....................   writeReg(0x31, 0x04); 
1333:  MOVLW  31
1334:  BSF    03.5
1335:  MOVWF  3F
1336:  MOVLW  04
1337:  MOVWF  40
1338:  BCF    0A.4
1339:  BCF    03.5
133A:  CALL   142
133B:  BSF    0A.4
....................   writeReg(0x32, 0x03); 
133C:  MOVLW  32
133D:  BSF    03.5
133E:  MOVWF  3F
133F:  MOVLW  03
1340:  MOVWF  40
1341:  BCF    0A.4
1342:  BCF    03.5
1343:  CALL   142
1344:  BSF    0A.4
....................   writeReg(0x40, 0x83); 
1345:  MOVLW  40
1346:  BSF    03.5
1347:  MOVWF  3F
1348:  MOVLW  83
1349:  MOVWF  40
134A:  BCF    0A.4
134B:  BCF    03.5
134C:  CALL   142
134D:  BSF    0A.4
....................   writeReg(0x46, 0x25); 
134E:  MOVLW  46
134F:  BSF    03.5
1350:  MOVWF  3F
1351:  MOVLW  25
1352:  MOVWF  40
1353:  BCF    0A.4
1354:  BCF    03.5
1355:  CALL   142
1356:  BSF    0A.4
....................   writeReg(0x60, 0x00); 
1357:  MOVLW  60
1358:  BSF    03.5
1359:  MOVWF  3F
135A:  CLRF   40
135B:  BCF    0A.4
135C:  BCF    03.5
135D:  CALL   142
135E:  BSF    0A.4
....................   writeReg(0x27, 0x00); 
135F:  MOVLW  27
1360:  BSF    03.5
1361:  MOVWF  3F
1362:  CLRF   40
1363:  BCF    0A.4
1364:  BCF    03.5
1365:  CALL   142
1366:  BSF    0A.4
....................   writeReg(0x50, 0x06); 
1367:  MOVLW  50
1368:  BSF    03.5
1369:  MOVWF  3F
136A:  MOVLW  06
136B:  MOVWF  40
136C:  BCF    0A.4
136D:  BCF    03.5
136E:  CALL   142
136F:  BSF    0A.4
....................   writeReg(0x51, 0x00); 
1370:  MOVLW  51
1371:  BSF    03.5
1372:  MOVWF  3F
1373:  CLRF   40
1374:  BCF    0A.4
1375:  BCF    03.5
1376:  CALL   142
1377:  BSF    0A.4
....................   writeReg(0x52, 0x96); 
1378:  MOVLW  52
1379:  BSF    03.5
137A:  MOVWF  3F
137B:  MOVLW  96
137C:  MOVWF  40
137D:  BCF    0A.4
137E:  BCF    03.5
137F:  CALL   142
1380:  BSF    0A.4
....................   writeReg(0x56, 0x08); 
1381:  MOVLW  56
1382:  BSF    03.5
1383:  MOVWF  3F
1384:  MOVLW  08
1385:  MOVWF  40
1386:  BCF    0A.4
1387:  BCF    03.5
1388:  CALL   142
1389:  BSF    0A.4
....................   writeReg(0x57, 0x30); 
138A:  MOVLW  57
138B:  BSF    03.5
138C:  MOVWF  3F
138D:  MOVLW  30
138E:  MOVWF  40
138F:  BCF    0A.4
1390:  BCF    03.5
1391:  CALL   142
1392:  BSF    0A.4
....................   writeReg(0x61, 0x00); 
1393:  MOVLW  61
1394:  BSF    03.5
1395:  MOVWF  3F
1396:  CLRF   40
1397:  BCF    0A.4
1398:  BCF    03.5
1399:  CALL   142
139A:  BSF    0A.4
....................   writeReg(0x62, 0x00); 
139B:  MOVLW  62
139C:  BSF    03.5
139D:  MOVWF  3F
139E:  CLRF   40
139F:  BCF    0A.4
13A0:  BCF    03.5
13A1:  CALL   142
13A2:  BSF    0A.4
....................   writeReg(0x64, 0x00); 
13A3:  MOVLW  64
13A4:  BSF    03.5
13A5:  MOVWF  3F
13A6:  CLRF   40
13A7:  BCF    0A.4
13A8:  BCF    03.5
13A9:  CALL   142
13AA:  BSF    0A.4
....................   writeReg(0x65, 0x00); 
13AB:  MOVLW  65
13AC:  BSF    03.5
13AD:  MOVWF  3F
13AE:  CLRF   40
13AF:  BCF    0A.4
13B0:  BCF    03.5
13B1:  CALL   142
13B2:  BSF    0A.4
....................   writeReg(0x66, 0xA0); 
13B3:  MOVLW  66
13B4:  BSF    03.5
13B5:  MOVWF  3F
13B6:  MOVLW  A0
13B7:  MOVWF  40
13B8:  BCF    0A.4
13B9:  BCF    03.5
13BA:  CALL   142
13BB:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x01); 
13BC:  MOVLW  FF
13BD:  BSF    03.5
13BE:  MOVWF  3F
13BF:  MOVLW  01
13C0:  MOVWF  40
13C1:  BCF    0A.4
13C2:  BCF    03.5
13C3:  CALL   142
13C4:  BSF    0A.4
....................   writeReg(0x22, 0x32); 
13C5:  MOVLW  22
13C6:  BSF    03.5
13C7:  MOVWF  3F
13C8:  MOVLW  32
13C9:  MOVWF  40
13CA:  BCF    0A.4
13CB:  BCF    03.5
13CC:  CALL   142
13CD:  BSF    0A.4
....................   writeReg(0x47, 0x14); 
13CE:  MOVLW  47
13CF:  BSF    03.5
13D0:  MOVWF  3F
13D1:  MOVLW  14
13D2:  MOVWF  40
13D3:  BCF    0A.4
13D4:  BCF    03.5
13D5:  CALL   142
13D6:  BSF    0A.4
....................   writeReg(0x49, 0xFF); 
13D7:  MOVLW  49
13D8:  BSF    03.5
13D9:  MOVWF  3F
13DA:  MOVLW  FF
13DB:  MOVWF  40
13DC:  BCF    0A.4
13DD:  BCF    03.5
13DE:  CALL   142
13DF:  BSF    0A.4
....................   writeReg(0x4A, 0x00); 
13E0:  MOVLW  4A
13E1:  BSF    03.5
13E2:  MOVWF  3F
13E3:  CLRF   40
13E4:  BCF    0A.4
13E5:  BCF    03.5
13E6:  CALL   142
13E7:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
13E8:  MOVLW  FF
13E9:  BSF    03.5
13EA:  MOVWF  3F
13EB:  CLRF   40
13EC:  BCF    0A.4
13ED:  BCF    03.5
13EE:  CALL   142
13EF:  BSF    0A.4
....................   writeReg(0x7A, 0x0A); 
13F0:  MOVLW  7A
13F1:  BSF    03.5
13F2:  MOVWF  3F
13F3:  MOVLW  0A
13F4:  MOVWF  40
13F5:  BCF    0A.4
13F6:  BCF    03.5
13F7:  CALL   142
13F8:  BSF    0A.4
....................   writeReg(0x7B, 0x00); 
13F9:  MOVLW  7B
13FA:  BSF    03.5
13FB:  MOVWF  3F
13FC:  CLRF   40
13FD:  BCF    0A.4
13FE:  BCF    03.5
13FF:  CALL   142
1400:  BSF    0A.4
....................   writeReg(0x78, 0x21); 
1401:  MOVLW  78
1402:  BSF    03.5
1403:  MOVWF  3F
1404:  MOVLW  21
1405:  MOVWF  40
1406:  BCF    0A.4
1407:  BCF    03.5
1408:  CALL   142
1409:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x01); 
140A:  MOVLW  FF
140B:  BSF    03.5
140C:  MOVWF  3F
140D:  MOVLW  01
140E:  MOVWF  40
140F:  BCF    0A.4
1410:  BCF    03.5
1411:  CALL   142
1412:  BSF    0A.4
....................   writeReg(0x23, 0x34); 
1413:  MOVLW  23
1414:  BSF    03.5
1415:  MOVWF  3F
1416:  MOVLW  34
1417:  MOVWF  40
1418:  BCF    0A.4
1419:  BCF    03.5
141A:  CALL   142
141B:  BSF    0A.4
....................   writeReg(0x42, 0x00); 
141C:  MOVLW  42
141D:  BSF    03.5
141E:  MOVWF  3F
141F:  CLRF   40
1420:  BCF    0A.4
1421:  BCF    03.5
1422:  CALL   142
1423:  BSF    0A.4
....................   writeReg(0x44, 0xFF); 
1424:  MOVLW  44
1425:  BSF    03.5
1426:  MOVWF  3F
1427:  MOVLW  FF
1428:  MOVWF  40
1429:  BCF    0A.4
142A:  BCF    03.5
142B:  CALL   142
142C:  BSF    0A.4
....................   writeReg(0x45, 0x26); 
142D:  MOVLW  45
142E:  BSF    03.5
142F:  MOVWF  3F
1430:  MOVLW  26
1431:  MOVWF  40
1432:  BCF    0A.4
1433:  BCF    03.5
1434:  CALL   142
1435:  BSF    0A.4
....................   writeReg(0x46, 0x05); 
1436:  MOVLW  46
1437:  BSF    03.5
1438:  MOVWF  3F
1439:  MOVLW  05
143A:  MOVWF  40
143B:  BCF    0A.4
143C:  BCF    03.5
143D:  CALL   142
143E:  BSF    0A.4
....................   writeReg(0x40, 0x40); 
143F:  MOVLW  40
1440:  BSF    03.5
1441:  MOVWF  3F
1442:  MOVWF  40
1443:  BCF    0A.4
1444:  BCF    03.5
1445:  CALL   142
1446:  BSF    0A.4
....................   writeReg(0x0E, 0x06); 
1447:  MOVLW  0E
1448:  BSF    03.5
1449:  MOVWF  3F
144A:  MOVLW  06
144B:  MOVWF  40
144C:  BCF    0A.4
144D:  BCF    03.5
144E:  CALL   142
144F:  BSF    0A.4
....................   writeReg(0x20, 0x1A); 
1450:  MOVLW  20
1451:  BSF    03.5
1452:  MOVWF  3F
1453:  MOVLW  1A
1454:  MOVWF  40
1455:  BCF    0A.4
1456:  BCF    03.5
1457:  CALL   142
1458:  BSF    0A.4
....................   writeReg(0x43, 0x40); 
1459:  MOVLW  43
145A:  BSF    03.5
145B:  MOVWF  3F
145C:  MOVLW  40
145D:  MOVWF  40
145E:  BCF    0A.4
145F:  BCF    03.5
1460:  CALL   142
1461:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
1462:  MOVLW  FF
1463:  BSF    03.5
1464:  MOVWF  3F
1465:  CLRF   40
1466:  BCF    0A.4
1467:  BCF    03.5
1468:  CALL   142
1469:  BSF    0A.4
....................   writeReg(0x34, 0x03); 
146A:  MOVLW  34
146B:  BSF    03.5
146C:  MOVWF  3F
146D:  MOVLW  03
146E:  MOVWF  40
146F:  BCF    0A.4
1470:  BCF    03.5
1471:  CALL   142
1472:  BSF    0A.4
....................   writeReg(0x35, 0x44); 
1473:  MOVLW  35
1474:  BSF    03.5
1475:  MOVWF  3F
1476:  MOVLW  44
1477:  MOVWF  40
1478:  BCF    0A.4
1479:  BCF    03.5
147A:  CALL   142
147B:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x01); 
147C:  MOVLW  FF
147D:  BSF    03.5
147E:  MOVWF  3F
147F:  MOVLW  01
1480:  MOVWF  40
1481:  BCF    0A.4
1482:  BCF    03.5
1483:  CALL   142
1484:  BSF    0A.4
....................   writeReg(0x31, 0x04); 
1485:  MOVLW  31
1486:  BSF    03.5
1487:  MOVWF  3F
1488:  MOVLW  04
1489:  MOVWF  40
148A:  BCF    0A.4
148B:  BCF    03.5
148C:  CALL   142
148D:  BSF    0A.4
....................   writeReg(0x4B, 0x09); 
148E:  MOVLW  4B
148F:  BSF    03.5
1490:  MOVWF  3F
1491:  MOVLW  09
1492:  MOVWF  40
1493:  BCF    0A.4
1494:  BCF    03.5
1495:  CALL   142
1496:  BSF    0A.4
....................   writeReg(0x4C, 0x05); 
1497:  MOVLW  4C
1498:  BSF    03.5
1499:  MOVWF  3F
149A:  MOVLW  05
149B:  MOVWF  40
149C:  BCF    0A.4
149D:  BCF    03.5
149E:  CALL   142
149F:  BSF    0A.4
....................   writeReg(0x4D, 0x04); 
14A0:  MOVLW  4D
14A1:  BSF    03.5
14A2:  MOVWF  3F
14A3:  MOVLW  04
14A4:  MOVWF  40
14A5:  BCF    0A.4
14A6:  BCF    03.5
14A7:  CALL   142
14A8:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
14A9:  MOVLW  FF
14AA:  BSF    03.5
14AB:  MOVWF  3F
14AC:  CLRF   40
14AD:  BCF    0A.4
14AE:  BCF    03.5
14AF:  CALL   142
14B0:  BSF    0A.4
....................   writeReg(0x44, 0x00); 
14B1:  MOVLW  44
14B2:  BSF    03.5
14B3:  MOVWF  3F
14B4:  CLRF   40
14B5:  BCF    0A.4
14B6:  BCF    03.5
14B7:  CALL   142
14B8:  BSF    0A.4
....................   writeReg(0x45, 0x20); 
14B9:  MOVLW  45
14BA:  BSF    03.5
14BB:  MOVWF  3F
14BC:  MOVLW  20
14BD:  MOVWF  40
14BE:  BCF    0A.4
14BF:  BCF    03.5
14C0:  CALL   142
14C1:  BSF    0A.4
....................   writeReg(0x47, 0x08); 
14C2:  MOVLW  47
14C3:  BSF    03.5
14C4:  MOVWF  3F
14C5:  MOVLW  08
14C6:  MOVWF  40
14C7:  BCF    0A.4
14C8:  BCF    03.5
14C9:  CALL   142
14CA:  BSF    0A.4
....................   writeReg(0x48, 0x28); 
14CB:  MOVLW  48
14CC:  BSF    03.5
14CD:  MOVWF  3F
14CE:  MOVLW  28
14CF:  MOVWF  40
14D0:  BCF    0A.4
14D1:  BCF    03.5
14D2:  CALL   142
14D3:  BSF    0A.4
....................   writeReg(0x67, 0x00); 
14D4:  MOVLW  67
14D5:  BSF    03.5
14D6:  MOVWF  3F
14D7:  CLRF   40
14D8:  BCF    0A.4
14D9:  BCF    03.5
14DA:  CALL   142
14DB:  BSF    0A.4
....................   writeReg(0x70, 0x04); 
14DC:  MOVLW  70
14DD:  BSF    03.5
14DE:  MOVWF  3F
14DF:  MOVLW  04
14E0:  MOVWF  40
14E1:  BCF    0A.4
14E2:  BCF    03.5
14E3:  CALL   142
14E4:  BSF    0A.4
....................   writeReg(0x71, 0x01); 
14E5:  MOVLW  71
14E6:  BSF    03.5
14E7:  MOVWF  3F
14E8:  MOVLW  01
14E9:  MOVWF  40
14EA:  BCF    0A.4
14EB:  BCF    03.5
14EC:  CALL   142
14ED:  BSF    0A.4
....................   writeReg(0x72, 0xFE); 
14EE:  MOVLW  72
14EF:  BSF    03.5
14F0:  MOVWF  3F
14F1:  MOVLW  FE
14F2:  MOVWF  40
14F3:  BCF    0A.4
14F4:  BCF    03.5
14F5:  CALL   142
14F6:  BSF    0A.4
....................   writeReg(0x76, 0x00); 
14F7:  MOVLW  76
14F8:  BSF    03.5
14F9:  MOVWF  3F
14FA:  CLRF   40
14FB:  BCF    0A.4
14FC:  BCF    03.5
14FD:  CALL   142
14FE:  BSF    0A.4
....................   writeReg(0x77, 0x00); 
14FF:  MOVLW  77
1500:  BSF    03.5
1501:  MOVWF  3F
1502:  CLRF   40
1503:  BCF    0A.4
1504:  BCF    03.5
1505:  CALL   142
1506:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x01); 
1507:  MOVLW  FF
1508:  BSF    03.5
1509:  MOVWF  3F
150A:  MOVLW  01
150B:  MOVWF  40
150C:  BCF    0A.4
150D:  BCF    03.5
150E:  CALL   142
150F:  BSF    0A.4
....................   writeReg(0x0D, 0x01); 
1510:  MOVLW  0D
1511:  BSF    03.5
1512:  MOVWF  3F
1513:  MOVLW  01
1514:  MOVWF  40
1515:  BCF    0A.4
1516:  BCF    03.5
1517:  CALL   142
1518:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
1519:  MOVLW  FF
151A:  BSF    03.5
151B:  MOVWF  3F
151C:  CLRF   40
151D:  BCF    0A.4
151E:  BCF    03.5
151F:  CALL   142
1520:  BSF    0A.4
....................   writeReg(0x80, 0x01); 
1521:  MOVLW  80
1522:  BSF    03.5
1523:  MOVWF  3F
1524:  MOVLW  01
1525:  MOVWF  40
1526:  BCF    0A.4
1527:  BCF    03.5
1528:  CALL   142
1529:  BSF    0A.4
....................   writeReg(0x01, 0xF8); 
152A:  MOVLW  01
152B:  BSF    03.5
152C:  MOVWF  3F
152D:  MOVLW  F8
152E:  MOVWF  40
152F:  BCF    0A.4
1530:  BCF    03.5
1531:  CALL   142
1532:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x01); 
1533:  MOVLW  FF
1534:  BSF    03.5
1535:  MOVWF  3F
1536:  MOVLW  01
1537:  MOVWF  40
1538:  BCF    0A.4
1539:  BCF    03.5
153A:  CALL   142
153B:  BSF    0A.4
....................   writeReg(0x8E, 0x01); 
153C:  MOVLW  8E
153D:  BSF    03.5
153E:  MOVWF  3F
153F:  MOVLW  01
1540:  MOVWF  40
1541:  BCF    0A.4
1542:  BCF    03.5
1543:  CALL   142
1544:  BSF    0A.4
....................   writeReg(0x00, 0x01); 
1545:  BSF    03.5
1546:  CLRF   3F
1547:  MOVLW  01
1548:  MOVWF  40
1549:  BCF    0A.4
154A:  BCF    03.5
154B:  CALL   142
154C:  BSF    0A.4
....................   writeReg(0xFF, 0x00); 
154D:  MOVLW  FF
154E:  BSF    03.5
154F:  MOVWF  3F
1550:  CLRF   40
1551:  BCF    0A.4
1552:  BCF    03.5
1553:  CALL   142
1554:  BSF    0A.4
....................   writeReg(0x80, 0x00); 
1555:  MOVLW  80
1556:  BSF    03.5
1557:  MOVWF  3F
1558:  CLRF   40
1559:  BCF    0A.4
155A:  BCF    03.5
155B:  CALL   142
155C:  BSF    0A.4
....................    
....................   return init2(); 
155D:  BCF    0A.4
155E:  BSF    0A.3
155F:  GOTO   1A6
1560:  BSF    0A.4
1561:  BCF    0A.3
1562:  MOVF   78,W
1563:  BSF    03.5
....................  
....................  
.................... } 
....................  
....................  
.................... #separate boolean init2() { 
....................   // -- VL53L0X_load_tuning_settings() end 
....................  
....................   // "Set interrupt config to new sample ready" 
....................   // -- VL53L0X_SetGpioConfig() begin 
....................  
....................   writeReg(SYSTEM_INTERRUPT_CONFIG_GPIO, 0x04); 
*
09A6:  MOVLW  0A
09A7:  BSF    03.5
09A8:  MOVWF  3F
09A9:  MOVLW  04
09AA:  MOVWF  40
09AB:  BCF    0A.3
09AC:  BCF    03.5
09AD:  CALL   142
09AE:  BSF    0A.3
....................   writeReg(GPIO_HV_MUX_ACTIVE_HIGH, readReg(GPIO_HV_MUX_ACTIVE_HIGH) & ~0x10); // active low 
09AF:  MOVLW  84
09B0:  BSF    03.5
09B1:  MOVWF  69
09B2:  BCF    0A.3
09B3:  BCF    03.5
09B4:  CALL   11C
09B5:  BSF    0A.3
09B6:  MOVF   78,W
09B7:  ANDLW  EF
09B8:  MOVWF  74
09B9:  MOVLW  84
09BA:  BSF    03.5
09BB:  MOVWF  3F
09BC:  MOVF   74,W
09BD:  MOVWF  40
09BE:  BCF    0A.3
09BF:  BCF    03.5
09C0:  CALL   142
09C1:  BSF    0A.3
....................   writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01); 
09C2:  MOVLW  0B
09C3:  BSF    03.5
09C4:  MOVWF  3F
09C5:  MOVLW  01
09C6:  MOVWF  40
09C7:  BCF    0A.3
09C8:  BCF    03.5
09C9:  CALL   142
09CA:  BSF    0A.3
....................  
....................   // -- VL53L0X_SetGpioConfig() end 
....................  
....................   measurement_timing_budget_us = getMeasurementTimingBudget(); 
*
0ABD:  MOVF   7A,W
0ABE:  MOVWF  36
0ABF:  MOVF   79,W
0AC0:  MOVWF  35
0AC1:  MOVF   78,W
0AC2:  MOVWF  34
0AC3:  MOVF   77,W
0AC4:  MOVWF  33
....................  
....................   // "Disable MSRC and TCC by default" 
....................   // MSRC = Minimum Signal Rate Check 
....................   // TCC = Target CentreCheck 
....................   // -- VL53L0X_SetSequenceStepEnable() begin 
....................  
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8); 
0AC5:  MOVLW  01
0AC6:  BSF    03.5
0AC7:  MOVWF  3F
0AC8:  MOVLW  E8
0AC9:  MOVWF  40
0ACA:  BCF    0A.3
0ACB:  BCF    03.5
0ACC:  CALL   142
0ACD:  BSF    0A.3
....................  
....................   // -- VL53L0X_SetSequenceStepEnable() end 
....................  
....................   // "Recalculate timing budget" 
....................   setMeasurementTimingBudget(measurement_timing_budget_us); 
0ACE:  MOVF   36,W
0ACF:  BSF    03.5
0AD0:  MOVWF  40
0AD1:  BCF    03.5
0AD2:  MOVF   35,W
0AD3:  BSF    03.5
0AD4:  MOVWF  3F
0AD5:  BCF    03.5
0AD6:  MOVF   34,W
0AD7:  BSF    03.5
0AD8:  MOVWF  3E
0AD9:  BCF    03.5
0ADA:  MOVF   33,W
0ADB:  BSF    03.5
0ADC:  MOVWF  3D
0ADD:  BCF    03.5
0ADE:  CALL   000
....................  
....................   // VL53L0X_StaticInit() end 
....................  
....................   // VL53L0X_PerformRefCalibration() begin (VL53L0X_perform_ref_calibration()) 
....................  
....................   // -- VL53L0X_perform_vhv_calibration() begin 
....................  
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, 0x01); 
0ADF:  MOVLW  01
0AE0:  BSF    03.5
0AE1:  MOVWF  3F
0AE2:  MOVWF  40
0AE3:  BCF    0A.3
0AE4:  BCF    03.5
0AE5:  CALL   142
0AE6:  BSF    0A.3
....................   if (!performSingleRefCalibration(0x40)) { return false; } 
0AE7:  MOVLW  40
0AE8:  BSF    03.5
0AE9:  MOVWF  3D
0AEA:  BCF    03.5
0AEB:  CALL   14C
0AEC:  MOVF   78,F
0AED:  BTFSS  03.2
0AEE:  GOTO   2F2
0AEF:  MOVLW  00
0AF0:  MOVWF  78
0AF1:  GOTO   310
....................  
....................   // -- VL53L0X_perform_vhv_calibration() end 
....................  
....................   // -- VL53L0X_perform_phase_calibration() begin 
....................  
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02); 
0AF2:  MOVLW  01
0AF3:  BSF    03.5
0AF4:  MOVWF  3F
0AF5:  MOVLW  02
0AF6:  MOVWF  40
0AF7:  BCF    0A.3
0AF8:  BCF    03.5
0AF9:  CALL   142
0AFA:  BSF    0A.3
....................   if (!performSingleRefCalibration(0x00)) { return false; } 
0AFB:  BSF    03.5
0AFC:  CLRF   3D
0AFD:  BCF    03.5
0AFE:  CALL   14C
0AFF:  MOVF   78,F
0B00:  BTFSS  03.2
0B01:  GOTO   305
0B02:  MOVLW  00
0B03:  MOVWF  78
0B04:  GOTO   310
....................  
....................   // -- VL53L0X_perform_phase_calibration() end 
....................  
....................   // "restore the previous Sequence Config" 
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8); 
0B05:  MOVLW  01
0B06:  BSF    03.5
0B07:  MOVWF  3F
0B08:  MOVLW  E8
0B09:  MOVWF  40
0B0A:  BCF    0A.3
0B0B:  BCF    03.5
0B0C:  CALL   142
0B0D:  BSF    0A.3
....................  
....................   // VL53L0X_PerformRefCalibration() end 
....................  
....................   return true; 
0B0E:  MOVLW  01
0B0F:  MOVWF  78
0B10:  BCF    0A.3
0B11:  BSF    0A.4
0B12:  GOTO   560 (RETURN)
.................... } 
....................  
.................... // Write an 8-bit register 
.................... void writeReg(int8 reg, int8 value) 
.................... { 
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  Wire.write(value); 
.................... //!  last_status = Wire.endTransmission(); 
....................  
.................... // IN the Arduino, last_status has the following values 
.................... //!0:success 
.................... //!1:data too long to fit in transmit buffer 
.................... //!2:received NACK on transmit of address 
.................... //!3:received NACK on transmit of data 
.................... //!4:other error 
....................  
.................... // In our current port, last_status will only depend on the 
.................... // success or failure of the last transmitted byte 
.................... // 0 = success, got an ack 
.................... // 1 =  no ack (NACK) 
.................... // 2 = collision 
....................  
.................... i2c_start(); 
*
0142:  BSF    03.5
0143:  BSF    11.0
0144:  BTFSC  11.0
0145:  GOTO   144
.................... i2c_write(address); 
0146:  BCF    03.5
0147:  MOVF   2C,W
0148:  BSF    03.5
0149:  MOVWF  6C
014A:  BCF    03.5
014B:  CALL   0FA
.................... i2c_write(reg); 
014C:  BSF    03.5
014D:  MOVF   3F,W
014E:  MOVWF  6C
014F:  BCF    03.5
0150:  CALL   0FA
.................... last_status = i2c_write(value); 
0151:  BSF    03.5
0152:  MOVF   40,W
0153:  MOVWF  6C
0154:  BCF    03.5
0155:  CALL   0FA
0156:  MOVF   78,W
0157:  MOVWF  37
.................... i2c_stop(); 
0158:  BSF    03.5
0159:  BSF    11.2
015A:  BTFSC  11.2
015B:  GOTO   15A
015C:  BCF    03.5
015D:  RETURN
....................  
.................... } 
....................  
.................... // Write a 16-bit register 
.................... void writeReg16Bit(int8 reg, int16 value) 
.................... { 
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  Wire.write((value >> 8) & 0xFF); // value high byte 
.................... //!  Wire.write( value       & 0xFF); // value low byte 
.................... //!  last_status = Wire.endTransmission(); 
.................... i2c_start(); 
*
0237:  BSF    03.5
0238:  BSF    11.0
0239:  BTFSC  11.0
023A:  GOTO   239
.................... i2c_write(address); 
023B:  BCF    03.5
023C:  MOVF   2C,W
023D:  BSF    03.5
023E:  MOVWF  6C
023F:  BCF    03.5
0240:  CALL   0FA
.................... i2c_write(reg); 
0241:  BSF    03.5
0242:  MOVF   64,W
0243:  MOVWF  6C
0244:  BCF    03.5
0245:  CALL   0FA
.................... i2c_write((value >> 8) & 0xFF); 
0246:  BSF    03.5
0247:  MOVF   66,W
0248:  MOVWF  67
0249:  CLRF   68
024A:  CLRF   68
024B:  MOVF   66,W
024C:  MOVWF  6C
024D:  BCF    03.5
024E:  CALL   0FA
.................... last_status = i2c_write(value & 0xFF); 
024F:  BSF    03.5
0250:  MOVF   65,W
0251:  MOVWF  67
0252:  CLRF   68
0253:  MOVF   65,W
0254:  MOVWF  6C
0255:  BCF    03.5
0256:  CALL   0FA
0257:  MOVF   78,W
0258:  MOVWF  37
.................... i2c_stop(); 
0259:  BSF    03.5
025A:  BSF    11.2
025B:  BTFSC  11.2
025C:  GOTO   25B
025D:  BCF    03.5
025E:  RETURN
....................  
.................... } 
....................  
.................... // Write a 32-bit register 
.................... void writeReg32Bit(int8 reg, int32 value) 
.................... { 
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  Wire.write((value >> 24) & 0xFF); // value highest byte 
.................... //!  Wire.write((value >> 16) & 0xFF); 
.................... //!  Wire.write((value >>  8) & 0xFF); 
.................... //!  Wire.write( value        & 0xFF); // value lowest byte 
.................... //!  last_status = Wire.endTransmission(); 
....................  
.................... i2c_start(); 
.................... i2c_write(address); 
.................... i2c_write(reg); 
.................... i2c_write((value >> 24) & 0xFF); 
.................... i2c_write((value >> 16) & 0xFF); 
.................... i2c_write((value >>  8) & 0xFF); 
.................... last_status = i2c_write(value & 0xFF); 
.................... i2c_stop(); 
....................  
.................... } 
....................  
.................... // Read an 8-bit register 
.................... int8 readReg(int8 reg) 
.................... { 
....................   int8 value; 
....................  
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  last_status = Wire.endTransmission(); 
.................... //! 
.................... //!  Wire.requestFrom(address, (int8)1); 
.................... //!  value = Wire.read(); 
.................... //! 
....................  
....................   i2c_start(); 
*
011C:  BSF    03.5
011D:  BSF    11.0
011E:  BTFSC  11.0
011F:  GOTO   11E
....................   i2c_write(address); 
0120:  BCF    03.5
0121:  MOVF   2C,W
0122:  BSF    03.5
0123:  MOVWF  6C
0124:  BCF    03.5
0125:  CALL   0FA
....................   last_status = i2c_write(reg); 
0126:  BSF    03.5
0127:  MOVF   69,W
0128:  MOVWF  6C
0129:  BCF    03.5
012A:  CALL   0FA
012B:  MOVF   78,W
012C:  MOVWF  37
....................    
....................   i2c_start(); 
012D:  BSF    03.5
012E:  BSF    11.1
012F:  BTFSC  11.1
0130:  GOTO   12F
....................   i2c_write(address | 1); 
0131:  BCF    03.5
0132:  MOVF   2C,W
0133:  IORLW  01
0134:  BSF    03.5
0135:  MOVWF  6B
0136:  MOVWF  6C
0137:  BCF    03.5
0138:  CALL   0FA
....................   value = i2c_read(0); 
0139:  CLRF   77
013A:  CALL   10C
013B:  MOVF   78,W
013C:  BSF    03.5
013D:  MOVWF  6A
....................    
....................   return value; 
013E:  MOVF   6A,W
013F:  MOVWF  78
0140:  BCF    03.5
0141:  RETURN
....................  
.................... } 
....................  
.................... // Read a 16-bit register 
.................... int16 readReg16Bit(int8 reg) 
.................... { 
....................   int16 value; 
....................  
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  last_status = Wire.endTransmission(); 
.................... //! 
.................... //!  Wire.requestFrom(address, (int8)2); 
.................... //!  value  = (int16)Wire.read() << 8; // value high byte 
.................... //!  value |=           Wire.read();      // value low byte 
....................  
....................   i2c_start(); 
*
0498:  BSF    03.5
0499:  BSF    11.1
049A:  BTFSC  11.1
049B:  GOTO   49A
....................   i2c_write(address); 
049C:  BCF    03.5
049D:  MOVF   2C,W
049E:  BSF    03.5
049F:  MOVWF  6C
04A0:  BCF    03.5
04A1:  CALL   0FA
....................   last_status = i2c_write(reg); 
04A2:  BSF    03.5
04A3:  MOVF   68,W
04A4:  MOVWF  6C
04A5:  BCF    03.5
04A6:  CALL   0FA
04A7:  MOVF   78,W
04A8:  MOVWF  37
....................    
....................   i2c_start(); 
04A9:  BSF    03.5
04AA:  BSF    11.1
04AB:  BTFSC  11.1
04AC:  GOTO   4AB
....................   i2c_write(address | 1); 
04AD:  BCF    03.5
04AE:  MOVF   2C,W
04AF:  IORLW  01
04B0:  BSF    03.5
04B1:  MOVWF  6B
04B2:  MOVWF  6C
04B3:  BCF    03.5
04B4:  CALL   0FA
....................   value = (int16)i2c_read() << 8; 
04B5:  MOVLW  01
04B6:  MOVWF  77
04B7:  CALL   10C
04B8:  MOVF   78,W
04B9:  BSF    03.5
04BA:  CLRF   6C
04BB:  MOVWF  6B
04BC:  MOVWF  6A
04BD:  CLRF   69
....................   value |= i2c_read(0); 
04BE:  CLRF   77
04BF:  BCF    03.5
04C0:  CALL   10C
04C1:  MOVF   78,W
04C2:  BSF    03.5
04C3:  IORWF  69,F
....................  
....................   return value; 
04C4:  MOVF   69,W
04C5:  MOVWF  78
04C6:  MOVF   6A,W
04C7:  MOVWF  79
04C8:  BCF    03.5
04C9:  RETURN
.................... } 
....................  
.................... // Read a 32-bit register 
.................... int32 readReg32Bit(int8 reg) 
.................... { 
....................   int32 value; 
....................  
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  last_status = Wire.endTransmission(); 
.................... //! 
.................... //!  Wire.requestFrom(address, (int8)4); 
.................... //!  value  = (int32)Wire.read() << 24; // value highest byte 
.................... //!  value |= (int32)Wire.read() << 16; 
.................... //!  value |= (int16)Wire.read() <<  8; 
.................... //!  value |=           Wire.read();       // value lowest byte 
....................  
....................   i2c_start(); 
....................   i2c_write(address); 
....................   last_status = i2c_write(reg); 
....................    
....................   i2c_start(); 
....................   i2c_write(address | 1); 
....................   value =  (int32)i2c_read() << 24; 
....................   value |= (int32)i2c_read() << 16; 
....................   value |= (int32)i2c_read() << 8; 
....................   value |= i2c_read(0); 
....................  
....................  
....................   return value; 
.................... } 
....................  
.................... // Write an arbitrary number of bytes from the given array to the sensor, 
.................... // starting at the given register 
.................... void writeMulti(int8 reg, int8 * src, int8 count) 
.................... { 
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //! 
.................... //!  while (count-- > 0) 
.................... //!  { 
.................... //!    Wire.write(*(src++)); 
.................... //!  } 
.................... //! 
.................... //!  last_status = Wire.endTransmission(); 
....................  
....................    i2c_start(); 
*
127D:  BSF    03.5
127E:  BSF    11.1
127F:  BTFSC  11.1
1280:  GOTO   27F
....................    i2c_write(address); 
1281:  BCF    03.5
1282:  MOVF   2C,W
1283:  BSF    03.5
1284:  MOVWF  6C
1285:  BCF    0A.4
1286:  BCF    03.5
1287:  CALL   0FA
1288:  BSF    0A.4
....................    i2c_write(reg); 
1289:  MOVF   74,W
128A:  BSF    03.5
128B:  MOVWF  6C
128C:  BCF    0A.4
128D:  BCF    03.5
128E:  CALL   0FA
128F:  BSF    0A.4
....................     
....................    while (count-- > 0) { 
1290:  MOVF   7B,W
1291:  DECF   7B,F
1292:  XORLW  00
1293:  BTFSC  03.2
1294:  GOTO   2AA
....................       last_status = i2c_write(*src++); 
1295:  MOVF   76,W
1296:  MOVWF  7A
1297:  MOVF   75,W
1298:  INCF   75,F
1299:  BTFSC  03.2
129A:  INCF   76,F
129B:  MOVWF  04
129C:  BCF    03.7
129D:  BTFSC  7A.0
129E:  BSF    03.7
129F:  MOVF   00,W
12A0:  MOVWF  7C
12A1:  BSF    03.5
12A2:  MOVWF  6C
12A3:  BCF    0A.4
12A4:  BCF    03.5
12A5:  CALL   0FA
12A6:  BSF    0A.4
12A7:  MOVF   78,W
12A8:  MOVWF  37
12A9:  GOTO   290
....................    } 
....................     
....................    i2c_stop(); 
12AA:  BSF    03.5
12AB:  BSF    11.2
12AC:  BTFSC  11.2
12AD:  GOTO   2AC
....................  
.................... } 
....................  
.................... // Read an arbitrary number of bytes from the sensor, starting at the given 
.................... // register, into the given array 
.................... void readMulti(int8 reg, int8 * dst, int8 count) 
.................... { 
.................... //!  Wire.beginTransmission(address); 
.................... //!  Wire.write(reg); 
.................... //!  last_status = Wire.endTransmission(); 
.................... //! 
.................... //!  Wire.requestFrom(address, count); 
.................... //! 
.................... //!  while (count-- > 0) 
.................... //!  { 
.................... //!    *(dst++) = Wire.read(); 
.................... //!  } 
....................  
....................    i2c_start(); 
*
11B1:  BSF    11.0
11B2:  BTFSC  11.0
11B3:  GOTO   1B2
....................    i2c_write(address); 
11B4:  BCF    03.5
11B5:  MOVF   2C,W
11B6:  BSF    03.5
11B7:  MOVWF  6C
11B8:  BCF    0A.4
11B9:  BCF    03.5
11BA:  CALL   0FA
11BB:  BSF    0A.4
....................    last_status = i2c_write(reg); 
11BC:  MOVF   74,W
11BD:  BSF    03.5
11BE:  MOVWF  6C
11BF:  BCF    0A.4
11C0:  BCF    03.5
11C1:  CALL   0FA
11C2:  BSF    0A.4
11C3:  MOVF   78,W
11C4:  MOVWF  37
....................     
....................    i2c_start(); 
11C5:  BSF    03.5
11C6:  BSF    11.1
11C7:  BTFSC  11.1
11C8:  GOTO   1C7
....................    i2c_write(address|1); 
11C9:  BCF    03.5
11CA:  MOVF   2C,W
11CB:  IORLW  01
11CC:  MOVWF  7C
11CD:  BSF    03.5
11CE:  MOVWF  6C
11CF:  BCF    0A.4
11D0:  BCF    03.5
11D1:  CALL   0FA
11D2:  BSF    0A.4
....................    while (count-- > 1) { 
11D3:  MOVF   7B,W
11D4:  DECF   7B,F
11D5:  SUBLW  01
11D6:  BTFSC  03.0
11D7:  GOTO   1EA
....................       *(dst++) = i2c_read(); 
11D8:  MOVF   76,W
11D9:  MOVWF  7A
11DA:  MOVF   75,W
11DB:  INCF   75,F
11DC:  BTFSC  03.2
11DD:  INCF   76,F
11DE:  MOVWF  04
11DF:  BCF    03.7
11E0:  BTFSC  7A.0
11E1:  BSF    03.7
11E2:  MOVLW  01
11E3:  MOVWF  77
11E4:  BCF    0A.4
11E5:  CALL   10C
11E6:  BSF    0A.4
11E7:  MOVF   78,W
11E8:  MOVWF  00
11E9:  GOTO   1D3
....................    } 
....................    *(dst++) = i2c_read(0); 
11EA:  MOVF   76,W
11EB:  MOVWF  7A
11EC:  MOVF   75,W
11ED:  INCF   75,F
11EE:  BTFSC  03.2
11EF:  INCF   76,F
11F0:  MOVWF  04
11F1:  BCF    03.7
11F2:  BTFSC  7A.0
11F3:  BSF    03.7
11F4:  CLRF   77
11F5:  BCF    0A.4
11F6:  CALL   10C
11F7:  BSF    0A.4
11F8:  MOVF   78,W
11F9:  MOVWF  00
....................  
....................    i2c_stop(); 
11FA:  BSF    03.5
11FB:  BSF    11.2
11FC:  BTFSC  11.2
11FD:  GOTO   1FC
....................  
....................  
.................... } 
....................  
.................... // Set the return signal rate limit check value in units of MCPS (mega counts 
.................... // per second). "This represents the amplitude of the signal reflected from the 
.................... // target and detected by the device"; setting this limit presumably determines 
.................... // the minimum measurement necessary for the sensor to report a valid reading. 
.................... // Setting a lower limit increases the potential range of the sensor but also 
.................... // seems to increase the likelihood of getting an inaccurate reading because of 
.................... // unwanted reflections from objects other than the intended target. 
.................... // Defaults to 0.25 MCPS as initialized by the ST API and this library. 
.................... boolean setSignalRateLimit(float limit_Mcps) 
.................... { 
....................   if (limit_Mcps < 0 || limit_Mcps > 511.99) { return false; } 
*
025F:  MOVF   7E,W
0260:  BSF    03.5
0261:  MOVWF  51
0262:  MOVF   7D,W
0263:  MOVWF  50
0264:  MOVF   7C,W
0265:  MOVWF  4F
0266:  MOVF   7B,W
0267:  MOVWF  4E
0268:  CLRF   55
0269:  CLRF   54
026A:  CLRF   53
026B:  CLRF   52
026C:  BCF    03.5
026D:  CALL   15E
026E:  BTFSC  03.0
026F:  GOTO   285
0270:  MOVLW  B8
0271:  BSF    03.5
0272:  MOVWF  51
0273:  MOVLW  FE
0274:  MOVWF  50
0275:  MOVLW  7F
0276:  MOVWF  4F
0277:  MOVLW  87
0278:  MOVWF  4E
0279:  MOVF   7E,W
027A:  MOVWF  55
027B:  MOVF   7D,W
027C:  MOVWF  54
027D:  MOVF   7C,W
027E:  MOVWF  53
027F:  MOVF   7B,W
0280:  MOVWF  52
0281:  BCF    03.5
0282:  CALL   15E
0283:  BTFSS  03.0
0284:  GOTO   288
0285:  MOVLW  00
0286:  MOVWF  78
0287:  GOTO   2B2
....................  
....................   // Q9.7 fixed point format (9 integer bits, 7 fractional bits) 
....................   writeReg16Bit(FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT, limit_Mcps * (1 << 7)); 
0288:  MOVF   7E,W
0289:  BSF    03.5
028A:  MOVWF  55
028B:  MOVF   7D,W
028C:  MOVWF  54
028D:  MOVF   7C,W
028E:  MOVWF  53
028F:  MOVF   7B,W
0290:  MOVWF  52
0291:  CLRF   59
0292:  CLRF   58
0293:  CLRF   57
0294:  MOVLW  86
0295:  MOVWF  56
0296:  BCF    03.5
0297:  CALL   19F
0298:  MOVF   7A,W
0299:  BSF    03.5
029A:  MOVWF  51
029B:  MOVF   79,W
029C:  MOVWF  50
029D:  MOVF   78,W
029E:  MOVWF  4F
029F:  MOVF   77,W
02A0:  MOVWF  4E
02A1:  BCF    03.5
02A2:  CALL   216
02A3:  MOVF   79,W
02A4:  MOVWF  75
02A5:  MOVF   78,W
02A6:  MOVWF  74
02A7:  MOVLW  44
02A8:  BSF    03.5
02A9:  MOVWF  64
02AA:  MOVF   79,W
02AB:  MOVWF  66
02AC:  MOVF   78,W
02AD:  MOVWF  65
02AE:  BCF    03.5
02AF:  CALL   237
....................   return true; 
02B0:  MOVLW  01
02B1:  MOVWF  78
02B2:  RETURN
.................... } 
....................  
.................... // Get the return signal rate limit check value in MCPS 
.................... float getSignalRateLimit(void) 
.................... { 
....................   return (float)readReg16Bit(FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT) / (1 << 7); 
.................... } 
....................  
.................... // Set the measurement timing budget in microseconds, which is the time allowed 
.................... // for one measurement; the ST API and this library take care of splitting the 
.................... // timing budget among the sub-steps in the ranging sequence. A longer timing 
.................... // budget allows for more accurate measurements. Increasing the budget by a 
.................... // factor of N decreases the range measurement standard deviation by a factor of 
.................... // sqrt(N). Defaults to about 33 milliseconds; the minimum is 20 ms. 
.................... // based on VL53L0X_set_measurement_timing_budget_micro_seconds() 
.................... boolean setMeasurementTimingBudget(int32 budget_us) 
.................... { 
....................   SequenceStepEnables enables; 
....................   SequenceStepTimeouts timeouts; 
....................  
....................   int16 const StartOverhead      = 1320; // note that this is different than the value in get_ 
....................   int16 const EndOverhead        = 960; 
....................   int16 const MsrcOverhead       = 660; 
....................   int16 const TccOverhead        = 590; 
....................   int16 const DssOverhead        = 690; 
....................   int16 const PreRangeOverhead   = 660; 
....................   int16 const FinalRangeOverhead = 550; 
....................  
....................   int32 const MinTimingBudget = 20000; 
....................  
....................   if (budget_us < MinTimingBudget) { return false; } 
*
0800:  BSF    03.5
0801:  MOVF   40,F
0802:  BTFSS  03.2
0803:  GOTO   014
0804:  MOVF   3F,F
0805:  BTFSS  03.2
0806:  GOTO   014
0807:  MOVF   3E,W
0808:  SUBLW  4E
0809:  BTFSS  03.0
080A:  GOTO   014
080B:  BTFSS  03.2
080C:  GOTO   011
080D:  MOVF   3D,W
080E:  SUBLW  1F
080F:  BTFSS  03.0
0810:  GOTO   014
0811:  MOVLW  00
0812:  MOVWF  78
0813:  GOTO   14A
....................  
....................   int32 used_budget_us = StartOverhead + EndOverhead; 
0814:  CLRF   5B
0815:  CLRF   5A
0816:  MOVLW  08
0817:  MOVWF  59
0818:  MOVLW  E8
0819:  MOVWF  58
....................  
....................   getSequenceStepEnables(&enables); 
081A:  CLRF   63
081B:  MOVLW  C1
081C:  MOVWF  62
081D:  BCF    0A.3
081E:  BCF    03.5
081F:  CALL   2B3
0820:  BSF    0A.3
....................   getSequenceStepTimeouts(&enables, &timeouts); 
0821:  BSF    03.5
0822:  CLRF   63
0823:  MOVLW  C1
0824:  MOVWF  62
0825:  CLRF   65
0826:  MOVLW  C2
0827:  MOVWF  64
0828:  BCF    0A.3
0829:  BCF    03.5
082A:  CALL   4E6
082B:  BSF    0A.3
....................  
....................   if (enables.tcc) 
082C:  BSF    03.5
082D:  BTFSS  41.0
082E:  GOTO   052
....................   { 
....................     used_budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead); 
082F:  MOVLW  4E
0830:  ADDWF  4C,W
0831:  MOVWF  77
0832:  MOVF   4D,W
0833:  MOVWF  78
0834:  MOVLW  02
0835:  BTFSC  03.0
0836:  MOVLW  03
0837:  ADDWF  78,F
0838:  MOVF   4E,W
0839:  MOVWF  79
083A:  MOVLW  00
083B:  BTFSC  03.0
083C:  MOVLW  01
083D:  ADDWF  79,F
083E:  MOVF   4F,W
083F:  MOVWF  7A
0840:  MOVLW  00
0841:  BTFSC  03.0
0842:  MOVLW  01
0843:  ADDWF  7A,F
0844:  MOVF   77,W
0845:  ADDWF  58,F
0846:  MOVF   78,W
0847:  BTFSC  03.0
0848:  INCFSZ 78,W
0849:  ADDWF  59,F
084A:  MOVF   79,W
084B:  BTFSC  03.0
084C:  INCFSZ 79,W
084D:  ADDWF  5A,F
084E:  MOVF   7A,W
084F:  BTFSC  03.0
0850:  INCFSZ 7A,W
0851:  ADDWF  5B,F
....................   } 
....................  
....................   if (enables.dss) 
0852:  BTFSS  41.2
0853:  GOTO   07D
....................   { 
....................     used_budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead); 
0854:  MOVLW  B2
0855:  ADDWF  4C,W
0856:  MOVWF  77
0857:  MOVF   4D,W
0858:  MOVWF  78
0859:  MOVLW  02
085A:  BTFSC  03.0
085B:  MOVLW  03
085C:  ADDWF  78,F
085D:  MOVF   4E,W
085E:  MOVWF  79
085F:  MOVLW  00
0860:  BTFSC  03.0
0861:  MOVLW  01
0862:  ADDWF  79,F
0863:  MOVF   4F,W
0864:  MOVWF  7A
0865:  MOVLW  00
0866:  BTFSC  03.0
0867:  MOVLW  01
0868:  ADDWF  7A,F
0869:  BCF    03.0
086A:  RLF    77,F
086B:  RLF    78,F
086C:  RLF    79,F
086D:  RLF    7A,F
086E:  MOVF   77,W
086F:  ADDWF  58,F
0870:  MOVF   78,W
0871:  BTFSC  03.0
0872:  INCFSZ 78,W
0873:  ADDWF  59,F
0874:  MOVF   79,W
0875:  BTFSC  03.0
0876:  INCFSZ 79,W
0877:  ADDWF  5A,F
0878:  MOVF   7A,W
0879:  BTFSC  03.0
087A:  INCFSZ 7A,W
087B:  ADDWF  5B,F
....................   } 
087C:  GOTO   0A2
....................   else if (enables.msrc) 
087D:  BTFSS  41.1
087E:  GOTO   0A2
....................   { 
....................     used_budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead); 
087F:  MOVLW  94
0880:  ADDWF  4C,W
0881:  MOVWF  77
0882:  MOVF   4D,W
0883:  MOVWF  78
0884:  MOVLW  02
0885:  BTFSC  03.0
0886:  MOVLW  03
0887:  ADDWF  78,F
0888:  MOVF   4E,W
0889:  MOVWF  79
088A:  MOVLW  00
088B:  BTFSC  03.0
088C:  MOVLW  01
088D:  ADDWF  79,F
088E:  MOVF   4F,W
088F:  MOVWF  7A
0890:  MOVLW  00
0891:  BTFSC  03.0
0892:  MOVLW  01
0893:  ADDWF  7A,F
0894:  MOVF   77,W
0895:  ADDWF  58,F
0896:  MOVF   78,W
0897:  BTFSC  03.0
0898:  INCFSZ 78,W
0899:  ADDWF  59,F
089A:  MOVF   79,W
089B:  BTFSC  03.0
089C:  INCFSZ 79,W
089D:  ADDWF  5A,F
089E:  MOVF   7A,W
089F:  BTFSC  03.0
08A0:  INCFSZ 7A,W
08A1:  ADDWF  5B,F
....................   } 
....................  
....................   if (enables.pre_range) 
08A2:  BTFSS  41.3
08A3:  GOTO   0C7
....................   { 
....................     used_budget_us += (timeouts.pre_range_us + PreRangeOverhead); 
08A4:  MOVLW  94
08A5:  ADDWF  50,W
08A6:  MOVWF  77
08A7:  MOVF   51,W
08A8:  MOVWF  78
08A9:  MOVLW  02
08AA:  BTFSC  03.0
08AB:  MOVLW  03
08AC:  ADDWF  78,F
08AD:  MOVF   52,W
08AE:  MOVWF  79
08AF:  MOVLW  00
08B0:  BTFSC  03.0
08B1:  MOVLW  01
08B2:  ADDWF  79,F
08B3:  MOVF   53,W
08B4:  MOVWF  7A
08B5:  MOVLW  00
08B6:  BTFSC  03.0
08B7:  MOVLW  01
08B8:  ADDWF  7A,F
08B9:  MOVF   77,W
08BA:  ADDWF  58,F
08BB:  MOVF   78,W
08BC:  BTFSC  03.0
08BD:  INCFSZ 78,W
08BE:  ADDWF  59,F
08BF:  MOVF   79,W
08C0:  BTFSC  03.0
08C1:  INCFSZ 79,W
08C2:  ADDWF  5A,F
08C3:  MOVF   7A,W
08C4:  BTFSC  03.0
08C5:  INCFSZ 7A,W
08C6:  ADDWF  5B,F
....................   } 
....................  
....................   if (enables.final_range) 
08C7:  BTFSS  41.4
08C8:  GOTO   148
....................   { 
....................     used_budget_us += FinalRangeOverhead; 
08C9:  MOVLW  26
08CA:  ADDWF  58,F
08CB:  MOVLW  02
08CC:  BTFSC  03.0
08CD:  MOVLW  03
08CE:  ADDWF  59,F
08CF:  MOVLW  00
08D0:  BTFSC  03.0
08D1:  MOVLW  01
08D2:  ADDWF  5A,F
08D3:  MOVLW  00
08D4:  BTFSC  03.0
08D5:  MOVLW  01
08D6:  ADDWF  5B,F
....................  
....................     // "Note that the final range timeout is determined by the timing 
....................     // budget and the sum of all other timeouts within the sequence. 
....................     // If there is no room for the final range timeout, then an error 
....................     // will be set. Otherwise the remaining time will be applied to 
....................     // the final range." 
....................  
....................     if (used_budget_us > budget_us) 
08D7:  MOVF   40,W
08D8:  SUBWF  5B,W
08D9:  BTFSS  03.0
08DA:  GOTO   0F0
08DB:  BTFSS  03.2
08DC:  GOTO   0ED
08DD:  MOVF   3F,W
08DE:  SUBWF  5A,W
08DF:  BTFSS  03.0
08E0:  GOTO   0F0
08E1:  BTFSS  03.2
08E2:  GOTO   0ED
08E3:  MOVF   3E,W
08E4:  SUBWF  59,W
08E5:  BTFSS  03.0
08E6:  GOTO   0F0
08E7:  BTFSS  03.2
08E8:  GOTO   0ED
08E9:  MOVF   58,W
08EA:  SUBWF  3D,W
08EB:  BTFSC  03.0
08EC:  GOTO   0F0
....................     { 
....................       // "Requested timeout too big." 
....................       return false; 
08ED:  MOVLW  00
08EE:  MOVWF  78
08EF:  GOTO   14A
....................     } 
....................  
....................     int32 final_range_timeout_us = budget_us - used_budget_us; 
....................  
....................     // set_sequence_step_timeout() begin 
....................     // (SequenceStepId == VL53L0X_SEQUENCESTEP_FINAL_RANGE) 
....................  
....................     // "For the final range timeout, the pre-range timeout 
....................     //  must be added. To do this both final and pre-range 
....................     //  timeouts must be expressed in macro periods MClks 
....................     //  because they have different vcsel periods." 
....................  
....................     int16 final_range_timeout_mclks = 
....................       timeoutMicrosecondsToMclks(final_range_timeout_us, 
....................                                  timeouts.final_range_vcsel_period_pclks); 
08F0:  MOVF   58,W
08F1:  SUBWF  3D,W
08F2:  MOVWF  5C
08F3:  MOVF   3E,W
08F4:  MOVWF  5D
08F5:  MOVF   59,W
08F6:  BTFSS  03.0
08F7:  INCFSZ 59,W
08F8:  SUBWF  5D,F
08F9:  MOVF   3F,W
08FA:  MOVWF  5E
08FB:  MOVF   5A,W
08FC:  BTFSS  03.0
08FD:  INCFSZ 5A,W
08FE:  SUBWF  5E,F
08FF:  MOVF   40,W
0900:  MOVWF  5F
0901:  MOVF   5B,W
0902:  BTFSS  03.0
0903:  INCFSZ 5B,W
0904:  SUBWF  5F,F
0905:  MOVF   5F,W
0906:  MOVWF  65
0907:  MOVF   5E,W
0908:  MOVWF  64
0909:  MOVF   5D,W
090A:  MOVWF  63
090B:  MOVF   5C,W
090C:  MOVWF  62
090D:  MOVF   44,W
090E:  MOVWF  66
090F:  BCF    0A.3
0910:  BCF    03.5
0911:  CALL   675
0912:  BSF    0A.3
0913:  MOVF   78,W
0914:  BSF    03.5
0915:  MOVWF  61
0916:  MOVF   77,W
0917:  MOVWF  60
....................  
....................     if (enables.pre_range) 
0918:  BTFSS  41.3
0919:  GOTO   120
....................     { 
....................       final_range_timeout_mclks += timeouts.pre_range_mclks; 
091A:  MOVF   48,W
091B:  ADDWF  60,F
091C:  MOVF   49,W
091D:  BTFSC  03.0
091E:  INCFSZ 49,W
091F:  ADDWF  61,F
....................     } 
....................  
....................     writeReg16Bit(FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI, 
....................       encodeTimeout(final_range_timeout_mclks)); 
0920:  MOVF   61,W
0921:  MOVWF  63
0922:  MOVF   60,W
0923:  MOVWF  62
0924:  BCF    0A.3
0925:  BCF    03.5
0926:  CALL   75B
0927:  BSF    0A.3
0928:  MOVF   79,W
0929:  BSF    03.5
092A:  MOVWF  63
092B:  MOVF   78,W
092C:  MOVWF  62
092D:  MOVLW  71
092E:  MOVWF  64
092F:  MOVF   63,W
0930:  MOVWF  66
0931:  MOVF   62,W
0932:  MOVWF  65
0933:  BCF    0A.3
0934:  BCF    03.5
0935:  CALL   237
0936:  BSF    0A.3
....................  
....................     // set_sequence_step_timeout() end 
....................  
....................     measurement_timing_budget_us = budget_us; // store for internal reuse 
0937:  BSF    03.5
0938:  MOVF   40,W
0939:  BCF    03.5
093A:  MOVWF  36
093B:  BSF    03.5
093C:  MOVF   3F,W
093D:  BCF    03.5
093E:  MOVWF  35
093F:  BSF    03.5
0940:  MOVF   3E,W
0941:  BCF    03.5
0942:  MOVWF  34
0943:  BSF    03.5
0944:  MOVF   3D,W
0945:  BCF    03.5
0946:  MOVWF  33
0947:  BSF    03.5
....................   } 
....................   return true; 
0948:  MOVLW  01
0949:  MOVWF  78
094A:  BCF    03.5
094B:  RETURN
.................... } 
....................  
.................... // Get the measurement timing budget in microseconds 
.................... // based on VL53L0X_get_measurement_timing_budget_micro_seconds() 
.................... // in us 
.................... int32 getMeasurementTimingBudget(void) 
*
09CB:  CLRF   7E
09CC:  CLRF   7D
09CD:  MOVLW  0B
09CE:  MOVWF  7C
09CF:  MOVLW  36
09D0:  MOVWF  7B
.................... { 
....................   SequenceStepEnables enables; 
....................   SequenceStepTimeouts timeouts; 
....................  
....................   int16 const StartOverhead     = 1910; // note that this is different than the value in set_ 
....................   int16 const EndOverhead        = 960; 
....................   int16 const MsrcOverhead       = 660; 
....................   int16 const TccOverhead        = 590; 
....................   int16 const DssOverhead        = 690; 
....................   int16 const PreRangeOverhead   = 660; 
....................   int16 const FinalRangeOverhead = 550; 
....................  
....................   // "Start and end overhead times always present" 
....................   int32 budget_us = StartOverhead + EndOverhead; 
....................  
....................   getSequenceStepEnables(&enables); 
09D1:  BSF    03.5
09D2:  CLRF   63
09D3:  MOVLW  74
09D4:  MOVWF  62
09D5:  BCF    0A.3
09D6:  BCF    03.5
09D7:  CALL   2B3
09D8:  BSF    0A.3
....................   getSequenceStepTimeouts(&enables, &timeouts); 
09D9:  BSF    03.5
09DA:  CLRF   63
09DB:  MOVLW  74
09DC:  MOVWF  62
09DD:  CLRF   65
09DE:  MOVLW  A0
09DF:  MOVWF  64
09E0:  BCF    0A.3
09E1:  BCF    03.5
09E2:  CALL   4E6
09E3:  BSF    0A.3
....................  
....................   if (enables.tcc) 
09E4:  BTFSS  74.0
09E5:  GOTO   20B
....................   { 
....................     budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead); 
09E6:  MOVLW  4E
09E7:  BSF    03.5
09E8:  ADDWF  2A,W
09E9:  MOVWF  77
09EA:  MOVF   2B,W
09EB:  MOVWF  78
09EC:  MOVLW  02
09ED:  BTFSC  03.0
09EE:  MOVLW  03
09EF:  ADDWF  78,F
09F0:  MOVF   2C,W
09F1:  MOVWF  79
09F2:  MOVLW  00
09F3:  BTFSC  03.0
09F4:  MOVLW  01
09F5:  ADDWF  79,F
09F6:  MOVF   2D,W
09F7:  MOVWF  7A
09F8:  MOVLW  00
09F9:  BTFSC  03.0
09FA:  MOVLW  01
09FB:  ADDWF  7A,F
09FC:  MOVF   77,W
09FD:  ADDWF  7B,F
09FE:  MOVF   78,W
09FF:  BTFSC  03.0
0A00:  INCFSZ 78,W
0A01:  ADDWF  7C,F
0A02:  MOVF   79,W
0A03:  BTFSC  03.0
0A04:  INCFSZ 79,W
0A05:  ADDWF  7D,F
0A06:  MOVF   7A,W
0A07:  BTFSC  03.0
0A08:  INCFSZ 7A,W
0A09:  ADDWF  7E,F
0A0A:  BCF    03.5
....................   } 
....................  
....................   if (enables.dss) 
0A0B:  BTFSS  74.2
0A0C:  GOTO   238
....................   { 
....................     budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead); 
0A0D:  MOVLW  B2
0A0E:  BSF    03.5
0A0F:  ADDWF  2A,W
0A10:  MOVWF  77
0A11:  MOVF   2B,W
0A12:  MOVWF  78
0A13:  MOVLW  02
0A14:  BTFSC  03.0
0A15:  MOVLW  03
0A16:  ADDWF  78,F
0A17:  MOVF   2C,W
0A18:  MOVWF  79
0A19:  MOVLW  00
0A1A:  BTFSC  03.0
0A1B:  MOVLW  01
0A1C:  ADDWF  79,F
0A1D:  MOVF   2D,W
0A1E:  MOVWF  7A
0A1F:  MOVLW  00
0A20:  BTFSC  03.0
0A21:  MOVLW  01
0A22:  ADDWF  7A,F
0A23:  BCF    03.0
0A24:  RLF    77,F
0A25:  RLF    78,F
0A26:  RLF    79,F
0A27:  RLF    7A,F
0A28:  MOVF   77,W
0A29:  ADDWF  7B,F
0A2A:  MOVF   78,W
0A2B:  BTFSC  03.0
0A2C:  INCFSZ 78,W
0A2D:  ADDWF  7C,F
0A2E:  MOVF   79,W
0A2F:  BTFSC  03.0
0A30:  INCFSZ 79,W
0A31:  ADDWF  7D,F
0A32:  MOVF   7A,W
0A33:  BTFSC  03.0
0A34:  INCFSZ 7A,W
0A35:  ADDWF  7E,F
....................   } 
0A36:  GOTO   25E
0A37:  BCF    03.5
....................   else if (enables.msrc) 
0A38:  BTFSS  74.1
0A39:  GOTO   25F
....................   { 
....................     budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead); 
0A3A:  MOVLW  94
0A3B:  BSF    03.5
0A3C:  ADDWF  2A,W
0A3D:  MOVWF  77
0A3E:  MOVF   2B,W
0A3F:  MOVWF  78
0A40:  MOVLW  02
0A41:  BTFSC  03.0
0A42:  MOVLW  03
0A43:  ADDWF  78,F
0A44:  MOVF   2C,W
0A45:  MOVWF  79
0A46:  MOVLW  00
0A47:  BTFSC  03.0
0A48:  MOVLW  01
0A49:  ADDWF  79,F
0A4A:  MOVF   2D,W
0A4B:  MOVWF  7A
0A4C:  MOVLW  00
0A4D:  BTFSC  03.0
0A4E:  MOVLW  01
0A4F:  ADDWF  7A,F
0A50:  MOVF   77,W
0A51:  ADDWF  7B,F
0A52:  MOVF   78,W
0A53:  BTFSC  03.0
0A54:  INCFSZ 78,W
0A55:  ADDWF  7C,F
0A56:  MOVF   79,W
0A57:  BTFSC  03.0
0A58:  INCFSZ 79,W
0A59:  ADDWF  7D,F
0A5A:  MOVF   7A,W
0A5B:  BTFSC  03.0
0A5C:  INCFSZ 7A,W
0A5D:  ADDWF  7E,F
0A5E:  BCF    03.5
....................   } 
....................  
....................   if (enables.pre_range) 
0A5F:  BTFSS  74.3
0A60:  GOTO   286
....................   { 
....................     budget_us += (timeouts.pre_range_us + PreRangeOverhead); 
0A61:  MOVLW  94
0A62:  BSF    03.5
0A63:  ADDWF  2E,W
0A64:  MOVWF  77
0A65:  MOVF   2F,W
0A66:  MOVWF  78
0A67:  MOVLW  02
0A68:  BTFSC  03.0
0A69:  MOVLW  03
0A6A:  ADDWF  78,F
0A6B:  MOVF   30,W
0A6C:  MOVWF  79
0A6D:  MOVLW  00
0A6E:  BTFSC  03.0
0A6F:  MOVLW  01
0A70:  ADDWF  79,F
0A71:  MOVF   31,W
0A72:  MOVWF  7A
0A73:  MOVLW  00
0A74:  BTFSC  03.0
0A75:  MOVLW  01
0A76:  ADDWF  7A,F
0A77:  MOVF   77,W
0A78:  ADDWF  7B,F
0A79:  MOVF   78,W
0A7A:  BTFSC  03.0
0A7B:  INCFSZ 78,W
0A7C:  ADDWF  7C,F
0A7D:  MOVF   79,W
0A7E:  BTFSC  03.0
0A7F:  INCFSZ 79,W
0A80:  ADDWF  7D,F
0A81:  MOVF   7A,W
0A82:  BTFSC  03.0
0A83:  INCFSZ 7A,W
0A84:  ADDWF  7E,F
0A85:  BCF    03.5
....................   } 
....................  
....................   if (enables.final_range) 
0A86:  BTFSS  74.4
0A87:  GOTO   2AD
....................   { 
....................     budget_us += (timeouts.final_range_us + FinalRangeOverhead); 
0A88:  MOVLW  26
0A89:  BSF    03.5
0A8A:  ADDWF  32,W
0A8B:  MOVWF  77
0A8C:  MOVF   33,W
0A8D:  MOVWF  78
0A8E:  MOVLW  02
0A8F:  BTFSC  03.0
0A90:  MOVLW  03
0A91:  ADDWF  78,F
0A92:  MOVF   34,W
0A93:  MOVWF  79
0A94:  MOVLW  00
0A95:  BTFSC  03.0
0A96:  MOVLW  01
0A97:  ADDWF  79,F
0A98:  MOVF   35,W
0A99:  MOVWF  7A
0A9A:  MOVLW  00
0A9B:  BTFSC  03.0
0A9C:  MOVLW  01
0A9D:  ADDWF  7A,F
0A9E:  MOVF   77,W
0A9F:  ADDWF  7B,F
0AA0:  MOVF   78,W
0AA1:  BTFSC  03.0
0AA2:  INCFSZ 78,W
0AA3:  ADDWF  7C,F
0AA4:  MOVF   79,W
0AA5:  BTFSC  03.0
0AA6:  INCFSZ 79,W
0AA7:  ADDWF  7D,F
0AA8:  MOVF   7A,W
0AA9:  BTFSC  03.0
0AAA:  INCFSZ 7A,W
0AAB:  ADDWF  7E,F
0AAC:  BCF    03.5
....................   } 
....................  
....................   measurement_timing_budget_us = budget_us; // store for internal reuse 
0AAD:  MOVF   7E,W
0AAE:  MOVWF  36
0AAF:  MOVF   7D,W
0AB0:  MOVWF  35
0AB1:  MOVF   7C,W
0AB2:  MOVWF  34
0AB3:  MOVF   7B,W
0AB4:  MOVWF  33
....................   return budget_us; 
0AB5:  MOVF   7B,W
0AB6:  MOVWF  77
0AB7:  MOVF   7C,W
0AB8:  MOVWF  78
0AB9:  MOVF   7D,W
0ABA:  MOVWF  79
0ABB:  MOVF   7E,W
0ABC:  MOVWF  7A
.................... } 
....................  
.................... // Set the VCSEL (vertical cavity surface emitting laser) pulse period for the 
.................... // given period type (pre-range or final range) to the given value in PCLKs. 
.................... // Longer periods seem to increase the potential range of the sensor. 
.................... // Valid values are (even numbers only): 
.................... //  pre:  12 to 18 (initialized default: 14) 
.................... //  final: 8 to 14 (initialized default: 10) 
.................... // based on VL53L0X_set_vcsel_pulse_period() 
.................... boolean setVcselPulsePeriod(vcselPeriodType type, int8 period_pclks) 
*
0B13:  BCF    03.0
0B14:  RRF    69,W
0B15:  ADDLW  FF
0B16:  MOVWF  6A
.................... { 
....................   int8 vcsel_period_reg = encodeVcselPeriod(period_pclks); 
....................  
....................   SequenceStepEnables enables; 
....................   SequenceStepTimeouts timeouts; 
....................  
....................   getSequenceStepEnables(&enables); 
0B17:  BSF    03.5
0B18:  CLRF   63
0B19:  MOVLW  6B
0B1A:  MOVWF  62
0B1B:  BCF    0A.3
0B1C:  BCF    03.5
0B1D:  CALL   2B3
0B1E:  BSF    0A.3
....................   getSequenceStepTimeouts(&enables, &timeouts); 
0B1F:  BSF    03.5
0B20:  CLRF   63
0B21:  MOVLW  6B
0B22:  MOVWF  62
0B23:  CLRF   65
0B24:  MOVLW  A0
0B25:  MOVWF  64
0B26:  BCF    0A.3
0B27:  BCF    03.5
0B28:  CALL   4E6
0B29:  BSF    0A.3
....................  
....................   // "Apply specific settings for the requested clock period" 
....................   // "Re-calculate and apply timeouts, in macro periods" 
....................  
....................   // "When the VCSEL period for the pre or final range is changed, 
....................   // the corresponding timeout must be read from the device using 
....................   // the current VCSEL period, then the new VCSEL period can be 
....................   // applied. The timeout then must be written back to the device 
....................   // using the new VCSEL period. 
....................   // 
....................   // For the MSRC timeout, the same applies - this timeout being 
....................   // dependant on the pre-range vcsel period." 
....................  
....................  
....................   if (type == VcselPeriodPreRange) 
0B2A:  MOVF   68,F
0B2B:  BTFSS  03.2
0B2C:  GOTO   3E0
....................   { 
....................     // "Set phase check limits" 
....................     switch (period_pclks) 
0B2D:  MOVF   69,W
0B2E:  XORLW  0C
0B2F:  BTFSC  03.2
0B30:  GOTO   33B
0B31:  XORLW  02
0B32:  BTFSC  03.2
0B33:  GOTO   345
0B34:  XORLW  1E
0B35:  BTFSC  03.2
0B36:  GOTO   34F
0B37:  XORLW  02
0B38:  BTFSC  03.2
0B39:  GOTO   359
0B3A:  GOTO   363
....................     { 
....................       case 12: 
....................         writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x18); 
0B3B:  MOVLW  57
0B3C:  BSF    03.5
0B3D:  MOVWF  3F
0B3E:  MOVLW  18
0B3F:  MOVWF  40
0B40:  BCF    0A.3
0B41:  BCF    03.5
0B42:  CALL   142
0B43:  BSF    0A.3
....................         break; 
0B44:  GOTO   366
....................  
....................       case 14: 
....................         writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x30); 
0B45:  MOVLW  57
0B46:  BSF    03.5
0B47:  MOVWF  3F
0B48:  MOVLW  30
0B49:  MOVWF  40
0B4A:  BCF    0A.3
0B4B:  BCF    03.5
0B4C:  CALL   142
0B4D:  BSF    0A.3
....................         break; 
0B4E:  GOTO   366
....................  
....................       case 16: 
....................         writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x40); 
0B4F:  MOVLW  57
0B50:  BSF    03.5
0B51:  MOVWF  3F
0B52:  MOVLW  40
0B53:  MOVWF  40
0B54:  BCF    0A.3
0B55:  BCF    03.5
0B56:  CALL   142
0B57:  BSF    0A.3
....................         break; 
0B58:  GOTO   366
....................  
....................       case 18: 
....................         writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x50); 
0B59:  MOVLW  57
0B5A:  BSF    03.5
0B5B:  MOVWF  3F
0B5C:  MOVLW  50
0B5D:  MOVWF  40
0B5E:  BCF    0A.3
0B5F:  BCF    03.5
0B60:  CALL   142
0B61:  BSF    0A.3
....................         break; 
0B62:  GOTO   366
....................  
....................       default: 
....................         // invalid period 
....................         return false; 
0B63:  MOVLW  00
0B64:  MOVWF  78
0B65:  GOTO   565
....................     } 
....................     writeReg(PRE_RANGE_CONFIG_VALID_PHASE_LOW, 0x08); 
0B66:  MOVLW  56
0B67:  BSF    03.5
0B68:  MOVWF  3F
0B69:  MOVLW  08
0B6A:  MOVWF  40
0B6B:  BCF    0A.3
0B6C:  BCF    03.5
0B6D:  CALL   142
0B6E:  BSF    0A.3
....................  
....................     // apply new VCSEL period 
....................     writeReg(PRE_RANGE_CONFIG_VCSEL_PERIOD, vcsel_period_reg); 
0B6F:  MOVLW  50
0B70:  BSF    03.5
0B71:  MOVWF  3F
0B72:  BCF    03.5
0B73:  MOVF   6A,W
0B74:  BSF    03.5
0B75:  MOVWF  40
0B76:  BCF    0A.3
0B77:  BCF    03.5
0B78:  CALL   142
0B79:  BSF    0A.3
....................  
....................     // update timeouts 
....................  
....................     // set_sequence_step_timeout() begin 
....................     // (SequenceStepId == VL53L0X_SEQUENCESTEP_PRE_RANGE) 
....................  
....................     int16 new_pre_range_timeout_mclks = 
....................       timeoutMicrosecondsToMclks(timeouts.pre_range_us, period_pclks); 
0B7A:  BSF    03.5
0B7B:  MOVF   31,W
0B7C:  MOVWF  65
0B7D:  MOVF   30,W
0B7E:  MOVWF  64
0B7F:  MOVF   2F,W
0B80:  MOVWF  63
0B81:  MOVF   2E,W
0B82:  MOVWF  62
0B83:  BCF    03.5
0B84:  MOVF   69,W
0B85:  BSF    03.5
0B86:  MOVWF  66
0B87:  BCF    0A.3
0B88:  BCF    03.5
0B89:  CALL   675
0B8A:  BSF    0A.3
0B8B:  MOVF   78,W
0B8C:  MOVWF  6D
0B8D:  MOVF   77,W
0B8E:  MOVWF  6C
....................  
....................     writeReg16Bit(PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI, 
....................       encodeTimeout(new_pre_range_timeout_mclks)); 
0B8F:  MOVF   6D,W
0B90:  BSF    03.5
0B91:  MOVWF  63
0B92:  BCF    03.5
0B93:  MOVF   6C,W
0B94:  BSF    03.5
0B95:  MOVWF  62
0B96:  BCF    0A.3
0B97:  BCF    03.5
0B98:  CALL   75B
0B99:  BSF    0A.3
0B9A:  MOVF   79,W
0B9B:  MOVWF  74
0B9C:  MOVF   78,W
0B9D:  MOVWF  73
0B9E:  MOVLW  51
0B9F:  BSF    03.5
0BA0:  MOVWF  64
0BA1:  MOVF   79,W
0BA2:  MOVWF  66
0BA3:  MOVF   78,W
0BA4:  MOVWF  65
0BA5:  BCF    0A.3
0BA6:  BCF    03.5
0BA7:  CALL   237
0BA8:  BSF    0A.3
....................  
....................     // set_sequence_step_timeout() end 
....................  
....................     // set_sequence_step_timeout() begin 
....................     // (SequenceStepId == VL53L0X_SEQUENCESTEP_MSRC) 
....................  
....................     int16 new_msrc_timeout_mclks = 
....................       timeoutMicrosecondsToMclks(timeouts.msrc_dss_tcc_us, period_pclks); 
0BA9:  BSF    03.5
0BAA:  MOVF   2D,W
0BAB:  MOVWF  65
0BAC:  MOVF   2C,W
0BAD:  MOVWF  64
0BAE:  MOVF   2B,W
0BAF:  MOVWF  63
0BB0:  MOVF   2A,W
0BB1:  MOVWF  62
0BB2:  BCF    03.5
0BB3:  MOVF   69,W
0BB4:  BSF    03.5
0BB5:  MOVWF  66
0BB6:  BCF    0A.3
0BB7:  BCF    03.5
0BB8:  CALL   675
0BB9:  BSF    0A.3
0BBA:  MOVF   78,W
0BBB:  MOVWF  6F
0BBC:  MOVF   77,W
0BBD:  MOVWF  6E
....................  
....................     writeReg(MSRC_CONFIG_TIMEOUT_MACROP, 
....................       (new_msrc_timeout_mclks > 256) ? 255 : (new_msrc_timeout_mclks - 1)); 
0BBE:  MOVF   6F,W
0BBF:  SUBLW  00
0BC0:  BTFSC  03.0
0BC1:  GOTO   3CB
0BC2:  XORLW  FF
0BC3:  BTFSS  03.2
0BC4:  GOTO   3C9
0BC5:  MOVF   6E,W
0BC6:  SUBLW  00
0BC7:  BTFSC  03.0
0BC8:  GOTO   3CB
0BC9:  MOVLW  FF
0BCA:  GOTO   3D5
0BCB:  MOVLW  01
0BCC:  SUBWF  6E,W
0BCD:  MOVWF  77
0BCE:  MOVF   6F,W
0BCF:  MOVWF  7A
0BD0:  MOVLW  00
0BD1:  BTFSS  03.0
0BD2:  MOVLW  01
0BD3:  SUBWF  7A,F
0BD4:  MOVF   77,W
0BD5:  MOVWF  73
0BD6:  MOVLW  46
0BD7:  BSF    03.5
0BD8:  MOVWF  3F
0BD9:  MOVF   73,W
0BDA:  MOVWF  40
0BDB:  BCF    0A.3
0BDC:  BCF    03.5
0BDD:  CALL   142
0BDE:  BSF    0A.3
....................  
....................     // set_sequence_step_timeout() end 
....................   } 
0BDF:  GOTO   533
....................   else if (type == VcselPeriodFinalRange) 
0BE0:  DECFSZ 68,W
0BE1:  GOTO   530
....................   { 
....................     switch (period_pclks) 
0BE2:  MOVF   69,W
0BE3:  XORLW  08
0BE4:  BTFSC  03.2
0BE5:  GOTO   3F0
0BE6:  XORLW  02
0BE7:  BTFSC  03.2
0BE8:  GOTO   42E
0BE9:  XORLW  06
0BEA:  BTFSC  03.2
0BEB:  GOTO   46D
0BEC:  XORLW  02
0BED:  BTFSC  03.2
0BEE:  GOTO   4AC
0BEF:  GOTO   4EA
....................     { 
....................       case 8: 
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x10); 
0BF0:  MOVLW  48
0BF1:  BSF    03.5
0BF2:  MOVWF  3F
0BF3:  MOVLW  10
0BF4:  MOVWF  40
0BF5:  BCF    0A.3
0BF6:  BCF    03.5
0BF7:  CALL   142
0BF8:  BSF    0A.3
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08); 
0BF9:  MOVLW  47
0BFA:  BSF    03.5
0BFB:  MOVWF  3F
0BFC:  MOVLW  08
0BFD:  MOVWF  40
0BFE:  BCF    0A.3
0BFF:  BCF    03.5
0C00:  CALL   142
0C01:  BSF    0A.3
....................         writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x02); 
0C02:  MOVLW  32
0C03:  BSF    03.5
0C04:  MOVWF  3F
0C05:  MOVLW  02
0C06:  MOVWF  40
0C07:  BCF    0A.3
0C08:  BCF    03.5
0C09:  CALL   142
0C0A:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x0C); 
0C0B:  MOVLW  30
0C0C:  BSF    03.5
0C0D:  MOVWF  3F
0C0E:  MOVLW  0C
0C0F:  MOVWF  40
0C10:  BCF    0A.3
0C11:  BCF    03.5
0C12:  CALL   142
0C13:  BSF    0A.3
....................         writeReg(0xFF, 0x01); 
0C14:  MOVLW  FF
0C15:  BSF    03.5
0C16:  MOVWF  3F
0C17:  MOVLW  01
0C18:  MOVWF  40
0C19:  BCF    0A.3
0C1A:  BCF    03.5
0C1B:  CALL   142
0C1C:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_LIM, 0x30); 
0C1D:  MOVLW  30
0C1E:  BSF    03.5
0C1F:  MOVWF  3F
0C20:  MOVWF  40
0C21:  BCF    0A.3
0C22:  BCF    03.5
0C23:  CALL   142
0C24:  BSF    0A.3
....................         writeReg(0xFF, 0x00); 
0C25:  MOVLW  FF
0C26:  BSF    03.5
0C27:  MOVWF  3F
0C28:  CLRF   40
0C29:  BCF    0A.3
0C2A:  BCF    03.5
0C2B:  CALL   142
0C2C:  BSF    0A.3
....................         break; 
0C2D:  GOTO   4ED
....................  
....................       case 10: 
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x28); 
0C2E:  MOVLW  48
0C2F:  BSF    03.5
0C30:  MOVWF  3F
0C31:  MOVLW  28
0C32:  MOVWF  40
0C33:  BCF    0A.3
0C34:  BCF    03.5
0C35:  CALL   142
0C36:  BSF    0A.3
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08); 
0C37:  MOVLW  47
0C38:  BSF    03.5
0C39:  MOVWF  3F
0C3A:  MOVLW  08
0C3B:  MOVWF  40
0C3C:  BCF    0A.3
0C3D:  BCF    03.5
0C3E:  CALL   142
0C3F:  BSF    0A.3
....................         writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03); 
0C40:  MOVLW  32
0C41:  BSF    03.5
0C42:  MOVWF  3F
0C43:  MOVLW  03
0C44:  MOVWF  40
0C45:  BCF    0A.3
0C46:  BCF    03.5
0C47:  CALL   142
0C48:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x09); 
0C49:  MOVLW  30
0C4A:  BSF    03.5
0C4B:  MOVWF  3F
0C4C:  MOVLW  09
0C4D:  MOVWF  40
0C4E:  BCF    0A.3
0C4F:  BCF    03.5
0C50:  CALL   142
0C51:  BSF    0A.3
....................         writeReg(0xFF, 0x01); 
0C52:  MOVLW  FF
0C53:  BSF    03.5
0C54:  MOVWF  3F
0C55:  MOVLW  01
0C56:  MOVWF  40
0C57:  BCF    0A.3
0C58:  BCF    03.5
0C59:  CALL   142
0C5A:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_LIM, 0x20); 
0C5B:  MOVLW  30
0C5C:  BSF    03.5
0C5D:  MOVWF  3F
0C5E:  MOVLW  20
0C5F:  MOVWF  40
0C60:  BCF    0A.3
0C61:  BCF    03.5
0C62:  CALL   142
0C63:  BSF    0A.3
....................         writeReg(0xFF, 0x00); 
0C64:  MOVLW  FF
0C65:  BSF    03.5
0C66:  MOVWF  3F
0C67:  CLRF   40
0C68:  BCF    0A.3
0C69:  BCF    03.5
0C6A:  CALL   142
0C6B:  BSF    0A.3
....................         break; 
0C6C:  GOTO   4ED
....................  
....................       case 12: 
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x38); 
0C6D:  MOVLW  48
0C6E:  BSF    03.5
0C6F:  MOVWF  3F
0C70:  MOVLW  38
0C71:  MOVWF  40
0C72:  BCF    0A.3
0C73:  BCF    03.5
0C74:  CALL   142
0C75:  BSF    0A.3
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08); 
0C76:  MOVLW  47
0C77:  BSF    03.5
0C78:  MOVWF  3F
0C79:  MOVLW  08
0C7A:  MOVWF  40
0C7B:  BCF    0A.3
0C7C:  BCF    03.5
0C7D:  CALL   142
0C7E:  BSF    0A.3
....................         writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03); 
0C7F:  MOVLW  32
0C80:  BSF    03.5
0C81:  MOVWF  3F
0C82:  MOVLW  03
0C83:  MOVWF  40
0C84:  BCF    0A.3
0C85:  BCF    03.5
0C86:  CALL   142
0C87:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x08); 
0C88:  MOVLW  30
0C89:  BSF    03.5
0C8A:  MOVWF  3F
0C8B:  MOVLW  08
0C8C:  MOVWF  40
0C8D:  BCF    0A.3
0C8E:  BCF    03.5
0C8F:  CALL   142
0C90:  BSF    0A.3
....................         writeReg(0xFF, 0x01); 
0C91:  MOVLW  FF
0C92:  BSF    03.5
0C93:  MOVWF  3F
0C94:  MOVLW  01
0C95:  MOVWF  40
0C96:  BCF    0A.3
0C97:  BCF    03.5
0C98:  CALL   142
0C99:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_LIM, 0x20); 
0C9A:  MOVLW  30
0C9B:  BSF    03.5
0C9C:  MOVWF  3F
0C9D:  MOVLW  20
0C9E:  MOVWF  40
0C9F:  BCF    0A.3
0CA0:  BCF    03.5
0CA1:  CALL   142
0CA2:  BSF    0A.3
....................         writeReg(0xFF, 0x00); 
0CA3:  MOVLW  FF
0CA4:  BSF    03.5
0CA5:  MOVWF  3F
0CA6:  CLRF   40
0CA7:  BCF    0A.3
0CA8:  BCF    03.5
0CA9:  CALL   142
0CAA:  BSF    0A.3
....................         break; 
0CAB:  GOTO   4ED
....................  
....................       case 14: 
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x48); 
0CAC:  MOVLW  48
0CAD:  BSF    03.5
0CAE:  MOVWF  3F
0CAF:  MOVWF  40
0CB0:  BCF    0A.3
0CB1:  BCF    03.5
0CB2:  CALL   142
0CB3:  BSF    0A.3
....................         writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08); 
0CB4:  MOVLW  47
0CB5:  BSF    03.5
0CB6:  MOVWF  3F
0CB7:  MOVLW  08
0CB8:  MOVWF  40
0CB9:  BCF    0A.3
0CBA:  BCF    03.5
0CBB:  CALL   142
0CBC:  BSF    0A.3
....................         writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03); 
0CBD:  MOVLW  32
0CBE:  BSF    03.5
0CBF:  MOVWF  3F
0CC0:  MOVLW  03
0CC1:  MOVWF  40
0CC2:  BCF    0A.3
0CC3:  BCF    03.5
0CC4:  CALL   142
0CC5:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x07); 
0CC6:  MOVLW  30
0CC7:  BSF    03.5
0CC8:  MOVWF  3F
0CC9:  MOVLW  07
0CCA:  MOVWF  40
0CCB:  BCF    0A.3
0CCC:  BCF    03.5
0CCD:  CALL   142
0CCE:  BSF    0A.3
....................         writeReg(0xFF, 0x01); 
0CCF:  MOVLW  FF
0CD0:  BSF    03.5
0CD1:  MOVWF  3F
0CD2:  MOVLW  01
0CD3:  MOVWF  40
0CD4:  BCF    0A.3
0CD5:  BCF    03.5
0CD6:  CALL   142
0CD7:  BSF    0A.3
....................         writeReg(ALGO_PHASECAL_LIM, 0x20); 
0CD8:  MOVLW  30
0CD9:  BSF    03.5
0CDA:  MOVWF  3F
0CDB:  MOVLW  20
0CDC:  MOVWF  40
0CDD:  BCF    0A.3
0CDE:  BCF    03.5
0CDF:  CALL   142
0CE0:  BSF    0A.3
....................         writeReg(0xFF, 0x00); 
0CE1:  MOVLW  FF
0CE2:  BSF    03.5
0CE3:  MOVWF  3F
0CE4:  CLRF   40
0CE5:  BCF    0A.3
0CE6:  BCF    03.5
0CE7:  CALL   142
0CE8:  BSF    0A.3
....................         break; 
0CE9:  GOTO   4ED
....................  
....................       default: 
....................         // invalid period 
....................         return false; 
0CEA:  MOVLW  00
0CEB:  MOVWF  78
0CEC:  GOTO   565
....................     } 
....................  
....................     // apply new VCSEL period 
....................     writeReg(FINAL_RANGE_CONFIG_VCSEL_PERIOD, vcsel_period_reg); 
0CED:  MOVLW  70
0CEE:  BSF    03.5
0CEF:  MOVWF  3F
0CF0:  BCF    03.5
0CF1:  MOVF   6A,W
0CF2:  BSF    03.5
0CF3:  MOVWF  40
0CF4:  BCF    0A.3
0CF5:  BCF    03.5
0CF6:  CALL   142
0CF7:  BSF    0A.3
....................  
....................     // update timeouts 
....................  
....................     // set_sequence_step_timeout() begin 
....................     // (SequenceStepId == VL53L0X_SEQUENCESTEP_FINAL_RANGE) 
....................  
....................     // "For the final range timeout, the pre-range timeout 
....................     //  must be added. To do this both final and pre-range 
....................     //  timeouts must be expressed in macro periods MClks 
....................     //  because they have different vcsel periods." 
....................  
....................     int16 new_final_range_timeout_mclks = 
....................       timeoutMicrosecondsToMclks(timeouts.final_range_us, period_pclks); 
0CF8:  BSF    03.5
0CF9:  MOVF   35,W
0CFA:  MOVWF  65
0CFB:  MOVF   34,W
0CFC:  MOVWF  64
0CFD:  MOVF   33,W
0CFE:  MOVWF  63
0CFF:  MOVF   32,W
0D00:  MOVWF  62
0D01:  BCF    03.5
0D02:  MOVF   69,W
0D03:  BSF    03.5
0D04:  MOVWF  66
0D05:  BCF    0A.3
0D06:  BCF    03.5
0D07:  CALL   675
0D08:  BSF    0A.3
0D09:  MOVF   78,W
0D0A:  MOVWF  71
0D0B:  MOVF   77,W
0D0C:  MOVWF  70
....................  
....................     if (enables.pre_range) 
0D0D:  BTFSS  6B.3
0D0E:  GOTO   517
....................     { 
....................       new_final_range_timeout_mclks += timeouts.pre_range_mclks; 
0D0F:  BSF    03.5
0D10:  MOVF   26,W
0D11:  ADDWF  70,F
0D12:  MOVF   27,W
0D13:  BTFSC  03.0
0D14:  INCFSZ 27,W
0D15:  ADDWF  71,F
0D16:  BCF    03.5
....................     } 
....................  
....................     writeReg16Bit(FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI, 
....................       encodeTimeout(new_final_range_timeout_mclks)); 
0D17:  MOVF   71,W
0D18:  BSF    03.5
0D19:  MOVWF  63
0D1A:  MOVF   70,W
0D1B:  MOVWF  62
0D1C:  BCF    0A.3
0D1D:  BCF    03.5
0D1E:  CALL   75B
0D1F:  BSF    0A.3
0D20:  MOVF   79,W
0D21:  MOVWF  74
0D22:  MOVF   78,W
0D23:  MOVWF  73
0D24:  MOVLW  71
0D25:  BSF    03.5
0D26:  MOVWF  64
0D27:  MOVF   79,W
0D28:  MOVWF  66
0D29:  MOVF   78,W
0D2A:  MOVWF  65
0D2B:  BCF    0A.3
0D2C:  BCF    03.5
0D2D:  CALL   237
0D2E:  BSF    0A.3
....................  
....................     // set_sequence_step_timeout end 
....................   } 
0D2F:  GOTO   533
....................   else  
....................   { 
....................     // invalid type 
....................     return false; 
0D30:  MOVLW  00
0D31:  MOVWF  78
0D32:  GOTO   565
....................   } 
....................  
....................   // "Finally, the timing budget must be re-applied" 
....................  
....................   setMeasurementTimingBudget(measurement_timing_budget_us); 
0D33:  MOVF   36,W
0D34:  BSF    03.5
0D35:  MOVWF  40
0D36:  BCF    03.5
0D37:  MOVF   35,W
0D38:  BSF    03.5
0D39:  MOVWF  3F
0D3A:  BCF    03.5
0D3B:  MOVF   34,W
0D3C:  BSF    03.5
0D3D:  MOVWF  3E
0D3E:  BCF    03.5
0D3F:  MOVF   33,W
0D40:  BSF    03.5
0D41:  MOVWF  3D
0D42:  BCF    03.5
0D43:  CALL   000
....................  
....................   // "Perform the phase calibration. This is needed after changing on vcsel period." 
....................   // VL53L0X_perform_phase_calibration() begin 
....................  
....................   int8 sequence_config = readReg(SYSTEM_SEQUENCE_CONFIG); 
0D44:  MOVLW  01
0D45:  BSF    03.5
0D46:  MOVWF  69
0D47:  BCF    0A.3
0D48:  BCF    03.5
0D49:  CALL   11C
0D4A:  BSF    0A.3
0D4B:  MOVF   78,W
0D4C:  MOVWF  72
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02); 
0D4D:  MOVLW  01
0D4E:  BSF    03.5
0D4F:  MOVWF  3F
0D50:  MOVLW  02
0D51:  MOVWF  40
0D52:  BCF    0A.3
0D53:  BCF    03.5
0D54:  CALL   142
0D55:  BSF    0A.3
....................   performSingleRefCalibration(0x0); 
0D56:  BSF    03.5
0D57:  CLRF   3D
0D58:  BCF    03.5
0D59:  CALL   14C
....................   writeReg(SYSTEM_SEQUENCE_CONFIG, sequence_config); 
0D5A:  MOVLW  01
0D5B:  BSF    03.5
0D5C:  MOVWF  3F
0D5D:  MOVF   72,W
0D5E:  MOVWF  40
0D5F:  BCF    0A.3
0D60:  BCF    03.5
0D61:  CALL   142
0D62:  BSF    0A.3
....................  
....................   // VL53L0X_perform_phase_calibration() end 
....................  
....................   return true; 
0D63:  MOVLW  01
0D64:  MOVWF  78
0D65:  RETURN
.................... } 
....................  
.................... // Get the VCSEL pulse period in PCLKs for the given period type. 
.................... // based on VL53L0X_get_vcsel_pulse_period() 
.................... int8 getVcselPulsePeriod(vcselPeriodType type) 
.................... { 
....................   if (type == VcselPeriodPreRange) 
*
0351:  BSF    03.5
0352:  MOVF   68,F
0353:  BTFSS  03.2
0354:  GOTO   363
....................   { 
....................     return decodeVcselPeriod(readReg(PRE_RANGE_CONFIG_VCSEL_PERIOD)); 
0355:  MOVLW  50
0356:  MOVWF  69
0357:  BCF    03.5
0358:  CALL   11C
0359:  MOVLW  01
035A:  ADDWF  78,W
035B:  MOVWF  77
035C:  BCF    03.0
035D:  RLF    77,F
035E:  MOVF   77,W
035F:  MOVWF  78
0360:  GOTO   376
....................   } 
0361:  GOTO   376
0362:  BSF    03.5
....................   else if (type == VcselPeriodFinalRange) 
0363:  DECFSZ 68,W
0364:  GOTO   373
....................   { 
....................     return decodeVcselPeriod(readReg(FINAL_RANGE_CONFIG_VCSEL_PERIOD)); 
0365:  MOVLW  70
0366:  MOVWF  69
0367:  BCF    03.5
0368:  CALL   11C
0369:  MOVLW  01
036A:  ADDWF  78,W
036B:  MOVWF  77
036C:  BCF    03.0
036D:  RLF    77,F
036E:  MOVF   77,W
036F:  MOVWF  78
0370:  GOTO   376
....................   } 
0371:  GOTO   376
0372:  BSF    03.5
....................   else { return 255; } 
0373:  MOVLW  FF
0374:  MOVWF  78
0375:  BCF    03.5
0376:  RETURN
.................... } 
....................  
.................... // Start continuous ranging measurements. If period_ms (optional) is 0 or not 
.................... // given, continuous back-to-back mode is used (the sensor takes measurements as 
.................... // often as possible); otherwise, continuous timed mode is used, with the given 
.................... // inter-measurement period in milliseconds determining how often the sensor 
.................... // takes a measurement. 
.................... // based on VL53L0X_StartMeasurement() 
.................... void startContinuous(int32 period_ms) 
.................... { 
....................   writeReg(0x80, 0x01); 
....................   writeReg(0xFF, 0x01); 
....................   writeReg(0x00, 0x00); 
....................   writeReg(0x91, stop_variable); 
....................   writeReg(0x00, 0x01); 
....................   writeReg(0xFF, 0x00); 
....................   writeReg(0x80, 0x00); 
....................  
....................   if (period_ms != 0) 
....................   { 
....................     // continuous timed mode 
....................  
....................     // VL53L0X_SetInterMeasurementPeriodMilliSeconds() begin 
....................  
....................     int16 osc_calibrate_val = readReg16Bit(OSC_CALIBRATE_VAL); 
....................  
....................     if (osc_calibrate_val != 0) 
....................     { 
....................       period_ms *= osc_calibrate_val; 
....................     } 
....................  
....................     writeReg32Bit(SYSTEM_INTERMEASUREMENT_PERIOD, period_ms); 
....................  
....................     // VL53L0X_SetInterMeasurementPeriodMilliSeconds() end 
....................  
....................     writeReg(SYSRANGE_START, 0x04); // VL53L0X_REG_SYSRANGE_MODE_TIMED 
....................   } 
....................   else 
....................   { 
....................     // continuous back-to-back mode 
....................     writeReg(SYSRANGE_START, 0x02); // VL53L0X_REG_SYSRANGE_MODE_BACKTOBACK 
....................   } 
.................... } 
....................  
.................... // Stop continuous measurements 
.................... // based on VL53L0X_StopMeasurement() 
.................... void stopContinuous(void) 
.................... { 
....................   writeReg(SYSRANGE_START, 0x01); // VL53L0X_REG_SYSRANGE_MODE_SINGLESHOT 
....................  
....................   writeReg(0xFF, 0x01); 
....................   writeReg(0x00, 0x00); 
....................   writeReg(0x91, 0x00); 
....................   writeReg(0x00, 0x01); 
....................   writeReg(0xFF, 0x00); 
.................... } 
....................  
.................... // Returns a range reading in millimeters when continuous mode is active 
.................... // (readRangeSingleMillimeters() also calls this function after starting a 
.................... // single-shot range measurement) 
.................... int16 readRangeContinuousMillimeters(void) 
.................... { 
....................   startTimeout(); 
*
0EAE:  MOVF   39,W
0EAF:  MOVWF  31
0EB0:  MOVF   38,W
0EB1:  MOVWF  30
....................   while ((readReg(RESULT_INTERRUPT_STATUS) & 0x07) == 0) 
0EB2:  MOVLW  13
0EB3:  BSF    03.5
0EB4:  MOVWF  69
0EB5:  BCF    0A.3
0EB6:  BCF    03.5
0EB7:  CALL   11C
0EB8:  BSF    0A.3
0EB9:  MOVF   78,W
0EBA:  ANDLW  07
0EBB:  BTFSS  03.2
0EBC:  GOTO   6DC
....................   { 
....................     if (checkTimeoutExpired()) 
0EBD:  MOVF   2D,F
0EBE:  BTFSS  03.2
0EBF:  GOTO   6C3
0EC0:  MOVF   2E,F
0EC1:  BTFSC  03.2
0EC2:  GOTO   6DB
0EC3:  MOVF   30,W
0EC4:  SUBWF  38,W
0EC5:  MOVWF  6A
0EC6:  MOVF   39,W
0EC7:  MOVWF  6B
0EC8:  MOVF   31,W
0EC9:  BTFSS  03.0
0ECA:  INCFSZ 31,W
0ECB:  SUBWF  6B,F
0ECC:  MOVF   2E,W
0ECD:  SUBWF  6B,W
0ECE:  BTFSS  03.0
0ECF:  GOTO   6DB
0ED0:  BTFSS  03.2
0ED1:  GOTO   6D6
0ED2:  MOVF   6A,W
0ED3:  SUBWF  2D,W
0ED4:  BTFSC  03.0
0ED5:  GOTO   6DB
....................     { 
....................       did_timeout = true; 
0ED6:  BSF    2F.0
....................       return 65535; 
0ED7:  MOVLW  FF
0ED8:  MOVWF  78
0ED9:  MOVWF  79
0EDA:  GOTO   6F4
....................     } 
0EDB:  GOTO   6B2
....................   } 
....................  
....................   // assumptions: Linearity Corrective Gain is 1000 (default); 
....................   // fractional ranging is not enabled 
....................   int16 range = readReg16Bit(RESULT_RANGE_STATUS + 10); 
0EDC:  MOVLW  1E
0EDD:  BSF    03.5
0EDE:  MOVWF  68
0EDF:  BCF    0A.3
0EE0:  BCF    03.5
0EE1:  CALL   498
0EE2:  BSF    0A.3
0EE3:  MOVF   79,W
0EE4:  MOVWF  69
0EE5:  MOVF   78,W
0EE6:  MOVWF  68
....................  
....................   writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01); 
0EE7:  MOVLW  0B
0EE8:  BSF    03.5
0EE9:  MOVWF  3F
0EEA:  MOVLW  01
0EEB:  MOVWF  40
0EEC:  BCF    0A.3
0EED:  BCF    03.5
0EEE:  CALL   142
0EEF:  BSF    0A.3
....................  
....................   return range; 
0EF0:  MOVF   68,W
0EF1:  MOVWF  78
0EF2:  MOVF   69,W
0EF3:  MOVWF  79
.................... } 
....................  
.................... // Performs a single-shot range measurement and returns the reading in 
.................... // millimeters 
.................... // based on VL53L0X_PerformSingleRangingMeasurement() 
.................... int16 readRangeSingleMillimeters(void) 
.................... { 
....................   writeReg(0x80, 0x01); 
*
0E3F:  MOVLW  80
0E40:  BSF    03.5
0E41:  MOVWF  3F
0E42:  MOVLW  01
0E43:  MOVWF  40
0E44:  BCF    0A.3
0E45:  BCF    03.5
0E46:  CALL   142
0E47:  BSF    0A.3
....................   writeReg(0xFF, 0x01); 
0E48:  MOVLW  FF
0E49:  BSF    03.5
0E4A:  MOVWF  3F
0E4B:  MOVLW  01
0E4C:  MOVWF  40
0E4D:  BCF    0A.3
0E4E:  BCF    03.5
0E4F:  CALL   142
0E50:  BSF    0A.3
....................   writeReg(0x00, 0x00); 
0E51:  BSF    03.5
0E52:  CLRF   3F
0E53:  CLRF   40
0E54:  BCF    0A.3
0E55:  BCF    03.5
0E56:  CALL   142
0E57:  BSF    0A.3
....................   writeReg(0x91, stop_variable); 
0E58:  MOVLW  91
0E59:  BSF    03.5
0E5A:  MOVWF  3F
0E5B:  BCF    03.5
0E5C:  MOVF   32,W
0E5D:  BSF    03.5
0E5E:  MOVWF  40
0E5F:  BCF    0A.3
0E60:  BCF    03.5
0E61:  CALL   142
0E62:  BSF    0A.3
....................   writeReg(0x00, 0x01); 
0E63:  BSF    03.5
0E64:  CLRF   3F
0E65:  MOVLW  01
0E66:  MOVWF  40
0E67:  BCF    0A.3
0E68:  BCF    03.5
0E69:  CALL   142
0E6A:  BSF    0A.3
....................   writeReg(0xFF, 0x00); 
0E6B:  MOVLW  FF
0E6C:  BSF    03.5
0E6D:  MOVWF  3F
0E6E:  CLRF   40
0E6F:  BCF    0A.3
0E70:  BCF    03.5
0E71:  CALL   142
0E72:  BSF    0A.3
....................   writeReg(0x80, 0x00); 
0E73:  MOVLW  80
0E74:  BSF    03.5
0E75:  MOVWF  3F
0E76:  CLRF   40
0E77:  BCF    0A.3
0E78:  BCF    03.5
0E79:  CALL   142
0E7A:  BSF    0A.3
....................  
....................   writeReg(SYSRANGE_START, 0x01); 
0E7B:  BSF    03.5
0E7C:  CLRF   3F
0E7D:  MOVLW  01
0E7E:  MOVWF  40
0E7F:  BCF    0A.3
0E80:  BCF    03.5
0E81:  CALL   142
0E82:  BSF    0A.3
....................  
....................   // "Wait until start bit has been cleared" 
....................   startTimeout(); 
0E83:  MOVF   39,W
0E84:  MOVWF  31
0E85:  MOVF   38,W
0E86:  MOVWF  30
....................   while (readReg(SYSRANGE_START) & 0x01) 
0E87:  BSF    03.5
0E88:  CLRF   69
0E89:  BCF    0A.3
0E8A:  BCF    03.5
0E8B:  CALL   11C
0E8C:  BSF    0A.3
0E8D:  BTFSS  78.0
0E8E:  GOTO   6AE
....................   { 
....................     if (checkTimeoutExpired()) 
0E8F:  MOVF   2D,F
0E90:  BTFSS  03.2
0E91:  GOTO   695
0E92:  MOVF   2E,F
0E93:  BTFSC  03.2
0E94:  GOTO   6AD
0E95:  MOVF   30,W
0E96:  SUBWF  38,W
0E97:  MOVWF  68
0E98:  MOVF   39,W
0E99:  MOVWF  69
0E9A:  MOVF   31,W
0E9B:  BTFSS  03.0
0E9C:  INCFSZ 31,W
0E9D:  SUBWF  69,F
0E9E:  MOVF   2E,W
0E9F:  SUBWF  69,W
0EA0:  BTFSS  03.0
0EA1:  GOTO   6AD
0EA2:  BTFSS  03.2
0EA3:  GOTO   6A8
0EA4:  MOVF   68,W
0EA5:  SUBWF  2D,W
0EA6:  BTFSC  03.0
0EA7:  GOTO   6AD
....................     { 
....................       did_timeout = true; 
0EA8:  BSF    2F.0
....................       return 65535; 
0EA9:  MOVLW  FF
0EAA:  MOVWF  78
0EAB:  MOVWF  79
0EAC:  GOTO   6F5
....................     } 
0EAD:  GOTO   687
....................   } 
....................  
....................   return readRangeContinuousMillimeters(); 
*
0EF4:  MOVF   79,W
0EF5:  BSF    0A.3
0EF6:  BSF    0A.4
0EF7:  GOTO   549 (RETURN)
.................... } 
....................  
.................... // Did a timeout occur in one of the read functions since the last call to 
.................... // timeoutOccurred()? 
.................... boolean timeoutOccurred() 
.................... { 
....................   boolean tmp = did_timeout; 
....................   did_timeout = false; 
....................   return tmp; 
.................... } 
....................  
.................... // Private Methods ///////////////////////////////////////////////////////////// 
....................  
.................... // Get reference SPAD (single photon avalanche diode) count and type 
.................... // based on VL53L0X_get_info_from_device(), 
.................... // but only gets reference SPAD count and type 
.................... boolean getSpadInfo(int8 * count, boolean * type_is_aperture) 
.................... { 
....................   int8 tmp; 
....................  
....................   writeReg(0x80, 0x01); 
*
109E:  MOVLW  80
109F:  BSF    03.5
10A0:  MOVWF  3F
10A1:  MOVLW  01
10A2:  MOVWF  40
10A3:  BCF    0A.4
10A4:  BCF    03.5
10A5:  CALL   142
10A6:  BSF    0A.4
....................   writeReg(0xFF, 0x01); 
10A7:  MOVLW  FF
10A8:  BSF    03.5
10A9:  MOVWF  3F
10AA:  MOVLW  01
10AB:  MOVWF  40
10AC:  BCF    0A.4
10AD:  BCF    03.5
10AE:  CALL   142
10AF:  BSF    0A.4
....................   writeReg(0x00, 0x00); 
10B0:  BSF    03.5
10B1:  CLRF   3F
10B2:  CLRF   40
10B3:  BCF    0A.4
10B4:  BCF    03.5
10B5:  CALL   142
10B6:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x06); 
10B7:  MOVLW  FF
10B8:  BSF    03.5
10B9:  MOVWF  3F
10BA:  MOVLW  06
10BB:  MOVWF  40
10BC:  BCF    0A.4
10BD:  BCF    03.5
10BE:  CALL   142
10BF:  BSF    0A.4
....................   writeReg(0x83, readReg(0x83) | 0x04); 
10C0:  MOVLW  83
10C1:  BSF    03.5
10C2:  MOVWF  69
10C3:  BCF    0A.4
10C4:  BCF    03.5
10C5:  CALL   11C
10C6:  BSF    0A.4
10C7:  MOVF   78,W
10C8:  IORLW  04
10C9:  BSF    03.5
10CA:  MOVWF  20
10CB:  MOVLW  83
10CC:  MOVWF  3F
10CD:  MOVF   20,W
10CE:  MOVWF  40
10CF:  BCF    0A.4
10D0:  BCF    03.5
10D1:  CALL   142
10D2:  BSF    0A.4
....................   writeReg(0xFF, 0x07); 
10D3:  MOVLW  FF
10D4:  BSF    03.5
10D5:  MOVWF  3F
10D6:  MOVLW  07
10D7:  MOVWF  40
10D8:  BCF    0A.4
10D9:  BCF    03.5
10DA:  CALL   142
10DB:  BSF    0A.4
....................   writeReg(0x81, 0x01); 
10DC:  MOVLW  81
10DD:  BSF    03.5
10DE:  MOVWF  3F
10DF:  MOVLW  01
10E0:  MOVWF  40
10E1:  BCF    0A.4
10E2:  BCF    03.5
10E3:  CALL   142
10E4:  BSF    0A.4
....................  
....................   writeReg(0x80, 0x01); 
10E5:  MOVLW  80
10E6:  BSF    03.5
10E7:  MOVWF  3F
10E8:  MOVLW  01
10E9:  MOVWF  40
10EA:  BCF    0A.4
10EB:  BCF    03.5
10EC:  CALL   142
10ED:  BSF    0A.4
....................  
....................   writeReg(0x94, 0x6b); 
10EE:  MOVLW  94
10EF:  BSF    03.5
10F0:  MOVWF  3F
10F1:  MOVLW  6B
10F2:  MOVWF  40
10F3:  BCF    0A.4
10F4:  BCF    03.5
10F5:  CALL   142
10F6:  BSF    0A.4
....................   writeReg(0x83, 0x00); 
10F7:  MOVLW  83
10F8:  BSF    03.5
10F9:  MOVWF  3F
10FA:  CLRF   40
10FB:  BCF    0A.4
10FC:  BCF    03.5
10FD:  CALL   142
10FE:  BSF    0A.4
....................   startTimeout(); 
10FF:  MOVF   39,W
1100:  MOVWF  31
1101:  MOVF   38,W
1102:  MOVWF  30
....................   while (readReg(0x83) == 0x00) 
1103:  MOVLW  83
1104:  BSF    03.5
1105:  MOVWF  69
1106:  BCF    0A.4
1107:  BCF    03.5
1108:  CALL   11C
1109:  BSF    0A.4
110A:  MOVF   78,F
110B:  BTFSS  03.2
110C:  GOTO   138
....................   { 
....................     if (checkTimeoutExpired()) { return false; } 
110D:  MOVF   2D,F
110E:  BTFSS  03.2
110F:  GOTO   113
1110:  MOVF   2E,F
1111:  BTFSC  03.2
1112:  GOTO   137
1113:  MOVF   30,W
1114:  SUBWF  38,W
1115:  BSF    03.5
1116:  MOVWF  20
1117:  BCF    03.5
1118:  MOVF   39,W
1119:  BSF    03.5
111A:  MOVWF  21
111B:  BCF    03.5
111C:  MOVF   31,W
111D:  BTFSS  03.0
111E:  INCFSZ 31,W
111F:  GOTO   121
1120:  GOTO   124
1121:  BSF    03.5
1122:  SUBWF  21,F
1123:  BCF    03.5
1124:  MOVF   2E,W
1125:  BSF    03.5
1126:  SUBWF  21,W
1127:  BTFSC  03.0
1128:  GOTO   12B
1129:  BCF    03.5
112A:  GOTO   137
112B:  BTFSS  03.2
112C:  GOTO   133
112D:  MOVF   20,W
112E:  BCF    03.5
112F:  SUBWF  2D,W
1130:  BTFSC  03.0
1131:  GOTO   137
1132:  BSF    03.5
1133:  MOVLW  00
1134:  MOVWF  78
1135:  GOTO   1A4
1136:  BCF    03.5
1137:  GOTO   103
....................   } 
....................   writeReg(0x83, 0x01); 
1138:  MOVLW  83
1139:  BSF    03.5
113A:  MOVWF  3F
113B:  MOVLW  01
113C:  MOVWF  40
113D:  BCF    0A.4
113E:  BCF    03.5
113F:  CALL   142
1140:  BSF    0A.4
....................   tmp = readReg(0x92); 
1141:  MOVLW  92
1142:  BSF    03.5
1143:  MOVWF  69
1144:  BCF    0A.4
1145:  BCF    03.5
1146:  CALL   11C
1147:  BSF    0A.4
1148:  MOVF   78,W
1149:  MOVWF  76
....................  
....................   *count = tmp & 0x7f; 
114A:  MOVF   74,W
114B:  MOVWF  04
114C:  BCF    03.7
114D:  BTFSC  75.0
114E:  BSF    03.7
114F:  MOVF   76,W
1150:  ANDLW  7F
1151:  MOVWF  00
....................   *type_is_aperture = (tmp >> 7) & 0x01; 
1152:  MOVF   7B,W
1153:  MOVWF  04
1154:  BCF    03.7
1155:  BTFSC  7C.0
1156:  BSF    03.7
1157:  CLRF   77
1158:  BTFSC  76.7
1159:  BSF    77.0
115A:  MOVF   77,W
115B:  ANDLW  01
115C:  MOVWF  00
....................  
....................   writeReg(0x81, 0x00); 
115D:  MOVLW  81
115E:  BSF    03.5
115F:  MOVWF  3F
1160:  CLRF   40
1161:  BCF    0A.4
1162:  BCF    03.5
1163:  CALL   142
1164:  BSF    0A.4
....................   writeReg(0xFF, 0x06); 
1165:  MOVLW  FF
1166:  BSF    03.5
1167:  MOVWF  3F
1168:  MOVLW  06
1169:  MOVWF  40
116A:  BCF    0A.4
116B:  BCF    03.5
116C:  CALL   142
116D:  BSF    0A.4
....................   writeReg(0x83, readReg( 0x83  & ~0x04)); 
116E:  MOVLW  83
116F:  BSF    03.5
1170:  MOVWF  69
1171:  BCF    0A.4
1172:  BCF    03.5
1173:  CALL   11C
1174:  BSF    0A.4
1175:  MOVF   78,W
1176:  BSF    03.5
1177:  MOVWF  20
1178:  MOVLW  83
1179:  MOVWF  3F
117A:  MOVF   20,W
117B:  MOVWF  40
117C:  BCF    0A.4
117D:  BCF    03.5
117E:  CALL   142
117F:  BSF    0A.4
....................   writeReg(0xFF, 0x01); 
1180:  MOVLW  FF
1181:  BSF    03.5
1182:  MOVWF  3F
1183:  MOVLW  01
1184:  MOVWF  40
1185:  BCF    0A.4
1186:  BCF    03.5
1187:  CALL   142
1188:  BSF    0A.4
....................   writeReg(0x00, 0x01); 
1189:  BSF    03.5
118A:  CLRF   3F
118B:  MOVLW  01
118C:  MOVWF  40
118D:  BCF    0A.4
118E:  BCF    03.5
118F:  CALL   142
1190:  BSF    0A.4
....................  
....................   writeReg(0xFF, 0x00); 
1191:  MOVLW  FF
1192:  BSF    03.5
1193:  MOVWF  3F
1194:  CLRF   40
1195:  BCF    0A.4
1196:  BCF    03.5
1197:  CALL   142
1198:  BSF    0A.4
....................   writeReg(0x80, 0x00); 
1199:  MOVLW  80
119A:  BSF    03.5
119B:  MOVWF  3F
119C:  CLRF   40
119D:  BCF    0A.4
119E:  BCF    03.5
119F:  CALL   142
11A0:  BSF    0A.4
....................  
....................   return true; 
11A1:  MOVLW  01
11A2:  MOVWF  78
11A3:  BSF    03.5
.................... } 
....................  
.................... // Get sequence step enables 
.................... // based on VL53L0X_GetSequenceStepEnables() 
.................... void getSequenceStepEnables(SequenceStepEnables * enables) 
*
02B3:  MOVLW  01
02B4:  BSF    03.5
02B5:  MOVWF  69
02B6:  BCF    03.5
02B7:  CALL   11C
02B8:  MOVF   78,W
02B9:  BSF    03.5
02BA:  MOVWF  64
.................... { 
....................   int8 sequence_config = readReg(SYSTEM_SEQUENCE_CONFIG); 
....................  
....................   enables->tcc          = (sequence_config >> 4) & 0x1; 
02BB:  MOVF   63,W
02BC:  MOVWF  7A
02BD:  MOVF   62,W
02BE:  MOVWF  65
02BF:  MOVF   63,W
02C0:  MOVWF  66
02C1:  SWAPF  64,W
02C2:  MOVWF  77
02C3:  MOVLW  0F
02C4:  ANDWF  77,F
02C5:  MOVF   77,W
02C6:  ANDLW  01
02C7:  MOVWF  78
02C8:  BTFSC  78.0
02C9:  GOTO   2D1
02CA:  MOVF   65,W
02CB:  MOVWF  04
02CC:  BCF    03.7
02CD:  BTFSC  66.0
02CE:  BSF    03.7
02CF:  BCF    00.0
02D0:  GOTO   2D7
02D1:  MOVF   65,W
02D2:  MOVWF  04
02D3:  BCF    03.7
02D4:  BTFSC  66.0
02D5:  BSF    03.7
02D6:  BSF    00.0
....................   enables->dss          = (sequence_config >> 3) & 0x1; 
02D7:  MOVF   62,W
02D8:  MOVWF  78
02D9:  MOVF   63,W
02DA:  MOVWF  7A
02DB:  MOVF   78,W
02DC:  MOVWF  65
02DD:  MOVF   63,W
02DE:  MOVWF  66
02DF:  RRF    64,W
02E0:  MOVWF  77
02E1:  RRF    77,F
02E2:  RRF    77,F
02E3:  MOVLW  1F
02E4:  ANDWF  77,F
02E5:  MOVF   77,W
02E6:  ANDLW  01
02E7:  MOVWF  78
02E8:  BTFSC  78.0
02E9:  GOTO   2F1
02EA:  MOVF   65,W
02EB:  MOVWF  04
02EC:  BCF    03.7
02ED:  BTFSC  66.0
02EE:  BSF    03.7
02EF:  BCF    00.2
02F0:  GOTO   2F7
02F1:  MOVF   65,W
02F2:  MOVWF  04
02F3:  BCF    03.7
02F4:  BTFSC  66.0
02F5:  BSF    03.7
02F6:  BSF    00.2
....................   enables->msrc         = (sequence_config >> 2) & 0x1; 
02F7:  MOVF   63,W
02F8:  MOVWF  7A
02F9:  MOVF   62,W
02FA:  MOVWF  65
02FB:  MOVF   63,W
02FC:  MOVWF  66
02FD:  RRF    64,W
02FE:  MOVWF  77
02FF:  RRF    77,F
0300:  MOVLW  3F
0301:  ANDWF  77,F
0302:  MOVF   77,W
0303:  ANDLW  01
0304:  MOVWF  78
0305:  BTFSC  78.0
0306:  GOTO   30E
0307:  MOVF   65,W
0308:  MOVWF  04
0309:  BCF    03.7
030A:  BTFSC  66.0
030B:  BSF    03.7
030C:  BCF    00.1
030D:  GOTO   314
030E:  MOVF   65,W
030F:  MOVWF  04
0310:  BCF    03.7
0311:  BTFSC  66.0
0312:  BSF    03.7
0313:  BSF    00.1
....................   enables->pre_range    = (sequence_config >> 6) & 0x1; 
0314:  MOVF   62,W
0315:  MOVWF  78
0316:  MOVF   63,W
0317:  MOVWF  7A
0318:  MOVF   78,W
0319:  MOVWF  65
031A:  MOVF   63,W
031B:  MOVWF  66
031C:  SWAPF  64,W
031D:  MOVWF  77
031E:  RRF    77,F
031F:  RRF    77,F
0320:  MOVLW  03
0321:  ANDWF  77,F
0322:  MOVF   77,W
0323:  ANDLW  01
0324:  MOVWF  78
0325:  BTFSC  78.0
0326:  GOTO   32E
0327:  MOVF   65,W
0328:  MOVWF  04
0329:  BCF    03.7
032A:  BTFSC  66.0
032B:  BSF    03.7
032C:  BCF    00.3
032D:  GOTO   334
032E:  MOVF   65,W
032F:  MOVWF  04
0330:  BCF    03.7
0331:  BTFSC  66.0
0332:  BSF    03.7
0333:  BSF    00.3
....................   enables->final_range  = (sequence_config >> 7) & 0x1; 
0334:  MOVF   63,W
0335:  MOVWF  7A
0336:  MOVF   62,W
0337:  MOVWF  65
0338:  MOVF   63,W
0339:  MOVWF  66
033A:  CLRF   77
033B:  BTFSC  64.7
033C:  BSF    77.0
033D:  MOVF   77,W
033E:  ANDLW  01
033F:  MOVWF  78
0340:  BTFSC  78.0
0341:  GOTO   349
0342:  MOVF   65,W
0343:  MOVWF  04
0344:  BCF    03.7
0345:  BTFSC  66.0
0346:  BSF    03.7
0347:  BCF    00.4
0348:  GOTO   34F
0349:  MOVF   65,W
034A:  MOVWF  04
034B:  BCF    03.7
034C:  BTFSC  66.0
034D:  BSF    03.7
034E:  BSF    00.4
034F:  BCF    03.5
0350:  RETURN
.................... } 
....................  
.................... // Get sequence step timeouts 
.................... // based on get_sequence_step_timeout(), 
.................... // but gets all timeouts instead of just the requested one, and also stores 
.................... // intermediate values 
.................... void getSequenceStepTimeouts(SequenceStepEnables  * enables, SequenceStepTimeouts * timeouts) 
.................... { 
....................   timeouts->pre_range_vcsel_period_pclks = getVcselPulsePeriod(VcselPeriodPreRange); 
*
04E6:  BSF    03.5
04E7:  MOVF   64,W
04E8:  MOVWF  78
04E9:  MOVF   65,W
04EA:  MOVWF  7A
04EB:  MOVF   64,W
04EC:  MOVWF  66
04ED:  MOVF   65,W
04EE:  MOVWF  67
04EF:  CLRF   68
04F0:  BCF    03.5
04F1:  CALL   351
04F2:  BSF    03.5
04F3:  MOVF   66,W
04F4:  MOVWF  04
04F5:  BCF    03.7
04F6:  BTFSC  67.0
04F7:  BSF    03.7
04F8:  INCF   04,F
04F9:  CLRF   00
04FA:  DECF   04,F
04FB:  MOVF   78,W
04FC:  MOVWF  00
....................  
....................   timeouts->msrc_dss_tcc_mclks = readReg(MSRC_CONFIG_TIMEOUT_MACROP) + 1; 
04FD:  MOVLW  04
04FE:  ADDWF  64,W
04FF:  MOVWF  78
0500:  MOVF   65,W
0501:  MOVWF  7A
0502:  BTFSC  03.0
0503:  INCF   7A,F
0504:  MOVF   78,W
0505:  MOVWF  66
0506:  MOVF   7A,W
0507:  MOVWF  67
0508:  MOVLW  46
0509:  MOVWF  69
050A:  BCF    03.5
050B:  CALL   11C
050C:  MOVLW  01
050D:  ADDWF  78,W
050E:  BSF    03.5
050F:  MOVWF  68
0510:  MOVF   66,W
0511:  MOVWF  04
0512:  BCF    03.7
0513:  BTFSC  67.0
0514:  BSF    03.7
0515:  INCF   04,F
0516:  CLRF   00
0517:  DECF   04,F
0518:  MOVF   68,W
0519:  MOVWF  00
....................   timeouts->msrc_dss_tcc_us = 
....................     timeoutMclksToMicroseconds(timeouts->msrc_dss_tcc_mclks, 
....................                                timeouts->pre_range_vcsel_period_pclks); 
051A:  MOVLW  0A
051B:  ADDWF  64,W
051C:  MOVWF  78
051D:  MOVF   65,W
051E:  MOVWF  7A
051F:  BTFSC  03.0
0520:  INCF   7A,F
0521:  MOVF   78,W
0522:  MOVWF  66
0523:  MOVF   7A,W
0524:  MOVWF  67
0525:  MOVLW  04
0526:  ADDWF  64,W
0527:  MOVWF  04
0528:  BCF    03.7
0529:  BTFSC  65.0
052A:  BSF    03.7
052B:  INCF   04,F
052C:  MOVF   00,W
052D:  MOVWF  69
052E:  DECF   04,F
052F:  MOVF   00,W
0530:  MOVWF  68
0531:  MOVF   64,W
0532:  MOVWF  04
0533:  BCF    03.7
0534:  BTFSC  65.0
0535:  BSF    03.7
0536:  INCF   04,F
0537:  MOVF   00,W
0538:  MOVWF  6B
0539:  DECF   04,F
053A:  MOVF   00,W
053B:  MOVWF  6A
053C:  MOVF   69,W
053D:  MOVWF  6D
053E:  MOVF   68,W
053F:  MOVWF  6C
0540:  MOVF   6A,W
0541:  MOVWF  6E
0542:  BCF    03.5
0543:  CALL   3F4
0544:  BSF    03.5
0545:  MOVF   66,W
0546:  MOVWF  04
0547:  BCF    03.7
0548:  BTFSC  67.0
0549:  BSF    03.7
054A:  MOVF   77,W
054B:  MOVWF  00
054C:  INCF   04,F
054D:  MOVF   78,W
054E:  MOVWF  00
054F:  INCF   04,F
0550:  MOVF   79,W
0551:  MOVWF  00
0552:  INCF   04,F
0553:  MOVF   7A,W
0554:  MOVWF  00
....................  
....................   timeouts->pre_range_mclks = 
....................     decodeTimeout(readReg16Bit(PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI)); 
0555:  MOVLW  06
0556:  ADDWF  64,W
0557:  MOVWF  78
0558:  MOVF   65,W
0559:  MOVWF  7A
055A:  BTFSC  03.0
055B:  INCF   7A,F
055C:  MOVF   78,W
055D:  MOVWF  66
055E:  MOVF   7A,W
055F:  MOVWF  67
0560:  MOVLW  51
0561:  MOVWF  68
0562:  BCF    03.5
0563:  CALL   498
0564:  MOVF   79,W
0565:  BSF    03.5
0566:  MOVWF  69
0567:  MOVF   78,W
0568:  MOVWF  68
0569:  MOVF   69,W
056A:  MOVWF  6B
056B:  MOVF   68,W
056C:  MOVWF  6A
056D:  BCF    03.5
056E:  CALL   4CA
056F:  BSF    03.5
0570:  MOVF   66,W
0571:  MOVWF  04
0572:  BCF    03.7
0573:  BTFSC  67.0
0574:  BSF    03.7
0575:  INCF   04,F
0576:  MOVF   79,W
0577:  MOVWF  00
0578:  DECF   04,F
0579:  MOVF   78,W
057A:  MOVWF  00
....................   timeouts->pre_range_us = 
....................     timeoutMclksToMicroseconds(timeouts->pre_range_mclks, 
....................                                timeouts->pre_range_vcsel_period_pclks); 
057B:  MOVLW  0E
057C:  ADDWF  64,W
057D:  MOVWF  78
057E:  MOVF   65,W
057F:  MOVWF  7A
0580:  BTFSC  03.0
0581:  INCF   7A,F
0582:  MOVF   78,W
0583:  MOVWF  66
0584:  MOVF   7A,W
0585:  MOVWF  67
0586:  MOVLW  06
0587:  ADDWF  64,W
0588:  MOVWF  04
0589:  BCF    03.7
058A:  BTFSC  65.0
058B:  BSF    03.7
058C:  INCF   04,F
058D:  MOVF   00,W
058E:  MOVWF  69
058F:  DECF   04,F
0590:  MOVF   00,W
0591:  MOVWF  68
0592:  MOVF   64,W
0593:  MOVWF  04
0594:  BCF    03.7
0595:  BTFSC  65.0
0596:  BSF    03.7
0597:  INCF   04,F
0598:  MOVF   00,W
0599:  MOVWF  6B
059A:  DECF   04,F
059B:  MOVF   00,W
059C:  MOVWF  6A
059D:  MOVF   69,W
059E:  MOVWF  6D
059F:  MOVF   68,W
05A0:  MOVWF  6C
05A1:  MOVF   6A,W
05A2:  MOVWF  6E
05A3:  BCF    03.5
05A4:  CALL   3F4
05A5:  BSF    03.5
05A6:  MOVF   66,W
05A7:  MOVWF  04
05A8:  BCF    03.7
05A9:  BTFSC  67.0
05AA:  BSF    03.7
05AB:  MOVF   77,W
05AC:  MOVWF  00
05AD:  INCF   04,F
05AE:  MOVF   78,W
05AF:  MOVWF  00
05B0:  INCF   04,F
05B1:  MOVF   79,W
05B2:  MOVWF  00
05B3:  INCF   04,F
05B4:  MOVF   7A,W
05B5:  MOVWF  00
....................  
....................   timeouts->final_range_vcsel_period_pclks = getVcselPulsePeriod(VcselPeriodFinalRange); 
05B6:  MOVLW  02
05B7:  ADDWF  64,W
05B8:  MOVWF  78
05B9:  MOVF   65,W
05BA:  MOVWF  7A
05BB:  BTFSC  03.0
05BC:  INCF   7A,F
05BD:  MOVF   78,W
05BE:  MOVWF  66
05BF:  MOVF   7A,W
05C0:  MOVWF  67
05C1:  MOVLW  01
05C2:  MOVWF  68
05C3:  BCF    03.5
05C4:  CALL   351
05C5:  BSF    03.5
05C6:  MOVF   66,W
05C7:  MOVWF  04
05C8:  BCF    03.7
05C9:  BTFSC  67.0
05CA:  BSF    03.7
05CB:  INCF   04,F
05CC:  CLRF   00
05CD:  DECF   04,F
05CE:  MOVF   78,W
05CF:  MOVWF  00
....................  
....................   timeouts->final_range_mclks = 
....................     decodeTimeout(readReg16Bit(FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI)); 
05D0:  MOVLW  08
05D1:  ADDWF  64,W
05D2:  MOVWF  78
05D3:  MOVF   65,W
05D4:  MOVWF  7A
05D5:  BTFSC  03.0
05D6:  INCF   7A,F
05D7:  MOVF   78,W
05D8:  MOVWF  66
05D9:  MOVF   7A,W
05DA:  MOVWF  67
05DB:  MOVLW  71
05DC:  MOVWF  68
05DD:  BCF    03.5
05DE:  CALL   498
05DF:  MOVF   79,W
05E0:  BSF    03.5
05E1:  MOVWF  69
05E2:  MOVF   78,W
05E3:  MOVWF  68
05E4:  MOVF   69,W
05E5:  MOVWF  6B
05E6:  MOVF   68,W
05E7:  MOVWF  6A
05E8:  BCF    03.5
05E9:  CALL   4CA
05EA:  BSF    03.5
05EB:  MOVF   66,W
05EC:  MOVWF  04
05ED:  BCF    03.7
05EE:  BTFSC  67.0
05EF:  BSF    03.7
05F0:  INCF   04,F
05F1:  MOVF   79,W
05F2:  MOVWF  00
05F3:  DECF   04,F
05F4:  MOVF   78,W
05F5:  MOVWF  00
....................  
....................   if (enables->pre_range) 
05F6:  MOVF   62,W
05F7:  MOVWF  04
05F8:  BCF    03.7
05F9:  BTFSC  63.0
05FA:  BSF    03.7
05FB:  BTFSS  00.3
05FC:  GOTO   637
....................   { 
....................     timeouts->final_range_mclks -= timeouts->pre_range_mclks; 
05FD:  MOVLW  08
05FE:  ADDWF  64,W
05FF:  MOVWF  78
0600:  MOVF   65,W
0601:  MOVWF  7A
0602:  BTFSC  03.0
0603:  INCF   7A,F
0604:  MOVF   78,W
0605:  MOVWF  66
0606:  MOVF   7A,W
0607:  MOVWF  67
0608:  MOVF   66,W
0609:  MOVWF  04
060A:  BCF    03.7
060B:  BTFSC  67.0
060C:  BSF    03.7
060D:  INCF   04,F
060E:  MOVF   00,W
060F:  MOVWF  69
0610:  DECF   04,F
0611:  MOVF   00,W
0612:  MOVWF  68
0613:  MOVLW  06
0614:  ADDWF  64,W
0615:  MOVWF  04
0616:  BCF    03.7
0617:  BTFSC  65.0
0618:  BSF    03.7
0619:  INCF   04,F
061A:  MOVF   00,W
061B:  MOVWF  7A
061C:  DECF   04,F
061D:  MOVF   00,W
061E:  SUBWF  68,W
061F:  MOVWF  77
0620:  MOVF   7A,W
0621:  BTFSS  03.0
0622:  INCFSZ 7A,W
0623:  GOTO   626
0624:  MOVF   69,W
0625:  GOTO   627
0626:  SUBWF  69,W
0627:  MOVWF  7A
0628:  MOVF   77,W
0629:  MOVWF  68
062A:  MOVF   7A,W
062B:  MOVWF  69
062C:  MOVF   66,W
062D:  MOVWF  04
062E:  BCF    03.7
062F:  BTFSC  67.0
0630:  BSF    03.7
0631:  INCF   04,F
0632:  MOVF   69,W
0633:  MOVWF  00
0634:  DECF   04,F
0635:  MOVF   68,W
0636:  MOVWF  00
....................   } 
....................  
....................   timeouts->final_range_us = 
....................     timeoutMclksToMicroseconds(timeouts->final_range_mclks, 
....................                                timeouts->final_range_vcsel_period_pclks); 
0637:  MOVLW  12
0638:  ADDWF  64,W
0639:  MOVWF  78
063A:  MOVF   65,W
063B:  MOVWF  7A
063C:  BTFSC  03.0
063D:  INCF   7A,F
063E:  MOVF   78,W
063F:  MOVWF  66
0640:  MOVF   7A,W
0641:  MOVWF  67
0642:  MOVLW  08
0643:  ADDWF  64,W
0644:  MOVWF  04
0645:  BCF    03.7
0646:  BTFSC  65.0
0647:  BSF    03.7
0648:  INCF   04,F
0649:  MOVF   00,W
064A:  MOVWF  69
064B:  DECF   04,F
064C:  MOVF   00,W
064D:  MOVWF  68
064E:  MOVLW  02
064F:  ADDWF  64,W
0650:  MOVWF  04
0651:  BCF    03.7
0652:  BTFSC  65.0
0653:  BSF    03.7
0654:  INCF   04,F
0655:  MOVF   00,W
0656:  MOVWF  6B
0657:  DECF   04,F
0658:  MOVF   00,W
0659:  MOVWF  6A
065A:  MOVF   69,W
065B:  MOVWF  6D
065C:  MOVF   68,W
065D:  MOVWF  6C
065E:  MOVF   6A,W
065F:  MOVWF  6E
0660:  BCF    03.5
0661:  CALL   3F4
0662:  BSF    03.5
0663:  MOVF   66,W
0664:  MOVWF  04
0665:  BCF    03.7
0666:  BTFSC  67.0
0667:  BSF    03.7
0668:  MOVF   77,W
0669:  MOVWF  00
066A:  INCF   04,F
066B:  MOVF   78,W
066C:  MOVWF  00
066D:  INCF   04,F
066E:  MOVF   79,W
066F:  MOVWF  00
0670:  INCF   04,F
0671:  MOVF   7A,W
0672:  MOVWF  00
0673:  BCF    03.5
0674:  RETURN
.................... } 
....................  
.................... // Decode sequence step timeout in MCLKs from register value 
.................... // based on VL53L0X_decode_timeout() 
.................... // Note: the original function returned a int32, but the return value is 
.................... // always stored in a int16. 
.................... int16 decodeTimeout(int16 reg_val) 
.................... { 
....................   // format: "(LSByte * 2^MSByte) + 1" 
....................   return (int16)((reg_val & 0x00FF) << 
....................          (int16)((reg_val & 0xFF00) >> 8)) + 1; 
*
04CA:  BSF    03.5
04CB:  MOVF   6A,W
04CC:  MOVWF  6C
04CD:  CLRF   6D
04CE:  CLRF   6E
04CF:  MOVF   6B,W
04D0:  MOVWF  6F
04D1:  CLRF   7A
04D2:  MOVWF  77
04D3:  MOVF   77,F
04D4:  BTFSC  03.2
04D5:  GOTO   4DB
04D6:  BCF    03.0
04D7:  RLF    6C,F
04D8:  RLF    6D,F
04D9:  DECFSZ 77,F
04DA:  GOTO   4D6
04DB:  MOVLW  01
04DC:  ADDWF  6C,W
04DD:  MOVWF  78
04DE:  MOVF   6D,W
04DF:  MOVWF  7A
04E0:  BTFSC  03.0
04E1:  INCF   7A,F
04E2:  MOVF   7A,W
04E3:  MOVWF  79
04E4:  BCF    03.5
04E5:  RETURN
.................... } 
....................  
.................... // Encode sequence step timeout register value from timeout in MCLKs 
.................... // based on VL53L0X_encode_timeout() 
.................... // Note: the original function took a int16, but the argument passed to it 
.................... // is always a int16. 
.................... int16 encodeTimeout(int16 timeout_mclks) 
*
075B:  BSF    03.5
075C:  CLRF   67
075D:  CLRF   66
075E:  CLRF   65
075F:  CLRF   64
0760:  CLRF   69
0761:  CLRF   68
.................... { 
....................   // format: "(LSByte * 2^MSByte) + 1" 
....................  
....................   int32 ls_byte = 0; 
....................   int16 ms_byte = 0; 
....................  
....................   if (timeout_mclks > 0) 
0762:  MOVF   62,F
0763:  BTFSS  03.2
0764:  GOTO   768
0765:  MOVF   63,F
0766:  BTFSC  03.2
0767:  GOTO   7A2
....................   { 
....................     ls_byte = timeout_mclks - 1; 
0768:  MOVLW  01
0769:  SUBWF  62,W
076A:  MOVWF  64
076B:  MOVF   63,W
076C:  MOVWF  65
076D:  MOVLW  00
076E:  BTFSS  03.0
076F:  MOVLW  01
0770:  SUBWF  65,F
0771:  CLRF   66
0772:  CLRF   67
....................  
....................     while ((ls_byte & 0xFFFFFF00) > 0) 
0773:  CLRF   6A
0774:  MOVF   65,W
0775:  MOVWF  6B
0776:  MOVF   66,W
0777:  MOVWF  6C
0778:  MOVF   67,W
0779:  MOVWF  6D
077A:  MOVF   6A,F
077B:  BTFSS  03.2
077C:  GOTO   786
077D:  MOVF   6B,F
077E:  BTFSS  03.2
077F:  GOTO   786
0780:  MOVF   6C,F
0781:  BTFSS  03.2
0782:  GOTO   786
0783:  MOVF   6D,F
0784:  BTFSC  03.2
0785:  GOTO   78F
....................     { 
....................       ls_byte >>= 1; 
0786:  BCF    03.0
0787:  RRF    67,F
0788:  RRF    66,F
0789:  RRF    65,F
078A:  RRF    64,F
....................       ms_byte++; 
078B:  INCF   68,F
078C:  BTFSC  03.2
078D:  INCF   69,F
078E:  GOTO   773
....................     } 
....................  
....................     return (ms_byte << 8) | (ls_byte & 0xFF); 
078F:  MOVF   68,W
0790:  MOVWF  6B
0791:  CLRF   6A
0792:  MOVF   64,W
0793:  MOVWF  77
0794:  CLRF   78
0795:  CLRF   79
0796:  CLRF   7A
0797:  MOVF   77,W
0798:  IORWF  6A,W
0799:  MOVWF  77
079A:  MOVF   78,W
079B:  IORWF  6B,W
079C:  MOVWF  78
079D:  MOVWF  79
079E:  MOVF   77,W
079F:  MOVWF  78
07A0:  GOTO   7A5
....................   } 
07A1:  GOTO   7A5
....................   else { return 0; } 
07A2:  MOVLW  00
07A3:  MOVWF  78
07A4:  MOVWF  79
07A5:  BCF    03.5
07A6:  RETURN
.................... } 
....................  
.................... // Convert sequence step timeout from MCLKs to microseconds with given VCSEL period in PCLKs 
.................... // based on VL53L0X_calc_timeout_us() 
.................... int32 timeoutMclksToMicroseconds(int16 timeout_period_mclks, int8 vcsel_period_pclks) 
*
03F4:  BSF    03.6
03F5:  CLRF   1B
03F6:  CLRF   1A
03F7:  MOVLW  09
03F8:  MOVWF  19
03F9:  CLRF   18
03FA:  CLRF   1F
03FB:  CLRF   1E
03FC:  CLRF   1D
03FD:  BSF    03.5
03FE:  BCF    03.6
03FF:  MOVF   6E,W
0400:  BCF    03.5
0401:  BSF    03.6
0402:  MOVWF  1C
0403:  BCF    03.6
0404:  CALL   377
0405:  MOVF   7A,W
0406:  BSF    03.6
0407:  MOVWF  17
0408:  MOVF   79,W
0409:  MOVWF  16
040A:  MOVF   78,W
040B:  MOVWF  15
040C:  MOVF   77,W
040D:  MOVWF  14
040E:  MOVF   17,W
040F:  MOVWF  1B
0410:  MOVF   16,W
0411:  MOVWF  1A
0412:  MOVF   15,W
0413:  MOVWF  19
0414:  MOVF   14,W
0415:  MOVWF  18
0416:  CLRF   1F
0417:  CLRF   1E
0418:  MOVLW  06
0419:  MOVWF  1D
041A:  MOVLW  77
041B:  MOVWF  1C
041C:  BCF    03.6
041D:  CALL   377
041E:  MOVF   7A,W
041F:  BSF    03.6
0420:  MOVWF  17
0421:  MOVF   79,W
0422:  MOVWF  16
0423:  MOVF   78,W
0424:  MOVWF  15
0425:  MOVF   77,W
0426:  MOVWF  14
0427:  MOVLW  F4
0428:  ADDWF  14,F
0429:  MOVLW  01
042A:  BTFSC  03.0
042B:  MOVLW  02
042C:  ADDWF  15,F
042D:  MOVLW  00
042E:  BTFSC  03.0
042F:  MOVLW  01
0430:  ADDWF  16,F
0431:  MOVLW  00
0432:  BTFSC  03.0
0433:  MOVLW  01
0434:  ADDWF  17,F
0435:  BCF    03.1
0436:  MOVF   17,W
0437:  MOVWF  1B
0438:  MOVF   16,W
0439:  MOVWF  1A
043A:  MOVF   15,W
043B:  MOVWF  19
043C:  MOVF   14,W
043D:  MOVWF  18
043E:  CLRF   1F
043F:  CLRF   1E
0440:  MOVLW  03
0441:  MOVWF  1D
0442:  MOVLW  E8
0443:  MOVWF  1C
0444:  BCF    03.6
0445:  CALL   3A3
0446:  MOVF   7A,W
0447:  BSF    03.6
0448:  MOVWF  13
0449:  MOVF   79,W
044A:  MOVWF  12
044B:  MOVF   78,W
044C:  MOVWF  11
044D:  MOVF   77,W
044E:  MOVWF  10
.................... { 
....................   int32 macro_period_ns = calcMacroPeriod(vcsel_period_pclks); 
....................  
....................   return ((timeout_period_mclks * macro_period_ns) + (macro_period_ns / 2)) / 1000; 
044F:  CLRF   1B
0450:  CLRF   1A
0451:  BSF    03.5
0452:  BCF    03.6
0453:  MOVF   6D,W
0454:  BCF    03.5
0455:  BSF    03.6
0456:  MOVWF  19
0457:  BSF    03.5
0458:  BCF    03.6
0459:  MOVF   6C,W
045A:  BCF    03.5
045B:  BSF    03.6
045C:  MOVWF  18
045D:  MOVF   13,W
045E:  MOVWF  1F
045F:  MOVF   12,W
0460:  MOVWF  1E
0461:  MOVF   11,W
0462:  MOVWF  1D
0463:  MOVF   10,W
0464:  MOVWF  1C
0465:  BCF    03.6
0466:  CALL   377
0467:  MOVF   7A,W
0468:  BSF    03.6
0469:  MOVWF  17
046A:  MOVF   79,W
046B:  MOVWF  16
046C:  MOVF   78,W
046D:  MOVWF  15
046E:  MOVF   77,W
046F:  MOVWF  14
0470:  BCF    03.0
0471:  RRF    13,W
0472:  MOVWF  7A
0473:  RRF    12,W
0474:  MOVWF  79
0475:  RRF    11,W
0476:  MOVWF  78
0477:  RRF    10,W
0478:  MOVWF  77
0479:  ADDWF  14,F
047A:  MOVF   78,W
047B:  BTFSC  03.0
047C:  INCFSZ 78,W
047D:  ADDWF  15,F
047E:  MOVF   79,W
047F:  BTFSC  03.0
0480:  INCFSZ 79,W
0481:  ADDWF  16,F
0482:  MOVF   7A,W
0483:  BTFSC  03.0
0484:  INCFSZ 7A,W
0485:  ADDWF  17,F
0486:  BCF    03.1
0487:  MOVF   17,W
0488:  MOVWF  1B
0489:  MOVF   16,W
048A:  MOVWF  1A
048B:  MOVF   15,W
048C:  MOVWF  19
048D:  MOVF   14,W
048E:  MOVWF  18
048F:  CLRF   1F
0490:  CLRF   1E
0491:  MOVLW  03
0492:  MOVWF  1D
0493:  MOVLW  E8
0494:  MOVWF  1C
0495:  BCF    03.6
0496:  CALL   3A3
0497:  RETURN
.................... } 
....................  
.................... // Convert sequence step timeout from microseconds to MCLKs with given VCSEL period in PCLKs 
.................... // based on VL53L0X_calc_timeout_mclks() 
.................... int32 timeoutMicrosecondsToMclks(int32 timeout_period_us, int8 vcsel_period_pclks) 
*
0675:  BSF    03.6
0676:  CLRF   1B
0677:  CLRF   1A
0678:  MOVLW  09
0679:  MOVWF  19
067A:  CLRF   18
067B:  CLRF   1F
067C:  CLRF   1E
067D:  CLRF   1D
067E:  BSF    03.5
067F:  BCF    03.6
0680:  MOVF   66,W
0681:  BCF    03.5
0682:  BSF    03.6
0683:  MOVWF  1C
0684:  BCF    03.6
0685:  CALL   377
0686:  MOVF   7A,W
0687:  BSF    03.5
0688:  MOVWF  6E
0689:  MOVF   79,W
068A:  MOVWF  6D
068B:  MOVF   78,W
068C:  MOVWF  6C
068D:  MOVF   77,W
068E:  MOVWF  6B
068F:  MOVF   6E,W
0690:  BCF    03.5
0691:  BSF    03.6
0692:  MOVWF  1B
0693:  BSF    03.5
0694:  BCF    03.6
0695:  MOVF   6D,W
0696:  BCF    03.5
0697:  BSF    03.6
0698:  MOVWF  1A
0699:  BSF    03.5
069A:  BCF    03.6
069B:  MOVF   6C,W
069C:  BCF    03.5
069D:  BSF    03.6
069E:  MOVWF  19
069F:  BSF    03.5
06A0:  BCF    03.6
06A1:  MOVF   6B,W
06A2:  BCF    03.5
06A3:  BSF    03.6
06A4:  MOVWF  18
06A5:  CLRF   1F
06A6:  CLRF   1E
06A7:  MOVLW  06
06A8:  MOVWF  1D
06A9:  MOVLW  77
06AA:  MOVWF  1C
06AB:  BCF    03.6
06AC:  CALL   377
06AD:  MOVF   7A,W
06AE:  BSF    03.5
06AF:  MOVWF  6E
06B0:  MOVF   79,W
06B1:  MOVWF  6D
06B2:  MOVF   78,W
06B3:  MOVWF  6C
06B4:  MOVF   77,W
06B5:  MOVWF  6B
06B6:  MOVLW  F4
06B7:  ADDWF  6B,F
06B8:  MOVLW  01
06B9:  BTFSC  03.0
06BA:  MOVLW  02
06BB:  ADDWF  6C,F
06BC:  MOVLW  00
06BD:  BTFSC  03.0
06BE:  MOVLW  01
06BF:  ADDWF  6D,F
06C0:  MOVLW  00
06C1:  BTFSC  03.0
06C2:  MOVLW  01
06C3:  ADDWF  6E,F
06C4:  BCF    03.1
06C5:  MOVF   6E,W
06C6:  BCF    03.5
06C7:  BSF    03.6
06C8:  MOVWF  1B
06C9:  BSF    03.5
06CA:  BCF    03.6
06CB:  MOVF   6D,W
06CC:  BCF    03.5
06CD:  BSF    03.6
06CE:  MOVWF  1A
06CF:  BSF    03.5
06D0:  BCF    03.6
06D1:  MOVF   6C,W
06D2:  BCF    03.5
06D3:  BSF    03.6
06D4:  MOVWF  19
06D5:  BSF    03.5
06D6:  BCF    03.6
06D7:  MOVF   6B,W
06D8:  BCF    03.5
06D9:  BSF    03.6
06DA:  MOVWF  18
06DB:  CLRF   1F
06DC:  CLRF   1E
06DD:  MOVLW  03
06DE:  MOVWF  1D
06DF:  MOVLW  E8
06E0:  MOVWF  1C
06E1:  BCF    03.6
06E2:  CALL   3A3
06E3:  MOVF   7A,W
06E4:  BSF    03.5
06E5:  MOVWF  6A
06E6:  MOVF   79,W
06E7:  MOVWF  69
06E8:  MOVF   78,W
06E9:  MOVWF  68
06EA:  MOVF   77,W
06EB:  MOVWF  67
.................... { 
....................   int32 macro_period_ns = calcMacroPeriod(vcsel_period_pclks); 
....................  
....................   return (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns); 
06EC:  MOVF   65,W
06ED:  BCF    03.5
06EE:  BSF    03.6
06EF:  MOVWF  1B
06F0:  BSF    03.5
06F1:  BCF    03.6
06F2:  MOVF   64,W
06F3:  BCF    03.5
06F4:  BSF    03.6
06F5:  MOVWF  1A
06F6:  BSF    03.5
06F7:  BCF    03.6
06F8:  MOVF   63,W
06F9:  BCF    03.5
06FA:  BSF    03.6
06FB:  MOVWF  19
06FC:  BSF    03.5
06FD:  BCF    03.6
06FE:  MOVF   62,W
06FF:  BCF    03.5
0700:  BSF    03.6
0701:  MOVWF  18
0702:  CLRF   1F
0703:  CLRF   1E
0704:  MOVLW  03
0705:  MOVWF  1D
0706:  MOVLW  E8
0707:  MOVWF  1C
0708:  BCF    03.6
0709:  CALL   377
070A:  MOVF   7A,W
070B:  BSF    03.5
070C:  MOVWF  6E
070D:  MOVF   79,W
070E:  MOVWF  6D
070F:  MOVF   78,W
0710:  MOVWF  6C
0711:  MOVF   77,W
0712:  MOVWF  6B
0713:  BCF    03.0
0714:  RRF    6A,W
0715:  MOVWF  7A
0716:  RRF    69,W
0717:  MOVWF  79
0718:  RRF    68,W
0719:  MOVWF  78
071A:  RRF    67,W
071B:  MOVWF  77
071C:  ADDWF  6B,F
071D:  MOVF   78,W
071E:  BTFSC  03.0
071F:  INCFSZ 78,W
0720:  ADDWF  6C,F
0721:  MOVF   79,W
0722:  BTFSC  03.0
0723:  INCFSZ 79,W
0724:  ADDWF  6D,F
0725:  MOVF   7A,W
0726:  BTFSC  03.0
0727:  INCFSZ 7A,W
0728:  ADDWF  6E,F
0729:  BCF    03.1
072A:  MOVF   6E,W
072B:  BCF    03.5
072C:  BSF    03.6
072D:  MOVWF  1B
072E:  BSF    03.5
072F:  BCF    03.6
0730:  MOVF   6D,W
0731:  BCF    03.5
0732:  BSF    03.6
0733:  MOVWF  1A
0734:  BSF    03.5
0735:  BCF    03.6
0736:  MOVF   6C,W
0737:  BCF    03.5
0738:  BSF    03.6
0739:  MOVWF  19
073A:  BSF    03.5
073B:  BCF    03.6
073C:  MOVF   6B,W
073D:  BCF    03.5
073E:  BSF    03.6
073F:  MOVWF  18
0740:  BSF    03.5
0741:  BCF    03.6
0742:  MOVF   6A,W
0743:  BCF    03.5
0744:  BSF    03.6
0745:  MOVWF  1F
0746:  BSF    03.5
0747:  BCF    03.6
0748:  MOVF   69,W
0749:  BCF    03.5
074A:  BSF    03.6
074B:  MOVWF  1E
074C:  BSF    03.5
074D:  BCF    03.6
074E:  MOVF   68,W
074F:  BCF    03.5
0750:  BSF    03.6
0751:  MOVWF  1D
0752:  BSF    03.5
0753:  BCF    03.6
0754:  MOVF   67,W
0755:  BCF    03.5
0756:  BSF    03.6
0757:  MOVWF  1C
0758:  BCF    03.6
0759:  CALL   3A3
075A:  RETURN
.................... } 
....................  
....................  
.................... // based on VL53L0X_perform_single_ref_calibration() 
.................... boolean performSingleRefCalibration(int8 vhv_init_byte) 
.................... { 
....................   writeReg(SYSRANGE_START, 0x01 | vhv_init_byte); // VL53L0X_REG_SYSRANGE_MODE_START_STOP 
*
094C:  BSF    03.5
094D:  MOVF   3D,W
094E:  IORLW  01
094F:  MOVWF  3E
0950:  CLRF   3F
0951:  MOVF   3E,W
0952:  MOVWF  40
0953:  BCF    0A.3
0954:  BCF    03.5
0955:  CALL   142
0956:  BSF    0A.3
....................  
....................   startTimeout(); 
0957:  MOVF   39,W
0958:  MOVWF  31
0959:  MOVF   38,W
095A:  MOVWF  30
....................   while ((readReg(RESULT_INTERRUPT_STATUS) & 0x07) == 0) 
095B:  MOVLW  13
095C:  BSF    03.5
095D:  MOVWF  69
095E:  BCF    0A.3
095F:  BCF    03.5
0960:  CALL   11C
0961:  BSF    0A.3
0962:  MOVF   78,W
0963:  ANDLW  07
0964:  BTFSS  03.2
0965:  GOTO   191
....................   { 
....................     if (checkTimeoutExpired()) { return false; } 
0966:  MOVF   2D,F
0967:  BTFSS  03.2
0968:  GOTO   16C
0969:  MOVF   2E,F
096A:  BTFSC  03.2
096B:  GOTO   190
096C:  MOVF   30,W
096D:  SUBWF  38,W
096E:  BSF    03.5
096F:  MOVWF  3E
0970:  BCF    03.5
0971:  MOVF   39,W
0972:  BSF    03.5
0973:  MOVWF  3F
0974:  BCF    03.5
0975:  MOVF   31,W
0976:  BTFSS  03.0
0977:  INCFSZ 31,W
0978:  GOTO   17A
0979:  GOTO   17D
097A:  BSF    03.5
097B:  SUBWF  3F,F
097C:  BCF    03.5
097D:  MOVF   2E,W
097E:  BSF    03.5
097F:  SUBWF  3F,W
0980:  BTFSC  03.0
0981:  GOTO   184
0982:  BCF    03.5
0983:  GOTO   190
0984:  BTFSS  03.2
0985:  GOTO   18C
0986:  MOVF   3E,W
0987:  BCF    03.5
0988:  SUBWF  2D,W
0989:  BTFSC  03.0
098A:  GOTO   190
098B:  BSF    03.5
098C:  MOVLW  00
098D:  MOVWF  78
098E:  GOTO   1A4
098F:  BCF    03.5
0990:  GOTO   15B
....................   } 
....................  
....................   writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01); 
0991:  MOVLW  0B
0992:  BSF    03.5
0993:  MOVWF  3F
0994:  MOVLW  01
0995:  MOVWF  40
0996:  BCF    0A.3
0997:  BCF    03.5
0998:  CALL   142
0999:  BSF    0A.3
....................  
....................   writeReg(SYSRANGE_START, 0x00); 
099A:  BSF    03.5
099B:  CLRF   3F
099C:  CLRF   40
099D:  BCF    0A.3
099E:  BCF    03.5
099F:  CALL   142
09A0:  BSF    0A.3
....................  
....................   return true; 
09A1:  MOVLW  01
09A2:  MOVWF  78
09A3:  BSF    03.5
09A4:  BCF    03.5
09A5:  RETURN
.................... } 
....................  
....................  
.................... //!void main() { 
.................... //!   delay_ms(1000); 
.................... //!   init(); 
.................... //! 
.................... //!} 
....................  
....................  

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
